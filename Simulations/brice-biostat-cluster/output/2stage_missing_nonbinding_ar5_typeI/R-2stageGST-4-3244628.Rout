
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> rm(list=ls())
> 
> ## * User interface
> ## cd /projects/biostat01/people/hpl802/DelayedGSD/
> args <- commandArgs(TRUE) ## BATCH MODE
> 
> ## arguments missing, binding, ... in BATCH model (e.g. when running on the server via slurm)
> iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
> n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
> if(length(args)>0){
+     for (arg in args){
+         eval(parse(text=arg))
+     }
+ }
> if(is.na(iter_sim)){ ## arguments for interactive R session (when not running on the server via slurm, iter_sim will be NA)
+     iter_sim <- 1
+     n.iter_sim <- 100
+ 
+     if("missing" %in% ls() == FALSE){ missing <- TRUE }
+     if("binding" %in% ls() == FALSE){ binding <- TRUE }
+     if("cNotBelowFixedc" %in% ls() == FALSE){ cNotBelowFixedc <- TRUE }
+     if("ar.factor" %in% ls() == FALSE){ ar.factor <- 10 }
+     if("delta.factor" %in% ls() == FALSE){ delta.factor <- 0.6 }
+ }
> 
> name <- ""
> if(missing>0){
+     name <- paste(name,"missing",sep="_")
+ }else{
+     name <- paste(name,"nomissing",sep="_")
+ }
> if(cNotBelowFixedc>0){
+     name <- paste(name,"fixC",sep="_")
+ }
> if(binding>0){
+     name <- paste(name,"binding",sep="_")
+ }else{
+     name <- paste(name,"nonbinding",sep="_")
+ }
> name <- paste0("2stage",name,"_ar",ar.factor)
> if(delta.factor>0){
+     name <- paste(name,"power",sep="_")
+ }else{
+     name <- paste(name,"typeI",sep="_")
+ }
> 
> cat("BATCH ",name,": ",iter_sim," over ",n.iter_sim,"\n",sep="")
BATCH 2stage_missing_nonbinding_ar5_typeI: 4 over 100
> cat("Arguments:\n")
Arguments:
> print(data.frame(missing = missing,
+                  binding = binding,
+                  cNotBelowFixedc = cNotBelowFixedc,
+                  ar.factor = ar.factor,
+                  delta.factor = delta.factor), row.names = FALSE)
 missing binding cNotBelowFixedc ar.factor delta.factor
    TRUE   FALSE           FALSE         5            0
> cat("\n")

> 
> ## * Settings
> nsim <- 100 # number of simulations
> method <- 1:3 # methods used to compute the boundaries
>                                         #--- to plan the trial ----
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.58,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.68  #(expected) information rate at each decision analysis
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.5,1)*delta.factor # treatment effect
> ar <- (0.86*2)*2*ar.factor # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As too low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> if(missing){
+     Miss11 <- 5/104 # miss both V1 and V2
+     Miss12 <- 1/104 # miss V1 and but not V2
+     Miss21 <- 6/104 # do not miss V1 and but miss V2
+     Miss22 <- 92/104 # miss none
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE, # to additionnally remove 1 more because some FASFL=N
+                          dimnames = list(c("V1 missing","V1 not missing"), c("V2 missing","V2 not missing")))
+ }else{
+     MyMissProb <- NULL
+ }
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- 0.6 # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> sdPower <- allsd[3]*sqrt(1-cor0j1^2)
> n <- ceiling(2*2*((sdPower/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
> ## adjust for expected withdrawal
> if(missing){
+     n <- n/(1-(Miss11+Miss21))
+ }
> 
> ## * Seed
> set.seed(140786598)
> nsimAll <- n.iter_sim * nsim
> allseeds <- sample.int(n = 1000000000, size = nsimAll, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> 
> ## * Load dependencies
> library(DelayedGSD) ## remotes::install_github("PauloWhite/DelayedGSD")
DelayedGSD version 0.0.5
> source("FCT.R") ## exportGSD function
> 
> ## * Planned boundaries
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+   plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                       alpha=alpha, 
+                                       beta=beta,  
+                                       InfoR.i=informationRates,  
+                                       InfoR.d=c(Id,1),  
+                                       rho_alpha=rho_alpha,  
+                                       rho_beta=rho_beta,  
+                                       method=iMeth,  
+                                       cNotBelowFixedc=cNotBelowFixedc,
+                                       bindingFutility=binding,
+                                       delta=deltaPower)
+   ## summary(plannedB[[1]])
+   ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> RES <- NULL
> 
> ## * Loop
> allj <- seq(1+(iter_sim-1)*nsim, iter_sim*nsim, by = 1)
> #allj <- 572:1000
> for(j in allj){ ## j <- 1 ## 5
+   startComp <- Sys.time()
+   myseedi <- allseeds[j]
+   #myseedi <- 919745562
+   # {{{ TRACE info (e.g. to check the Rout)
+   print(paste0("seed ",myseedi," for ","j=",j," (index ",which(j==allj),") out of ",nsim))
+   # }}}
+   
+   # {{{ generate data
+   ## ** simulate
+   res <- GenData(n=max(nGSD), 
+                  N.fw=2,
+                  rand.block=block,
+                  allsd=allsd,
+                  mean0=mean0,
+                  delta=delta,
+                  ar=ar,
+                  cor.01.1=cor011,
+                  cor.ij.1=corij1,
+                  cor.0j.1=cor0j1,
+                  seed=myseedi,
+                  MissProb=MyMissProb,
+                  DigitsOutcome=2,
+                  TimeFactor=TimeFactor,
+                  DigitsTime=0
+   )
+   d <- res$d
+   ## head(d,n=20)
+   # }}}
+   # {{{ reformat data like those of Corine
+   ## Make data long format
+   ## dd <- FormatAsCase(d)
+   ## head(dd)
+   ## summary(dd)
+   # }}}
+   
+   # {{{ make data available at interim
+   # Here we stop inclusion data collection for the interim analysis as soon as
+   # half of the participants have completed (or had the opportunity to complete) the follow-up 
+   thets <- d$t3[ceiling(nGSD*PropForInterim)]
+   #thet <- d$t3[ceiling(n*PropForInterim)]
+   
+   ## ddi <- FormatAsCase(di) # needed ????
+   ## head(d[d$id==52,])
+   # }}}
+   
+   nX1.interim <- vector()
+   nX2.interim <- vector()
+   nX3.interim <- vector()
+   currentGSD <- vector(mode = "list", length = 3)
+   out.interim <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     # {{{ make data available at interim
+     di <- SelectData(d,t=thets[iMeth])
+     
+     nX1.interim[iMeth] <- sum(!is.na(di$X1))
+     nX2.interim[iMeth] = sum(!is.na(di$X2))
+     nX3.interim[iMeth] = sum(!is.na(di$X3))
+     
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thets[iMeth] + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+     
+     out.interim[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                       export.statistic = TRUE,
+                                       export.ML = TRUE,
+                                       export.MUE = FALSE,
+                                       export.info = TRUE,
+                                       export.predinfo = TRUE,
+                                       export.boundary = TRUE,
+                                       export.decision = TRUE)
+   }
+   ## currentGSD[[1]]
+   ## plot(currentGSD[[1]], legend.x = "bottomleft")
+   
+   
+   out.decision <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thets[iMeth] + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+       ## Non binding: never stop for futility when simulating under the null and always stop for futility when simulating under the alternative
+       ## (then the observed rejection rate should match the nominal type 1 or type 2 error)
+       if(out.interim[[iMeth]]$decision == "stop" && (out.interim[[iMeth]]$reason!="futility" || binding == TRUE || delta.factor > 0)){
+ 
+           currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+           ## plot(currentGSD[[iMeth]])
+       
+           out.decision[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                              export.statistic = TRUE,
+                                              export.ML = TRUE,
+                                              export.MUE = TRUE,
+                                              export.info = TRUE,
+                                              export.predinfo = FALSE,
+                                              export.boundary = TRUE,
+                                              export.decision = TRUE)
+       
+       
+       }else{
+           if(out.interim[[iMeth]]$decision == "stop"){ ## overrule futility boundary
+               currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], overrule.futility = TRUE)
+           }
+           ## update information
+           currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+       
+           out.decision[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                              export.statistic = FALSE,
+                                              export.ML = FALSE,
+                                              export.MUE = FALSE,
+                                              export.info = TRUE,
+                                              export.predinfo = FALSE,
+                                              export.boundary = TRUE,
+                                              export.decision = FALSE)
+       }
+   }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+   
+   ## ** finale
+   out.final <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     dFinal <- d[1:nGSD[iMeth],]
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     if(currentGSD[[iMeth]]$stage[,"type"]=="decision"){
+       
+       out.final[[iMeth]] <- exportGSD(NA)
+       
+     }else{
+       currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+       
+       out.final[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                       export.statistic = TRUE,
+                                       export.ML = TRUE,
+                                       export.MUE = TRUE,
+                                       export.info = TRUE,
+                                       export.predinfo = FALSE,
+                                       export.boundary = TRUE,
+                                       export.decision = TRUE)
+       
+     }
+   }
+   # }}}
+   
+   stopComp <- Sys.time()
+   # {{{ Save results
+   outMerge <- do.call(rbind,lapply(method, function(iMeth){
+     iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+     iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+     iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+     iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+     iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+     return(iMerge)
+   }))
+   
+   ## outMerge[outMerge$method==3,]
+   
+   out <- cbind(
+       ## results
+       outMerge,
+       ## simulation details
+       time.interim = rep(thets,each=3),
+       seed=myseedi,             
+       nX1.interim = rep(nX1.interim,each=3),
+       nX2.interim = rep(nX2.interim,each=3),
+       nX3.interim = rep(nX3.interim,each=3),
+       ## computation time
+       computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+   )
+   ## names(out) <- myColNames
+   RES <- rbind(RES,out)
+   if(j %in% round(quantile(allj, probs = (1:10)/10))){
+       saveRDS(RES,file=file.path("Results",name,paste0("sim-",name,"-",iter_sim,"(tempo)_",nsim,".rds")))
+   }
+   # }}}
+ }
[1] "seed 924433196 for j=301 (index 1) out of 100"
Loading required namespace: nlme
[1] "seed 895094679 for j=302 (index 2) out of 100"
[1] "seed 837185807 for j=303 (index 3) out of 100"
[1] "seed 870141183 for j=304 (index 4) out of 100"
[1] "seed 836423239 for j=305 (index 5) out of 100"
[1] "seed 279131710 for j=306 (index 6) out of 100"
[1] "seed 660357290 for j=307 (index 7) out of 100"
[1] "seed 805301171 for j=308 (index 8) out of 100"
[1] "seed 910801330 for j=309 (index 9) out of 100"
[1] "seed 887621038 for j=310 (index 10) out of 100"
[1] "seed 154643813 for j=311 (index 11) out of 100"
[1] "seed 480727420 for j=312 (index 12) out of 100"
[1] "seed 929803219 for j=313 (index 13) out of 100"
[1] "seed 440879503 for j=314 (index 14) out of 100"
[1] "seed 972993997 for j=315 (index 15) out of 100"
[1] "seed 282000563 for j=316 (index 16) out of 100"
[1] "seed 238316539 for j=317 (index 17) out of 100"
[1] "seed 558296084 for j=318 (index 18) out of 100"
[1] "seed 986715677 for j=319 (index 19) out of 100"
[1] "seed 151919337 for j=320 (index 20) out of 100"
[1] "seed 758721352 for j=321 (index 21) out of 100"
[1] "seed 485155476 for j=322 (index 22) out of 100"
[1] "seed 883891967 for j=323 (index 23) out of 100"
[1] "seed 639211252 for j=324 (index 24) out of 100"
[1] "seed 748417291 for j=325 (index 25) out of 100"
[1] "seed 348348043 for j=326 (index 26) out of 100"
[1] "seed 205393994 for j=327 (index 27) out of 100"
[1] "seed 43864657 for j=328 (index 28) out of 100"
[1] "seed 448337359 for j=329 (index 29) out of 100"
[1] "seed 837145832 for j=330 (index 30) out of 100"
[1] "seed 337658939 for j=331 (index 31) out of 100"
[1] "seed 900888714 for j=332 (index 32) out of 100"
[1] "seed 605573492 for j=333 (index 33) out of 100"
[1] "seed 1899692 for j=334 (index 34) out of 100"
[1] "seed 390178350 for j=335 (index 35) out of 100"
[1] "seed 937915279 for j=336 (index 36) out of 100"
[1] "seed 437642151 for j=337 (index 37) out of 100"
[1] "seed 828322436 for j=338 (index 38) out of 100"
[1] "seed 950927225 for j=339 (index 39) out of 100"
[1] "seed 554671919 for j=340 (index 40) out of 100"
[1] "seed 407448062 for j=341 (index 41) out of 100"
[1] "seed 548056651 for j=342 (index 42) out of 100"
[1] "seed 258242324 for j=343 (index 43) out of 100"
[1] "seed 316434596 for j=344 (index 44) out of 100"
[1] "seed 126478652 for j=345 (index 45) out of 100"
[1] "seed 734479038 for j=346 (index 46) out of 100"
[1] "seed 498787062 for j=347 (index 47) out of 100"
[1] "seed 798950543 for j=348 (index 48) out of 100"
[1] "seed 763609224 for j=349 (index 49) out of 100"
[1] "seed 126842337 for j=350 (index 50) out of 100"
[1] "seed 800962465 for j=351 (index 51) out of 100"
[1] "seed 778913704 for j=352 (index 52) out of 100"
[1] "seed 792957733 for j=353 (index 53) out of 100"
[1] "seed 196427759 for j=354 (index 54) out of 100"
[1] "seed 552636070 for j=355 (index 55) out of 100"
[1] "seed 659185952 for j=356 (index 56) out of 100"
[1] "seed 119141368 for j=357 (index 57) out of 100"
[1] "seed 92432374 for j=358 (index 58) out of 100"
[1] "seed 189558800 for j=359 (index 59) out of 100"
[1] "seed 420402149 for j=360 (index 60) out of 100"
[1] "seed 292821309 for j=361 (index 61) out of 100"
[1] "seed 419035542 for j=362 (index 62) out of 100"
[1] "seed 409632295 for j=363 (index 63) out of 100"
[1] "seed 117360172 for j=364 (index 64) out of 100"
[1] "seed 712860847 for j=365 (index 65) out of 100"
[1] "seed 554764399 for j=366 (index 66) out of 100"
[1] "seed 9125093 for j=367 (index 67) out of 100"
[1] "seed 172031814 for j=368 (index 68) out of 100"
[1] "seed 848940288 for j=369 (index 69) out of 100"
[1] "seed 870095450 for j=370 (index 70) out of 100"
[1] "seed 115809938 for j=371 (index 71) out of 100"
[1] "seed 408187829 for j=372 (index 72) out of 100"
[1] "seed 521220460 for j=373 (index 73) out of 100"
[1] "seed 995876561 for j=374 (index 74) out of 100"
[1] "seed 22060431 for j=375 (index 75) out of 100"
[1] "seed 829899052 for j=376 (index 76) out of 100"
[1] "seed 834010342 for j=377 (index 77) out of 100"
[1] "seed 478453902 for j=378 (index 78) out of 100"
[1] "seed 620647129 for j=379 (index 79) out of 100"
[1] "seed 477933129 for j=380 (index 80) out of 100"
[1] "seed 791464028 for j=381 (index 81) out of 100"
[1] "seed 877874322 for j=382 (index 82) out of 100"
[1] "seed 123944108 for j=383 (index 83) out of 100"
[1] "seed 120035551 for j=384 (index 84) out of 100"
[1] "seed 291883477 for j=385 (index 85) out of 100"
[1] "seed 877960456 for j=386 (index 86) out of 100"
[1] "seed 923737774 for j=387 (index 87) out of 100"
[1] "seed 389051919 for j=388 (index 88) out of 100"
[1] "seed 633744233 for j=389 (index 89) out of 100"
[1] "seed 994754720 for j=390 (index 90) out of 100"
[1] "seed 125961160 for j=391 (index 91) out of 100"
[1] "seed 56369572 for j=392 (index 92) out of 100"
[1] "seed 140724302 for j=393 (index 93) out of 100"
[1] "seed 659180979 for j=394 (index 94) out of 100"
[1] "seed 992544366 for j=395 (index 95) out of 100"
[1] "seed 185184832 for j=396 (index 96) out of 100"
[1] "seed 417922201 for j=397 (index 97) out of 100"
[1] "seed 80737062 for j=398 (index 98) out of 100"
[1] "seed 623350260 for j=399 (index 99) out of 100"
[1] "seed 883544298 for j=400 (index 100) out of 100"
> 
> ## * Export
> rownames(RES) <- NULL
> saveRDS(RES,file=file.path("Results",name,paste0("sim-",name,"-",iter_sim,"_",nsim,".rds")))
> 
> sessionInfo()
R version 4.1.2 (2021-11-01)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux 8.7 (Ootpa)

Matrix products: default
BLAS:   /opt/software/R/4.1.2/lib64/R/lib/libRblas.so
LAPACK: /opt/software/R/4.1.2/lib64/R/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] mvtnorm_1.1-3    DelayedGSD_0.0.5

loaded via a namespace (and not attached):
 [1] magrittr_2.0.3   BB_2019.10-1     tidyselect_1.2.0 munsell_0.5.0   
 [5] lattice_0.20-45  colorspace_2.0-3 xtable_1.8-4     R6_2.5.1        
 [9] quadprog_1.5-8   rlang_1.0.6      fansi_1.0.3      dplyr_1.0.10    
[13] grid_4.1.2       nlme_3.1-153     gtable_0.3.1     gsDesign_3.4.0  
[17] utf8_1.2.2       cli_3.6.0        tibble_3.1.8     lifecycle_1.0.3 
[21] purrr_0.3.5      ggplot2_3.4.0    tidyr_1.2.1      vctrs_0.5.1     
[25] glue_1.6.2       compiler_4.1.2   pillar_1.8.1     generics_0.1.3  
[29] scales_1.2.1     pkgconfig_2.0.3 
> 
> proc.time()
   user  system elapsed 
803.297   1.920 881.844 
