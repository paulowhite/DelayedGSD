
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> rm(list=ls())
> 
> ## * User interface
> ## cd /projects/biostat01/people/hpl802/DelayedGSD/
> args <- commandArgs(TRUE) ## BATCH MODE
> 
> ## arguments missing, binding, ... in BATCH model (e.g. when running on the server via slurm)
> iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
> n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
> if(length(args)>0){
+     for (arg in args){
+         eval(parse(text=arg))
+     }
+ }
> if(is.na(iter_sim)){ ## arguments for interactive R session (when not running on the server via slurm, iter_sim will be NA)
+     iter_sim <- 61
+     n.iter_sim <- 100
+ 
+     if("missing" %in% ls() == FALSE){ missing <- TRUE }
+     if("binding" %in% ls() == FALSE){ binding <- FALSE }
+     if("cNotBelowFixedc" %in% ls() == FALSE){ cNotBelowFixedc <- TRUE }
+     if("ar.factor" %in% ls() == FALSE){ ar.factor <- 10 }
+     if("delta.factor" %in% ls() == FALSE){ delta.factor <- 0.6 }
+     if("n.method" %in% ls() == FALSE){ n.method <- NULL }
+ }
> 
> name <- ""
> if(missing>0){
+     name <- paste(name,"missing",sep="_")
+ }else{
+     name <- paste(name,"nomissing",sep="_")
+ }
> if(cNotBelowFixedc>0){
+     name <- paste(name,"fixC",sep="_")
+ }
> if(binding>0){
+     name <- paste(name,"binding",sep="_")
+ }else{
+     name <- paste(name,"nonbinding",sep="_")
+ }
> name <- paste0("2stage",name,"_ar",ar.factor)
> if(delta.factor>0){
+     name <- paste(name,"power",sep="_")
+ }else{
+     name <- paste(name,"typeI",sep="_")
+ }
> 
> cat("BATCH ",name,": ",iter_sim," over ",n.iter_sim,"\n",sep="")
BATCH 2stage_missing_nonbinding_ar5_power: 3 over 100
> cat("Arguments:\n")
Arguments:
> df.args <- data.frame(missing = missing,
+                       binding = binding,
+                       cNotBelowFixedc = cNotBelowFixedc,
+                       ar.factor = ar.factor,
+                       delta.factor = delta.factor)
> if(!is.null(n.method)){df.args$n.method <- n.method}
> print(df.args, row.names = FALSE)
 missing binding cNotBelowFixedc ar.factor delta.factor n.method
    TRUE   FALSE           FALSE         5          0.6        3
> cat("\n")

> 
> ## * Settings
> nsim <- 100 # number of simulations
> method <- 1:3 # methods used to compute the boundaries
>                                         #--- to plan the trial ----
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.58,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.68  #(expected) information rate at each decision analysis
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.5,1)*delta.factor # treatment effect
> ar <- (0.86*2)*2*ar.factor # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As too low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> if(missing){
+     Miss11 <- 5/104 # miss both V1 and V2
+     Miss12 <- 1/104 # miss V1 and but not V2
+     Miss21 <- 6/104 # do not miss V1 and but miss V2
+     Miss22 <- 92/104 # miss none
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE, # to additionnally remove 1 more because some FASFL=N
+                          dimnames = list(c("V1 missing","V1 not missing"), c("V2 missing","V2 not missing")))
+ }else{
+     MyMissProb <- NULL
+ }
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- 0.6 # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> sdPower <- allsd[3]*sqrt(1-cor0j1^2)
> n <- ceiling(2*2*((sdPower/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
> ## adjust for expected withdrawal
> if(missing){
+     n <- n/(1-(Miss11+Miss21))
+ }
> 
> ## * Seed
> set.seed(140786598)
> nsimAll <- n.iter_sim * nsim
> allseeds <- sample.int(n = 1000000000, size = nsimAll, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> 
> ## * Load dependencies
> library(DelayedGSD) ## remotes::install_github("PauloWhite/DelayedGSD")
DelayedGSD version 0.0.5
> source("FCT.R") ## exportGSD function
> 
> ## * Planned boundaries
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+     plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                         alpha=alpha, 
+                                         beta=beta,  
+                                         InfoR.i=informationRates,  
+                                         InfoR.d=c(Id,1),  
+                                         rho_alpha=rho_alpha,  
+                                         rho_beta=rho_beta,  
+                                         method=iMeth,  
+                                         cNotBelowFixedc=cNotBelowFixedc,
+                                         bindingFutility=binding,
+                                         delta=deltaPower)
+     ## summary(plannedB[[1]])
+     ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> if(is.null(n.method)){
+     inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
+ }else{
+     inflationFactor <- rep(plannedB[[n.method]]$planned$InflationFactor, 3)
+ }
> nGSD <- ceiling(n*inflationFactor)
> RES <- NULL
> 
> cat("Sample size: ",paste(nGSD, collapse = ", "),"\n",sep="")
Sample size: 557, 557, 557
> 
> ## * Loop
> allj <- seq(1+(iter_sim-1)*nsim, iter_sim*nsim, by = 1)
> #allj <- 572:1000
> for(j in allj){ ## j <- 1 ## 5
+   startComp <- Sys.time()
+   myseedi <- allseeds[j]
+   #myseedi <- 94206819
+   # {{{ TRACE info (e.g. to check the Rout)
+   cat("seed ",myseedi," for ","j=",j," (index ",which(j==allj),") out of ",nsim,": ", sep="")
+   # }}}
+   
+   # {{{ generate data
+   ## ** simulate
+   res <- GenData(n=max(nGSD), 
+                  N.fw=2,
+                  rand.block=block,
+                  allsd=allsd,
+                  mean0=mean0,
+                  delta=delta,
+                  ar=ar,
+                  cor.01.1=cor011,
+                  cor.ij.1=corij1,
+                  cor.0j.1=cor0j1,
+                  seed=myseedi,
+                  MissProb=MyMissProb,
+                  DigitsOutcome=2,
+                  TimeFactor=TimeFactor,
+                  DigitsTime=0
+   )
+   d <- res$d
+   ## head(d,n=20)
+   # }}}
+   # {{{ reformat data like those of Corine
+   ## Make data long format
+   ## dd <- FormatAsCase(d)
+   ## head(dd)
+   ## summary(dd)
+   # }}}
+   
+   # {{{ make data available at interim
+   # Here we stop inclusion data collection for the interim analysis as soon as
+   # half of the participants have completed (or had the opportunity to complete) the follow-up 
+   thets <- d$t3[ceiling(nGSD*PropForInterim)]
+   cat("time = ",paste(thets, collapse = ", "),"\n",sep="")
+   #thet <- d$t3[ceiling(n*PropForInterim)]
+   
+   ## ddi <- FormatAsCase(di) # needed ????
+   ## head(d[d$id==52,])
+   # }}}
+   
+   nX1.interim <- vector()
+   nX2.interim <- vector()
+   nX3.interim <- vector()
+   currentGSD <- vector(mode = "list", length = 3)
+   out.interim <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     # {{{ make data available at interim
+     di <- SelectData(d,t=thets[iMeth])
+     
+     nX1.interim[iMeth] <- sum(!is.na(di$X1))
+     nX2.interim[iMeth] = sum(!is.na(di$X2))
+     nX3.interim[iMeth] = sum(!is.na(di$X3))
+     
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thets[iMeth] + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+     
+     out.interim[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                       export.statistic = TRUE,
+                                       export.ML = TRUE,
+                                       export.MUE = FALSE,
+                                       export.info = TRUE,
+                                       export.predinfo = TRUE,
+                                       export.boundary = TRUE,
+                                       export.decision = TRUE)
+   }
+   ## currentGSD[[3]]
+   ## plot(currentGSD[[1]], legend.x = "bottomleft")
+   
+   
+   out.decision <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 3
+     
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thets[iMeth] + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+       ## Non binding: never stop for futility when simulating under the null and always stop for futility when simulating under the alternative
+       ## (then the observed rejection rate should match the nominal type 1 or type 2 error)
+       if(out.interim[[iMeth]]$decision == "stop" && (out.interim[[iMeth]]$reason!="futility" || binding == TRUE || delta.factor > 0)){
+ 
+           currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+           ## plot(currentGSD[[iMeth]])
+       
+           out.decision[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                              export.statistic = TRUE,
+                                              export.ML = TRUE,
+                                              export.MUE = TRUE,
+                                              export.info = TRUE,
+                                              export.predinfo = FALSE,
+                                              export.boundary = TRUE,
+                                              export.decision = TRUE)
+       
+       
+       }else{
+           if(out.interim[[iMeth]]$decision == "stop"){ ## overrule futility boundary
+               currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], overrule.futility = TRUE)
+           }
+           ## update information
+           currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+       }
+   }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+   
+   ## ** finale
+   out.final <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     dFinal <- d[1:nGSD[iMeth],]
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     if(currentGSD[[iMeth]]$stage[,"type"]=="decision"){
+       
+       out.final[[iMeth]] <- cbind(method = iMeth, stage = 2, type = "final", exportGSD(NA))
+       
+     }else{
+       currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+       
+       out.final[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                       export.statistic = TRUE,
+                                       export.ML = TRUE,
+                                       export.MUE = TRUE,
+                                       export.info = TRUE,
+                                       export.predinfo = FALSE,
+                                       export.boundary = TRUE,
+                                       export.decision = TRUE)
+       
+     }
+   }
+   # }}}
+   
+   stopComp <- Sys.time()
+   # {{{ Save results
+   outMerge <- do.call(rbind,lapply(method, function(iMeth){ ## iMeth <- 3
+       cbind(rbind(out.interim[[iMeth]],
+                   out.decision[[iMeth]],
+                   out.final[[iMeth]]),
+             time.interim = thets[iMeth], nX1.interim = nX1.interim[iMeth], nX2.interim = nX2.interim[iMeth], nX3.interim = nX3.interim[iMeth])
+   }))
+   
+   ## outMerge[outMerge$method==3,]
+   
+   out <- cbind(
+       ## results
+       outMerge,
+       ## simulation details
+       seed=myseedi,             
+       ## computation time
+       computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+   )
+   ## names(out) <- myColNames
+   RES <- rbind(RES,out)
+   if(j %in% round(quantile(allj, probs = (1:10)/10))){
+       saveRDS(RES,file=file.path("Results",name,paste0("sim-",name,"-",iter_sim,"(tempo)_",nsim,".rds")))
+   }
+   # }}}
+ }
seed 490538362 for j=201 (index 1) out of 100: time = 249, 249, 249
Loading required namespace: nlme
seed 681447409 for j=202 (index 2) out of 100: time = 246, 246, 246
seed 630952624 for j=203 (index 3) out of 100: time = 250, 250, 250
seed 989577592 for j=204 (index 4) out of 100: time = 244, 244, 244
seed 882776123 for j=205 (index 5) out of 100: time = 247, 247, 247
seed 385749732 for j=206 (index 6) out of 100: time = 260, 260, 260
seed 972336988 for j=207 (index 7) out of 100: time = 241, 241, 241
seed 262773604 for j=208 (index 8) out of 100: time = 257, 257, 257
seed 518564160 for j=209 (index 9) out of 100: time = 250, 250, 250
seed 415337433 for j=210 (index 10) out of 100: time = 246, 246, 246
seed 619269792 for j=211 (index 11) out of 100: time = 256, 256, 256
seed 648949735 for j=212 (index 12) out of 100: time = 252, 252, 252
seed 239841576 for j=213 (index 13) out of 100: time = 266, 266, 266
seed 682164918 for j=214 (index 14) out of 100: time = 246, 246, 246
seed 344367659 for j=215 (index 15) out of 100: time = 260, 260, 260
seed 9380677 for j=216 (index 16) out of 100: time = 240, 240, 240
seed 452906304 for j=217 (index 17) out of 100: time = 249, 249, 249
seed 843734697 for j=218 (index 18) out of 100: time = 253, 253, 253
seed 64323783 for j=219 (index 19) out of 100: time = 255, 255, 255
seed 544731170 for j=220 (index 20) out of 100: time = 252, 252, 252
seed 279612652 for j=221 (index 21) out of 100: time = 236, 236, 236
seed 240460026 for j=222 (index 22) out of 100: time = 252, 252, 252
seed 981628606 for j=223 (index 23) out of 100: time = 250, 250, 250
seed 292306763 for j=224 (index 24) out of 100: time = 270, 270, 270
seed 320359626 for j=225 (index 25) out of 100: time = 239, 239, 239
seed 407971177 for j=226 (index 26) out of 100: time = 258, 258, 258
seed 974477138 for j=227 (index 27) out of 100: time = 252, 252, 252
seed 305512476 for j=228 (index 28) out of 100: time = 252, 252, 252
seed 43539035 for j=229 (index 29) out of 100: time = 257, 257, 257
seed 97077065 for j=230 (index 30) out of 100: time = 251, 251, 251
seed 864982160 for j=231 (index 31) out of 100: time = 266, 266, 266
seed 85179638 for j=232 (index 32) out of 100: time = 261, 261, 261
seed 631660245 for j=233 (index 33) out of 100: time = 249, 249, 249
seed 412898145 for j=234 (index 34) out of 100: time = 257, 257, 257
seed 128038681 for j=235 (index 35) out of 100: time = 267, 267, 267
seed 899087277 for j=236 (index 36) out of 100: time = 262, 262, 262
seed 112928385 for j=237 (index 37) out of 100: time = 256, 256, 256
seed 300183278 for j=238 (index 38) out of 100: time = 257, 257, 257
seed 526955631 for j=239 (index 39) out of 100: time = 260, 260, 260
seed 207958253 for j=240 (index 40) out of 100: time = 263, 263, 263
seed 793211411 for j=241 (index 41) out of 100: time = 252, 252, 252
seed 609610507 for j=242 (index 42) out of 100: time = 270, 270, 270
seed 286743859 for j=243 (index 43) out of 100: time = 246, 246, 246
seed 333612852 for j=244 (index 44) out of 100: time = 258, 258, 258
seed 76699468 for j=245 (index 45) out of 100: time = 246, 246, 246
seed 187368342 for j=246 (index 46) out of 100: time = 272, 272, 272
seed 311559015 for j=247 (index 47) out of 100: time = 268, 268, 268
seed 666802382 for j=248 (index 48) out of 100: time = 253, 253, 253
seed 616156865 for j=249 (index 49) out of 100: time = 261, 261, 261
seed 435485383 for j=250 (index 50) out of 100: time = 243, 243, 243
seed 160066573 for j=251 (index 51) out of 100: time = 274, 274, 274
seed 593980050 for j=252 (index 52) out of 100: time = 261, 261, 261
seed 469423026 for j=253 (index 53) out of 100: time = 257, 257, 257
seed 57833369 for j=254 (index 54) out of 100: time = 247, 247, 247
seed 938014245 for j=255 (index 55) out of 100: time = 248, 248, 248
seed 535433126 for j=256 (index 56) out of 100: time = 264, 264, 264
seed 48438277 for j=257 (index 57) out of 100: time = 241, 241, 241
seed 392525588 for j=258 (index 58) out of 100: time = 243, 243, 243
seed 346547799 for j=259 (index 59) out of 100: time = 247, 247, 247
seed 907841222 for j=260 (index 60) out of 100: time = 253, 253, 253
seed 629382753 for j=261 (index 61) out of 100: time = 253, 253, 253
seed 707405491 for j=262 (index 62) out of 100: time = 253, 253, 253
seed 520151314 for j=263 (index 63) out of 100: time = 251, 251, 251
seed 805983828 for j=264 (index 64) out of 100: time = 253, 253, 253
seed 393425324 for j=265 (index 65) out of 100: time = 245, 245, 245
seed 704912086 for j=266 (index 66) out of 100: time = 267, 267, 267
seed 26665203 for j=267 (index 67) out of 100: time = 250, 250, 250
seed 659752784 for j=268 (index 68) out of 100: time = 250, 250, 250
seed 805221864 for j=269 (index 69) out of 100: time = 251, 251, 251
seed 983661269 for j=270 (index 70) out of 100: time = 250, 250, 250
seed 942855938 for j=271 (index 71) out of 100: time = 258, 258, 258
seed 634440654 for j=272 (index 72) out of 100: time = 266, 266, 266
seed 278956500 for j=273 (index 73) out of 100: time = 244, 244, 244
seed 991711259 for j=274 (index 74) out of 100: time = 259, 259, 259
seed 101428838 for j=275 (index 75) out of 100: time = 254, 254, 254
seed 682175965 for j=276 (index 76) out of 100: time = 255, 255, 255
seed 590422206 for j=277 (index 77) out of 100: time = 241, 241, 241
seed 250543637 for j=278 (index 78) out of 100: time = 248, 248, 248
seed 153490025 for j=279 (index 79) out of 100: time = 258, 258, 258
seed 963393016 for j=280 (index 80) out of 100: time = 259, 259, 259
seed 410663849 for j=281 (index 81) out of 100: time = 266, 266, 266
seed 576971053 for j=282 (index 82) out of 100: time = 250, 250, 250
seed 650419021 for j=283 (index 83) out of 100: time = 254, 254, 254
seed 46395187 for j=284 (index 84) out of 100: time = 257, 257, 257
seed 482241237 for j=285 (index 85) out of 100: time = 245, 245, 245
seed 581795050 for j=286 (index 86) out of 100: time = 250, 250, 250
seed 494050887 for j=287 (index 87) out of 100: time = 249, 249, 249
seed 820940168 for j=288 (index 88) out of 100: time = 249, 249, 249
seed 74928426 for j=289 (index 89) out of 100: time = 254, 254, 254
seed 538363672 for j=290 (index 90) out of 100: time = 254, 254, 254
seed 930141960 for j=291 (index 91) out of 100: time = 260, 260, 260
seed 275842197 for j=292 (index 92) out of 100: time = 255, 255, 255
seed 144487067 for j=293 (index 93) out of 100: time = 237, 237, 237
seed 735585658 for j=294 (index 94) out of 100: time = 258, 258, 258
seed 214976822 for j=295 (index 95) out of 100: time = 247, 247, 247
seed 915785440 for j=296 (index 96) out of 100: time = 253, 253, 253
seed 19286989 for j=297 (index 97) out of 100: time = 252, 252, 252
seed 302375566 for j=298 (index 98) out of 100: time = 254, 254, 254
seed 90771603 for j=299 (index 99) out of 100: time = 256, 256, 256
seed 221547126 for j=300 (index 100) out of 100: time = 251, 251, 251
There were 24 warnings (use warnings() to see them)
> 
> ## * Export
> rownames(RES) <- NULL
> saveRDS(RES,file=file.path("Results",name,paste0("sim-",name,"-",iter_sim,"_",nsim,".rds")))
> 
> sessionInfo()
R version 4.1.2 (2021-11-01)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux 8.8 (Ootpa)

Matrix products: default
BLAS:   /opt/software/R/4.1.2/lib64/R/lib/libRblas.so
LAPACK: /opt/software/R/4.1.2/lib64/R/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] mvtnorm_1.1-3    DelayedGSD_0.0.5

loaded via a namespace (and not attached):
 [1] magrittr_2.0.3   BB_2019.10-1     tidyselect_1.2.0 munsell_0.5.0   
 [5] lattice_0.20-45  colorspace_2.1-0 xtable_1.8-4     R6_2.5.1        
 [9] quadprog_1.5-8   rlang_1.1.0      fansi_1.0.4      dplyr_1.1.0     
[13] grid_4.1.2       nlme_3.1-153     gtable_0.3.3     gsDesign_3.4.0  
[17] utf8_1.2.3       cli_3.6.0        tibble_3.2.1     lifecycle_1.0.3 
[21] purrr_0.3.5      ggplot2_3.4.1    tidyr_1.2.1      vctrs_0.6.1     
[25] glue_1.6.2       compiler_4.1.2   pillar_1.9.0     generics_0.1.3  
[29] scales_1.2.1     pkgconfig_2.0.3 
> 
> proc.time()
   user  system elapsed 
479.738   1.804 487.950 
