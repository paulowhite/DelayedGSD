
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> rm(list=ls())
> 
> ## * User interface
> ## cd /projects/biostat01/people/hpl802/DelayedGSD/
> args <- commandArgs(TRUE) ## BATCH MODE
> 
> ## arguments missing, binding, ... in BATCH model (e.g. when running on the server via slurm)
> iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
> n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
> if(length(args)>0){
+     for (arg in args){
+         eval(parse(text=arg))
+     }
+ }
> if(is.na(iter_sim)){ ## arguments for interactive R session (when not running on the server via slurm, iter_sim will be NA)
+     iter_sim <- 61
+     n.iter_sim <- 100
+ 
+     if("missing" %in% ls() == FALSE){ missing <- TRUE }
+     if("binding" %in% ls() == FALSE){ binding <- FALSE }
+     if("cNotBelowFixedc" %in% ls() == FALSE){ cNotBelowFixedc <- TRUE }
+     if("ar.factor" %in% ls() == FALSE){ ar.factor <- 10 }
+     if("delta.factor" %in% ls() == FALSE){ delta.factor <- 0.6 }
+     if("n.method" %in% ls() == FALSE){ n.method <- NULL }
+ }
> 
> name <- ""
> if(missing>0){
+     name <- paste(name,"missing",sep="_")
+ }else{
+     name <- paste(name,"nomissing",sep="_")
+ }
> if(cNotBelowFixedc>0){
+     name <- paste(name,"fixC",sep="_")
+ }
> if(binding>0){
+     name <- paste(name,"binding",sep="_")
+ }else{
+     name <- paste(name,"nonbinding",sep="_")
+ }
> name <- paste0("2stage",name,"_ar",ar.factor)
> if(delta.factor>0){
+     name <- paste(name,"power",sep="_")
+ }else{
+     name <- paste(name,"typeI",sep="_")
+ }
> 
> cat("BATCH ",name,": ",iter_sim," over ",n.iter_sim,"\n",sep="")
BATCH 2stage_missing_binding_ar5_typeI: 2 over 100
> cat("Arguments:\n")
Arguments:
> df.args <- data.frame(missing = missing,
+                       binding = binding,
+                       cNotBelowFixedc = cNotBelowFixedc,
+                       ar.factor = ar.factor,
+                       delta.factor = delta.factor)
> if(!is.null(n.method)){df.args$n.method <- n.method}
> print(df.args, row.names = FALSE)
 missing binding cNotBelowFixedc ar.factor delta.factor n.method
    TRUE    TRUE           FALSE         5            0        3
> cat("\n")

> 
> ## * Settings
> nsim <- 100 # number of simulations
> method <- 1:3 # methods used to compute the boundaries
>                                         #--- to plan the trial ----
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.58,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.68  #(expected) information rate at each decision analysis
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.5,1)*delta.factor # treatment effect
> ar <- (0.86*2)*2*ar.factor # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As too low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> if(missing){
+     Miss11 <- 5/104 # miss both V1 and V2
+     Miss12 <- 1/104 # miss V1 and but not V2
+     Miss21 <- 6/104 # do not miss V1 and but miss V2
+     Miss22 <- 92/104 # miss none
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE, # to additionnally remove 1 more because some FASFL=N
+                          dimnames = list(c("V1 missing","V1 not missing"), c("V2 missing","V2 not missing")))
+ }else{
+     MyMissProb <- NULL
+ }
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- 0.6 # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> sdPower <- allsd[3]*sqrt(1-cor0j1^2)
> n <- ceiling(2*2*((sdPower/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
> ## adjust for expected withdrawal
> if(missing){
+     n <- n/(1-(Miss11+Miss21))
+ }
> 
> ## * Seed
> set.seed(140786598)
> nsimAll <- n.iter_sim * nsim
> allseeds <- sample.int(n = 1000000000, size = nsimAll, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> 
> ## * Load dependencies
> library(DelayedGSD) ## remotes::install_github("PauloWhite/DelayedGSD")
DelayedGSD version 0.0.5
> source("FCT.R") ## exportGSD function
> 
> ## * Planned boundaries
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+     plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                         alpha=alpha, 
+                                         beta=beta,  
+                                         InfoR.i=informationRates,  
+                                         InfoR.d=c(Id,1),  
+                                         rho_alpha=rho_alpha,  
+                                         rho_beta=rho_beta,  
+                                         method=iMeth,  
+                                         cNotBelowFixedc=cNotBelowFixedc,
+                                         bindingFutility=binding,
+                                         delta=deltaPower)
+     ## summary(plannedB[[1]])
+     ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> if(is.null(n.method)){
+     inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
+ }else{
+     inflationFactor <- rep(plannedB[[n.method]]$planned$InflationFactor, 3)
+ }
> nGSD <- ceiling(n*inflationFactor)
> RES <- NULL
> 
> cat("Sample size: ",paste(nGSD, collapse = ", "),"\n",sep="")
Sample size: 549, 549, 549
> 
> ## * Loop
> allj <- seq(1+(iter_sim-1)*nsim, iter_sim*nsim, by = 1)
> #allj <- 572:1000
> for(j in allj){ ## j <- 1 ## 5
+   startComp <- Sys.time()
+   myseedi <- allseeds[j]
+   #myseedi <- 94206819
+   # {{{ TRACE info (e.g. to check the Rout)
+   cat("seed ",myseedi," for ","j=",j," (index ",which(j==allj),") out of ",nsim,": ", sep="")
+   # }}}
+   
+   # {{{ generate data
+   ## ** simulate
+   res <- GenData(n=max(nGSD), 
+                  N.fw=2,
+                  rand.block=block,
+                  allsd=allsd,
+                  mean0=mean0,
+                  delta=delta,
+                  ar=ar,
+                  cor.01.1=cor011,
+                  cor.ij.1=corij1,
+                  cor.0j.1=cor0j1,
+                  seed=myseedi,
+                  MissProb=MyMissProb,
+                  DigitsOutcome=2,
+                  TimeFactor=TimeFactor,
+                  DigitsTime=0
+   )
+   d <- res$d
+   ## head(d,n=20)
+   # }}}
+   # {{{ reformat data like those of Corine
+   ## Make data long format
+   ## dd <- FormatAsCase(d)
+   ## head(dd)
+   ## summary(dd)
+   # }}}
+   
+   # {{{ make data available at interim
+   # Here we stop inclusion data collection for the interim analysis as soon as
+   # half of the participants have completed (or had the opportunity to complete) the follow-up 
+   thets <- d$t3[ceiling(nGSD*PropForInterim)]
+   cat("time = ",paste(thets, collapse = ", "),"\n",sep="")
+   #thet <- d$t3[ceiling(n*PropForInterim)]
+   
+   ## ddi <- FormatAsCase(di) # needed ????
+   ## head(d[d$id==52,])
+   # }}}
+   
+   nX1.interim <- vector()
+   nX2.interim <- vector()
+   nX3.interim <- vector()
+   currentGSD <- vector(mode = "list", length = 3)
+   out.interim <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     # {{{ make data available at interim
+     di <- SelectData(d,t=thets[iMeth])
+     
+     nX1.interim[iMeth] <- sum(!is.na(di$X1))
+     nX2.interim[iMeth] = sum(!is.na(di$X2))
+     nX3.interim[iMeth] = sum(!is.na(di$X3))
+     
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thets[iMeth] + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+     
+     out.interim[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                       export.statistic = TRUE,
+                                       export.ML = TRUE,
+                                       export.MUE = FALSE,
+                                       export.info = TRUE,
+                                       export.predinfo = TRUE,
+                                       export.boundary = TRUE,
+                                       export.decision = TRUE)
+   }
+   ## currentGSD[[3]]
+   ## plot(currentGSD[[1]], legend.x = "bottomleft")
+   
+   
+   out.decision <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 3
+     
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thets[iMeth] + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+       ## Non binding: never stop for futility when simulating under the null and always stop for futility when simulating under the alternative
+       ## (then the observed rejection rate should match the nominal type 1 or type 2 error)
+       if(out.interim[[iMeth]]$decision == "stop" && (out.interim[[iMeth]]$reason!="futility" || binding == TRUE || delta.factor > 0)){
+ 
+           currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+           ## plot(currentGSD[[iMeth]])
+       
+           out.decision[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                              export.statistic = TRUE,
+                                              export.ML = TRUE,
+                                              export.MUE = TRUE,
+                                              export.info = TRUE,
+                                              export.predinfo = FALSE,
+                                              export.boundary = TRUE,
+                                              export.decision = TRUE)
+       
+       
+       }else{
+           if(out.interim[[iMeth]]$decision == "stop"){ ## overrule futility boundary
+               currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], overrule.futility = TRUE)
+           }
+           ## update information
+           currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+       }
+   }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+   
+   ## ** finale
+   out.final <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     dFinal <- d[1:nGSD[iMeth],]
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     if(currentGSD[[iMeth]]$stage[,"type"]=="decision"){
+       
+       out.final[[iMeth]] <- cbind(method = iMeth, stage = 2, type = "final", exportGSD(NA))
+       
+     }else{
+       currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+       
+       out.final[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                       export.statistic = TRUE,
+                                       export.ML = TRUE,
+                                       export.MUE = TRUE,
+                                       export.info = TRUE,
+                                       export.predinfo = FALSE,
+                                       export.boundary = TRUE,
+                                       export.decision = TRUE)
+       
+     }
+   }
+   # }}}
+   
+   stopComp <- Sys.time()
+   # {{{ Save results
+   outMerge <- do.call(rbind,lapply(method, function(iMeth){ ## iMeth <- 3
+       cbind(rbind(out.interim[[iMeth]],
+                   out.decision[[iMeth]],
+                   out.final[[iMeth]]),
+             time.interim = thets[iMeth], nX1.interim = nX1.interim[iMeth], nX2.interim = nX2.interim[iMeth], nX3.interim = nX3.interim[iMeth])
+   }))
+   
+   ## outMerge[outMerge$method==3,]
+   
+   out <- cbind(
+       ## results
+       outMerge,
+       ## simulation details
+       seed=myseedi,             
+       ## computation time
+       computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+   )
+   ## names(out) <- myColNames
+   RES <- rbind(RES,out)
+   if(j %in% round(quantile(allj, probs = (1:10)/10))){
+       saveRDS(RES,file=file.path("Results",name,paste0("sim-",name,"-",iter_sim,"(tempo)_",nsim,".rds")))
+   }
+   # }}}
+ }
seed 799707165 for j=101 (index 1) out of 100: time = 253, 253, 253
Loading required namespace: nlme
seed 882050130 for j=102 (index 2) out of 100: time = 250, 250, 250
seed 530138129 for j=103 (index 3) out of 100: time = 250, 250, 250
seed 476140307 for j=104 (index 4) out of 100: time = 263, 263, 263
seed 864007415 for j=105 (index 5) out of 100: time = 252, 252, 252
seed 570207711 for j=106 (index 6) out of 100: time = 239, 239, 239
seed 957803202 for j=107 (index 7) out of 100: time = 254, 254, 254
seed 257975782 for j=108 (index 8) out of 100: time = 244, 244, 244
seed 607849912 for j=109 (index 9) out of 100: time = 247, 247, 247
seed 647128233 for j=110 (index 10) out of 100: time = 245, 245, 245
seed 21029435 for j=111 (index 11) out of 100: time = 255, 255, 255
seed 159857053 for j=112 (index 12) out of 100: time = 251, 251, 251
seed 716422565 for j=113 (index 13) out of 100: time = 254, 254, 254
seed 753686887 for j=114 (index 14) out of 100: time = 245, 245, 245
seed 751171836 for j=115 (index 15) out of 100: time = 247, 247, 247
seed 767015167 for j=116 (index 16) out of 100: time = 249, 249, 249
seed 646815346 for j=117 (index 17) out of 100: time = 247, 247, 247
seed 745577292 for j=118 (index 18) out of 100: time = 261, 261, 261
seed 319632638 for j=119 (index 19) out of 100: time = 246, 246, 246
seed 735286221 for j=120 (index 20) out of 100: time = 257, 257, 257
seed 152140172 for j=121 (index 21) out of 100: time = 257, 257, 257
seed 814238822 for j=122 (index 22) out of 100: time = 248, 248, 248
seed 615353586 for j=123 (index 23) out of 100: time = 260, 260, 260
seed 652452693 for j=124 (index 24) out of 100: time = 258, 258, 258
seed 371476637 for j=125 (index 25) out of 100: time = 248, 248, 248
seed 312071325 for j=126 (index 26) out of 100: time = 260, 260, 260
seed 887395738 for j=127 (index 27) out of 100: time = 268, 268, 268
seed 688854522 for j=128 (index 28) out of 100: time = 251, 251, 251
seed 729993870 for j=129 (index 29) out of 100: time = 247, 247, 247
seed 126142903 for j=130 (index 30) out of 100: time = 258, 258, 258
seed 40611370 for j=131 (index 31) out of 100: time = 254, 254, 254
seed 269875711 for j=132 (index 32) out of 100: time = 257, 257, 257
seed 383238979 for j=133 (index 33) out of 100: time = 245, 245, 245
seed 294899077 for j=134 (index 34) out of 100: time = 246, 246, 246
seed 461914938 for j=135 (index 35) out of 100: time = 253, 253, 253
seed 808287379 for j=136 (index 36) out of 100: time = 260, 260, 260
seed 489542607 for j=137 (index 37) out of 100: time = 243, 243, 243
seed 895264200 for j=138 (index 38) out of 100: time = 240, 240, 240
seed 672639426 for j=139 (index 39) out of 100: time = 251, 251, 251
seed 216157967 for j=140 (index 40) out of 100: time = 246, 246, 246
seed 156483194 for j=141 (index 41) out of 100: time = 248, 248, 248
seed 555832371 for j=142 (index 42) out of 100: time = 245, 245, 245
seed 396101422 for j=143 (index 43) out of 100: time = 237, 237, 237
seed 346578820 for j=144 (index 44) out of 100: time = 251, 251, 251
seed 612261637 for j=145 (index 45) out of 100: time = 256, 256, 256
seed 581959460 for j=146 (index 46) out of 100: time = 258, 258, 258
seed 802297987 for j=147 (index 47) out of 100: time = 250, 250, 250
seed 164792212 for j=148 (index 48) out of 100: time = 264, 264, 264
seed 13866862 for j=149 (index 49) out of 100: time = 244, 244, 244
seed 962902738 for j=150 (index 50) out of 100: time = 247, 247, 247
seed 320026601 for j=151 (index 51) out of 100: time = 255, 255, 255
seed 766576404 for j=152 (index 52) out of 100: time = 260, 260, 260
seed 338322647 for j=153 (index 53) out of 100: time = 261, 261, 261
seed 655806552 for j=154 (index 54) out of 100: time = 256, 256, 256
seed 726481795 for j=155 (index 55) out of 100: time = 240, 240, 240
seed 73671590 for j=156 (index 56) out of 100: time = 251, 251, 251
seed 2879512 for j=157 (index 57) out of 100: time = 244, 244, 244
seed 913832209 for j=158 (index 58) out of 100: time = 233, 233, 233
seed 774739301 for j=159 (index 59) out of 100: time = 262, 262, 262
seed 360347589 for j=160 (index 60) out of 100: time = 264, 264, 264
seed 758227503 for j=161 (index 61) out of 100: time = 242, 242, 242
seed 848145487 for j=162 (index 62) out of 100: time = 244, 244, 244
seed 437332194 for j=163 (index 63) out of 100: time = 258, 258, 258
seed 20629376 for j=164 (index 64) out of 100: time = 238, 238, 238
seed 366829002 for j=165 (index 65) out of 100: time = 249, 249, 249
seed 966213659 for j=166 (index 66) out of 100: time = 256, 256, 256
seed 221451166 for j=167 (index 67) out of 100: time = 247, 247, 247
seed 604676609 for j=168 (index 68) out of 100: time = 251, 251, 251
seed 92179223 for j=169 (index 69) out of 100: time = 250, 250, 250
seed 314282948 for j=170 (index 70) out of 100: time = 252, 252, 252
seed 888766811 for j=171 (index 71) out of 100: time = 248, 248, 248
seed 408715782 for j=172 (index 72) out of 100: time = 242, 242, 242
seed 77090460 for j=173 (index 73) out of 100: time = 255, 255, 255
seed 4880016 for j=174 (index 74) out of 100: time = 235, 235, 235
seed 584489058 for j=175 (index 75) out of 100: time = 244, 244, 244
seed 334188719 for j=176 (index 76) out of 100: time = 260, 260, 260
seed 780380852 for j=177 (index 77) out of 100: time = 249, 249, 249
seed 570564166 for j=178 (index 78) out of 100: time = 252, 252, 252
seed 166474102 for j=179 (index 79) out of 100: time = 250, 250, 250
seed 507078367 for j=180 (index 80) out of 100: time = 246, 246, 246
seed 13517263 for j=181 (index 81) out of 100: time = 255, 255, 255
seed 749061016 for j=182 (index 82) out of 100: time = 252, 252, 252
seed 725873542 for j=183 (index 83) out of 100: time = 255, 255, 255
seed 179472920 for j=184 (index 84) out of 100: time = 260, 260, 260
seed 958932347 for j=185 (index 85) out of 100: time = 254, 254, 254
seed 71882019 for j=186 (index 86) out of 100: time = 262, 262, 262
seed 607240809 for j=187 (index 87) out of 100: time = 244, 244, 244
seed 795986819 for j=188 (index 88) out of 100: time = 248, 248, 248
seed 265856112 for j=189 (index 89) out of 100: time = 249, 249, 249
seed 243982067 for j=190 (index 90) out of 100: time = 246, 246, 246
seed 68651081 for j=191 (index 91) out of 100: time = 249, 249, 249
seed 175615120 for j=192 (index 92) out of 100: time = 256, 256, 256
seed 759456289 for j=193 (index 93) out of 100: time = 250, 250, 250
seed 767807739 for j=194 (index 94) out of 100: time = 242, 242, 242
seed 383404226 for j=195 (index 95) out of 100: time = 241, 241, 241
seed 145568503 for j=196 (index 96) out of 100: time = 254, 254, 254
seed 959543946 for j=197 (index 97) out of 100: time = 255, 255, 255
seed 992545374 for j=198 (index 98) out of 100: time = 251, 251, 251
seed 322973128 for j=199 (index 99) out of 100: time = 251, 251, 251
seed 955926135 for j=200 (index 100) out of 100: time = 256, 256, 256
> 
> ## * Export
> rownames(RES) <- NULL
> saveRDS(RES,file=file.path("Results",name,paste0("sim-",name,"-",iter_sim,"_",nsim,".rds")))
> 
> sessionInfo()
R version 4.1.2 (2021-11-01)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux 8.8 (Ootpa)

Matrix products: default
BLAS:   /opt/software/R/4.1.2/lib64/R/lib/libRblas.so
LAPACK: /opt/software/R/4.1.2/lib64/R/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] mvtnorm_1.1-3    DelayedGSD_0.0.5

loaded via a namespace (and not attached):
 [1] magrittr_2.0.3   BB_2019.10-1     tidyselect_1.2.0 munsell_0.5.0   
 [5] lattice_0.20-45  colorspace_2.1-0 xtable_1.8-4     R6_2.5.1        
 [9] quadprog_1.5-8   rlang_1.1.0      fansi_1.0.4      dplyr_1.1.0     
[13] grid_4.1.2       nlme_3.1-153     gtable_0.3.3     gsDesign_3.4.0  
[17] utf8_1.2.3       cli_3.6.0        tibble_3.2.1     lifecycle_1.0.3 
[21] purrr_0.3.5      ggplot2_3.4.1    tidyr_1.2.1      vctrs_0.6.1     
[25] glue_1.6.2       compiler_4.1.2   pillar_1.9.0     generics_0.1.3  
[29] scales_1.2.1     pkgconfig_2.0.3 
> 
> proc.time()
   user  system elapsed 
468.446   1.894 476.438 
