
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> rm(list=ls())
> 
> ## * User interface
> ## cd /projects/biostat01/people/hpl802/DelayedGSD/
> args <- commandArgs(TRUE) ## BATCH MODE
> 
> ## arguments missing, binding, ... in BATCH model (e.g. when running on the server via slurm)
> iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
> n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
> if(length(args)>0){
+     for (arg in args){
+         eval(parse(text=arg))
+     }
+ }
> if(is.na(iter_sim)){ ## arguments for interactive R session (when not running on the server via slurm, iter_sim will be NA)
+     iter_sim <- 1
+     n.iter_sim <- 100
+ 
+     if("missing" %in% ls() == FALSE){ missing <- TRUE }
+     if("binding" %in% ls() == FALSE){ binding <- FALSE }
+     if("cNotBelowFixedc" %in% ls() == FALSE){ cNotBelowFixedc <- TRUE }
+     if("ar.factor" %in% ls() == FALSE){ ar.factor <- 10 }
+     if("delta.factor" %in% ls() == FALSE){ delta.factor <- 0 }
+ }
> 
> name <- ""
> if(missing>0){
+     name <- paste(name,"missing",sep="_")
+ }else{
+     name <- paste(name,"nomissing",sep="_")
+ }
> if(cNotBelowFixedc>0){
+     name <- paste(name,"fixC",sep="_")
+ }
> if(binding>0){
+     name <- paste(name,"binding",sep="_")
+ }else{
+     name <- paste(name,"nonbinding",sep="_")
+ }
> name <- paste0("2stage",name,"_ar",ar.factor)
> if(delta.factor>0){
+     name <- paste(name,"power",sep="_")
+ }else{
+     name <- paste(name,"typeI",sep="_")
+ }
> 
> cat("BATCH ",name,": ",iter_sim," over ",n.iter_sim,"\n",sep="")
BATCH 2stage_missing_fixC_binding_ar5_typeI: 1 over 100
> cat("Arguments:\n")
Arguments:
> print(data.frame(missing = missing,
+                  binding = binding,
+                  cNotBelowFixedc = cNotBelowFixedc,
+                  ar.factor = ar.factor,
+                  delta.factor = delta.factor), row.names = FALSE)
 missing binding cNotBelowFixedc ar.factor delta.factor
    TRUE    TRUE            TRUE         5            0
> cat("\n")

> 
> ## * Settings
> nsim <- 100 # number of simulations
> method <- 1:3 # methods used to compute the boundaries
>                                         #--- to plan the trial ----
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.58,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.68  #(expected) information rate at each decision analysis
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.5,1)*delta.factor # treatment effect
> ar <- (0.86*2)*2*ar.factor # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As too low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> if(missing){
+     Miss11 <- 5/104 # miss both V1 and V2
+     Miss12 <- 1/104 # miss V1 and but not V2
+     Miss21 <- 6/104 # do not miss V1 and but miss V2
+     Miss22 <- 92/104 # miss none
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE, # to additionnally remove 1 more because some FASFL=N
+                          dimnames = list(c("V1 missing","V1 not missing"), c("V2 missing","V2 not missing")))
+ }else{
+     MyMissProb <- NULL
+ }
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- 0.6 # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> sdPower <- allsd[3]*sqrt(1-cor0j1^2)
> n <- ceiling(2*2*((sdPower/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
> ## adjust for expected withdrawal
> if(missing){
+     n <- n/(1-(Miss11+Miss21))
+ }
> 
> ## * Seed
> set.seed(140786598)
> nsimAll <- n.iter_sim * nsim
> allseeds <- sample.int(n = 1000000000, size = nsimAll, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> 
> ## * Load dependencies
> library(DelayedGSD) ## remotes::install_github("PauloWhite/DelayedGSD")
DelayedGSD version 0.0.5
> source("FCT.R") ## exportGSD function
> 
> ## * Planned boundaries
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+   plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                       alpha=alpha, 
+                                       beta=beta,  
+                                       InfoR.i=informationRates,  
+                                       InfoR.d=c(Id,1),  
+                                       rho_alpha=rho_alpha,  
+                                       rho_beta=rho_beta,  
+                                       method=iMeth,  
+                                       cNotBelowFixedc=cNotBelowFixedc,
+                                       bindingFutility=binding,
+                                       delta=deltaPower)
+   ## summary(plannedB[[1]])
+   ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> RES <- NULL
> 
> ## * Loop
> allj <- seq(1+(iter_sim-1)*nsim, iter_sim*nsim, by = 1)
> #allj <- 572:1000
> for(j in allj){ ## j <- 1 ## 5
+   startComp <- Sys.time()
+   myseedi <- allseeds[j]
+   #myseedi <- 955535360
+   # {{{ TRACE info (e.g. to check the Rout)
+   print(paste0("seed ",myseedi," for ","j=",j," (index ",which(j==allj),") out of ",nsim))
+   # }}}
+   
+   # {{{ generate data
+   ## ** simulate
+   res <- GenData(n=max(nGSD), 
+                  N.fw=2,
+                  rand.block=block,
+                  allsd=allsd,
+                  mean0=mean0,
+                  delta=delta,
+                  ar=ar,
+                  cor.01.1=cor011,
+                  cor.ij.1=corij1,
+                  cor.0j.1=cor0j1,
+                  seed=myseedi,
+                  MissProb=MyMissProb,
+                  DigitsOutcome=2,
+                  TimeFactor=TimeFactor,
+                  DigitsTime=0
+   )
+   d <- res$d
+   ## head(d,n=20)
+   # }}}
+   # {{{ reformat data like those of Corine
+   ## Make data long format
+   ## dd <- FormatAsCase(d)
+   ## head(dd)
+   ## summary(dd)
+   # }}}
+   
+   # {{{ make data available at interim
+   # Here we stop inclusion data collection for the interim analysis as soon as
+   # half of the participants have completed (or had the opportunity to complete) the follow-up 
+   thets <- d$t3[ceiling(nGSD*PropForInterim)]
+   #thet <- d$t3[ceiling(n*PropForInterim)]
+   
+   ## ddi <- FormatAsCase(di) # needed ????
+   ## head(d[d$id==52,])
+   # }}}
+   
+   nX1.interim <- vector()
+   nX2.interim <- vector()
+   nX3.interim <- vector()
+   currentGSD <- vector(mode = "list", length = 3)
+   out.interim <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     # {{{ make data available at interim
+     di <- SelectData(d,t=thets[iMeth])
+     
+     nX1.interim[iMeth] <- sum(!is.na(di$X1))
+     nX2.interim[iMeth] = sum(!is.na(di$X2))
+     nX3.interim[iMeth] = sum(!is.na(di$X3))
+     
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thets[iMeth] + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+     
+     out.interim[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                       export.statistic = TRUE,
+                                       export.ML = TRUE,
+                                       export.MUE = FALSE,
+                                       export.info = TRUE,
+                                       export.predinfo = TRUE,
+                                       export.boundary = TRUE,
+                                       export.decision = TRUE)
+   }
+   ## currentGSD[[1]]
+   ## plot(currentGSD[[1]], legend.x = "bottomleft")
+   
+   
+   out.decision <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thets[iMeth] + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+       ## Non binding: never stop for futility when simulating under the null and always stop for futility when simulating under the alternative
+       ## (then the observed rejection rate should match the nominal type 1 or type 2 error)
+       if(out.interim[[iMeth]]$decision == "stop" && (out.interim[[iMeth]]$reason!="futility" || binding == TRUE || delta.factor > 0)){
+ 
+           currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+           ## plot(currentGSD[[iMeth]])
+       
+           out.decision[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                              export.statistic = TRUE,
+                                              export.ML = TRUE,
+                                              export.MUE = TRUE,
+                                              export.info = TRUE,
+                                              export.predinfo = FALSE,
+                                              export.boundary = TRUE,
+                                              export.decision = TRUE)
+       
+       
+       }else{
+           if(out.interim[[iMeth]]$decision == "stop"){ ## overrule futility boundary
+               currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], overrule.futility = TRUE)
+           }
+           ## update information
+           currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+       
+           out.decision[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                              export.statistic = FALSE,
+                                              export.ML = FALSE,
+                                              export.MUE = FALSE,
+                                              export.info = TRUE,
+                                              export.predinfo = FALSE,
+                                              export.boundary = TRUE,
+                                              export.decision = FALSE)
+       }
+   }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+   
+   ## ** finale
+   out.final <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     dFinal <- d[1:nGSD[iMeth],]
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     if(currentGSD[[iMeth]]$stage[,"type"]=="decision"){
+       
+       out.final[[iMeth]] <- exportGSD(NA)
+       
+     }else{
+       currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+       
+       out.final[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                       export.statistic = TRUE,
+                                       export.ML = TRUE,
+                                       export.MUE = TRUE,
+                                       export.info = TRUE,
+                                       export.predinfo = FALSE,
+                                       export.boundary = TRUE,
+                                       export.decision = TRUE)
+       
+     }
+   }
+   # }}}
+   
+   stopComp <- Sys.time()
+   # {{{ Save results
+   outMerge <- do.call(rbind,lapply(method, function(iMeth){
+     iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+     iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+     iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+     iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+     iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+     return(iMerge)
+   }))
+   
+   ## outMerge[outMerge$method==3,]
+   
+   out <- cbind(
+       ## results
+       outMerge,
+       ## simulation details
+       time.interim = rep(thets,each=3),
+       seed=myseedi,             
+       nX1.interim = rep(nX1.interim,each=3),
+       nX2.interim = rep(nX2.interim,each=3),
+       nX3.interim = rep(nX3.interim,each=3),
+       ## computation time
+       computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+   )
+   ## names(out) <- myColNames
+   RES <- rbind(RES,out)
+   if(j %in% round(quantile(allj, probs = (1:10)/10))){
+       saveRDS(RES,file=file.path("Results",name,paste0("sim-",name,"-",iter_sim,"(tempo)_",nsim,".rds")))
+   }
+   # }}}
+ }
[1] "seed 312274104 for j=1 (index 1) out of 100"
Loading required namespace: nlme
[1] "seed 940292917 for j=2 (index 2) out of 100"
[1] "seed 316031316 for j=3 (index 3) out of 100"
[1] "seed 720433051 for j=4 (index 4) out of 100"
[1] "seed 664244032 for j=5 (index 5) out of 100"
[1] "seed 408288863 for j=6 (index 6) out of 100"
[1] "seed 323604876 for j=7 (index 7) out of 100"
[1] "seed 605942573 for j=8 (index 8) out of 100"
[1] "seed 976928862 for j=9 (index 9) out of 100"
[1] "seed 6598542 for j=10 (index 10) out of 100"
[1] "seed 752187451 for j=11 (index 11) out of 100"
[1] "seed 741304709 for j=12 (index 12) out of 100"
[1] "seed 406265869 for j=13 (index 13) out of 100"
[1] "seed 755489412 for j=14 (index 14) out of 100"
[1] "seed 508501482 for j=15 (index 15) out of 100"
[1] "seed 222256069 for j=16 (index 16) out of 100"
[1] "seed 810256876 for j=17 (index 17) out of 100"
[1] "seed 268575222 for j=18 (index 18) out of 100"
[1] "seed 854769519 for j=19 (index 19) out of 100"
[1] "seed 727736567 for j=20 (index 20) out of 100"
[1] "seed 890510558 for j=21 (index 21) out of 100"
[1] "seed 407921501 for j=22 (index 22) out of 100"
[1] "seed 546025307 for j=23 (index 23) out of 100"
[1] "seed 798683941 for j=24 (index 24) out of 100"
[1] "seed 592732265 for j=25 (index 25) out of 100"
[1] "seed 811290881 for j=26 (index 26) out of 100"
[1] "seed 749391034 for j=27 (index 27) out of 100"
[1] "seed 539881094 for j=28 (index 28) out of 100"
[1] "seed 775249103 for j=29 (index 29) out of 100"
[1] "seed 736972486 for j=30 (index 30) out of 100"
[1] "seed 519649137 for j=31 (index 31) out of 100"
[1] "seed 75625975 for j=32 (index 32) out of 100"
[1] "seed 775014027 for j=33 (index 33) out of 100"
[1] "seed 187033903 for j=34 (index 34) out of 100"
[1] "seed 732638575 for j=35 (index 35) out of 100"
[1] "seed 11250549 for j=36 (index 36) out of 100"
[1] "seed 37289357 for j=37 (index 37) out of 100"
[1] "seed 768777780 for j=38 (index 38) out of 100"
[1] "seed 291243934 for j=39 (index 39) out of 100"
[1] "seed 155576218 for j=40 (index 40) out of 100"
[1] "seed 919901530 for j=41 (index 41) out of 100"
[1] "seed 444865923 for j=42 (index 42) out of 100"
[1] "seed 145028903 for j=43 (index 43) out of 100"
[1] "seed 321964005 for j=44 (index 44) out of 100"
[1] "seed 251357380 for j=45 (index 45) out of 100"
[1] "seed 981444995 for j=46 (index 46) out of 100"
[1] "seed 932603551 for j=47 (index 47) out of 100"
[1] "seed 288424263 for j=48 (index 48) out of 100"
[1] "seed 984260677 for j=49 (index 49) out of 100"
[1] "seed 528640882 for j=50 (index 50) out of 100"
[1] "seed 386172892 for j=51 (index 51) out of 100"
[1] "seed 96314452 for j=52 (index 52) out of 100"
[1] "seed 851499118 for j=53 (index 53) out of 100"
[1] "seed 501925971 for j=54 (index 54) out of 100"
[1] "seed 457076778 for j=55 (index 55) out of 100"
[1] "seed 535903070 for j=56 (index 56) out of 100"
[1] "seed 666356223 for j=57 (index 57) out of 100"
[1] "seed 409050955 for j=58 (index 58) out of 100"
[1] "seed 854390247 for j=59 (index 59) out of 100"
[1] "seed 190873709 for j=60 (index 60) out of 100"
[1] "seed 877461284 for j=61 (index 61) out of 100"
[1] "seed 313208341 for j=62 (index 62) out of 100"
[1] "seed 742493360 for j=63 (index 63) out of 100"
[1] "seed 703318247 for j=64 (index 64) out of 100"
[1] "seed 620861571 for j=65 (index 65) out of 100"
[1] "seed 44004955 for j=66 (index 66) out of 100"
[1] "seed 241258496 for j=67 (index 67) out of 100"
[1] "seed 939286176 for j=68 (index 68) out of 100"
[1] "seed 996631745 for j=69 (index 69) out of 100"
[1] "seed 135285823 for j=70 (index 70) out of 100"
[1] "seed 569226216 for j=71 (index 71) out of 100"
[1] "seed 130869105 for j=72 (index 72) out of 100"
[1] "seed 740109336 for j=73 (index 73) out of 100"
[1] "seed 276049919 for j=74 (index 74) out of 100"
[1] "seed 333236620 for j=75 (index 75) out of 100"
[1] "seed 926278617 for j=76 (index 76) out of 100"
[1] "seed 708032608 for j=77 (index 77) out of 100"
[1] "seed 846729510 for j=78 (index 78) out of 100"
[1] "seed 593222359 for j=79 (index 79) out of 100"
[1] "seed 453604871 for j=80 (index 80) out of 100"
[1] "seed 940732194 for j=81 (index 81) out of 100"
[1] "seed 277353396 for j=82 (index 82) out of 100"
[1] "seed 837215739 for j=83 (index 83) out of 100"
[1] "seed 492744058 for j=84 (index 84) out of 100"
[1] "seed 197688318 for j=85 (index 85) out of 100"
[1] "seed 126638832 for j=86 (index 86) out of 100"
[1] "seed 321006898 for j=87 (index 87) out of 100"
[1] "seed 579018813 for j=88 (index 88) out of 100"
[1] "seed 880967589 for j=89 (index 89) out of 100"
[1] "seed 959010204 for j=90 (index 90) out of 100"
[1] "seed 445115603 for j=91 (index 91) out of 100"
[1] "seed 388900960 for j=92 (index 92) out of 100"
[1] "seed 64966669 for j=93 (index 93) out of 100"
[1] "seed 102720002 for j=94 (index 94) out of 100"
[1] "seed 49550467 for j=95 (index 95) out of 100"
[1] "seed 339519918 for j=96 (index 96) out of 100"
[1] "seed 151594999 for j=97 (index 97) out of 100"
[1] "seed 556146183 for j=98 (index 98) out of 100"
[1] "seed 62846262 for j=99 (index 99) out of 100"
[1] "seed 866100745 for j=100 (index 100) out of 100"
> 
> ## * Export
> rownames(RES) <- NULL
> saveRDS(RES,file=file.path("Results",name,paste0("sim-",name,"-",iter_sim,"_",nsim,".rds")))
> 
> sessionInfo()
R version 4.1.2 (2021-11-01)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux 8.7 (Ootpa)

Matrix products: default
BLAS:   /opt/software/R/4.1.2/lib64/R/lib/libRblas.so
LAPACK: /opt/software/R/4.1.2/lib64/R/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] mvtnorm_1.1-3    DelayedGSD_0.0.5

loaded via a namespace (and not attached):
 [1] magrittr_2.0.3   BB_2019.10-1     tidyselect_1.2.0 munsell_0.5.0   
 [5] lattice_0.20-45  colorspace_2.0-3 xtable_1.8-4     R6_2.5.1        
 [9] quadprog_1.5-8   rlang_1.0.6      fansi_1.0.3      dplyr_1.0.10    
[13] grid_4.1.2       nlme_3.1-153     gtable_0.3.1     gsDesign_3.4.0  
[17] utf8_1.2.2       cli_3.6.0        tibble_3.1.8     lifecycle_1.0.3 
[21] purrr_0.3.5      ggplot2_3.4.0    tidyr_1.2.1      vctrs_0.5.1     
[25] glue_1.6.2       compiler_4.1.2   pillar_1.8.1     generics_0.1.3  
[29] scales_1.2.1     pkgconfig_2.0.3 
> 
> proc.time()
   user  system elapsed 
727.816   1.681 736.509 
