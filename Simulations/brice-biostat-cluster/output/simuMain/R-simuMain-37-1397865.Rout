
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### BATCH_simuMain.R --- 
> #----------------------------------------------------------------------
> ## Author: Paul Blanche
> ## Created: Mar  5 2021 (10:56) 
> ## Version: 
> ## Last-Updated: maj  6 2022 (10:22) 
> ##           By: Brice Ozenne
> ##     Update #: 512
> #----------------------------------------------------------------------
> ## 
> ### Commentary: 
> ## 
> ### Change Log:
> #----------------------------------------------------------------------
> ## 
> ### Code:
> 
> rm(list=ls())
>                                    # {{{ parameters
> ## * parameters
> name <- "ScenarioName" # To save the results
> method <- 1:2 # methods used to compute the boundaries
>                                         #---
> myseed <- 140786598
>                                         #--- to plan the trial ----
> NMC <- 250 # number of sequential simulations to run in parallel. Eg. with 250, then we can run 40 scripts in paralell to get N=10,000 runs in total.
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.5,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.55  #(expected) information rate at each decision analysis
> binding <- TRUE
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.6,0.8) # treatment effect
> ar <- (0.86*2)*2 # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As to low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> Miss11 <- 5/104 # miss both V1 and V2
> Miss12 <- 1/104 # miss V1 and but not V2
> Miss21 <- 6/104 # do not miss V1 and but miss V2
> Miss22 <- 92/104 # miss none
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- abs(delta[3]) # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> n <- ceiling(2*2*((allsd[3]/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
> # {{{ Set seeds for parallel computing and reproducibility
> ## * Seed
> iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
> n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
> if(is.na(iter_sim)){iter_sim <- 2}
> if(is.na(n.iter_sim)){n.iter_sim <- 10}
> 
> set.seed(140786598)
> allseeds <- sample.int(n = 10*n.iter_sim*NMC, size = n.iter_sim*NMC, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> # }}}
> 
> # {{{ set path to load and save and othe machine specific variables
> ## * path
> path <- "."
> path.res <- file.path(path,"Results","simuMain")
> if(dir.exists(path.res)==FALSE){
+     if(dir.exists(file.path(path,"Results"))==FALSE){
+     dir.create(file.path(path,"Results"))
+     }
+     dir.create(path.res)
+ }
> path.output <- file.path(path,"output","simuMain")
> if(dir.exists(path.output)==FALSE){
+     if(dir.exists(file.path(path,"output"))==FALSE){
+     dir.create(file.path(path,"output"))
+     }
+     dir.create(path.output)
+ }
> # }}}
> 
> 
> ## * libraries and functions
> library(DelayedGSD)
DelayedGSD version 0.0.2
> ## sourceDir <- function(path, trace = TRUE, ...) {
> ##     for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
> ##         if(trace) cat(nm,":")
> ##         source(file.path(path, nm), ...)
> ##         if(trace) cat("\n")
> ##     }
> ## }
> ## sourceDir(pathToLoad)
>     
> 
> ## * Compute inflation factor and sample size
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+     plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                         alpha=alpha, 
+                                         beta=beta,  
+                                         InfoR.i=informationRates,  
+                                         InfoR.d=c(Id,1),  
+                                         rho_alpha=rho_alpha,  
+                                         rho_beta=rho_beta,  
+                                         method=iMeth,  
+                                         cNotBelowFixedc=FALSE,
+                                         bindingFutility=binding,
+                                         delta=tail(delta,1))
+     ## summary(plannedB[[1]])
+     ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> ##  plot(plannedB[[1]])
> 
> #
> # --- just to check---
> ## n
> ## InfoFixed <- ((qnorm(1-beta)-qnorm(alpha))/(deltaPower))^2
> ## InfoFixed
> ## n/(4*(allsd[3])^2)
> #---
> # }}}
> 
> 
> 
> 
> # {{{ technical details to loop
> RES <- NULL # initialize results to save
> allj <- ((iter_sim-1)*NMC + 1):(iter_sim*NMC) # indices of all iterations (replicates) for this job, accountng for the other jobs running in parallel
> # }}}
> 
> ## * Loop
> for(j in allj){ ## j <- 5 ## 5
+     startComp <- Sys.time()
+     myseedi <- allseeds[j]
+     # {{{ TRACE info (e.g. to check the Rout)
+     print(paste0("seed ",myseedi," for ","j=",which(j==allj)," out of ",NMC, " (i.e. j=",j," in [",(iter_sim-1)*NMC + 1,";",iter_sim*NMC,"], as job id is i=",iter_sim,")"))
+     # }}}
+     # {{{ Missing probabilities
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE) # to additionnally remove 1 more because some FASFL=N
+     colnames(MyMissProb) <- c("V2 missing","V2 not missing")
+     rownames(MyMissProb) <- c("V1 missing","V1 not missing")
+     # }}}
+ 
+                                         # {{{ generate data
+     ## ** simulate
+     res <- GenData(n=n, 
+                    N.fw=2,
+                    rand.block=block,
+                    allsd=allsd,
+                    mean0=mean0,
+                    delta=delta,
+                    ar=ar,
+                    cor.01.1=cor011,
+                    cor.ij.1=corij1,
+                    cor.0j.1=cor0j1,
+                    seed=myseedi,
+                    MissProb=MyMissProb,
+                    DigitsOutcome=2,
+                    TimeFactor=TimeFactor,
+                    DigitsTime=0
+                    )
+     d <- res$d
+     ## head(d,n=20)
+                                         # }}}
+                                         # {{{ reformat data like those of Corine
+     ## Make data long format
+     ## dd <- FormatAsCase(d)
+     ## head(dd)
+     ## summary(dd)
+                                         # }}}
+    
+                                         # {{{ make data available at interim
+                                         # Here we stop inclusion data collection for the interim analysis as soon as
+                                         # half of the participants have completed (or had the opportunity to complete) the follow-up 
+     thet <- d$t3[ceiling(n*PropForInterim)]
+     di <- SelectData(d,t=thet)
+     ## ddi <- FormatAsCase(di) # needed ????
+     ## head(d[d$id==52,])
+                                         # }}}
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thet + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     currentGSD <- vector(mode = "list", length = 3)
+     out.interim <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+ 
+         currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+ 
+         iConfint.interim <- confint(currentGSD[[iMeth]])
+         iInfo.interim <- coef(currentGSD[[iMeth]], type = "information")
+         iBoundary.interim <- coef(currentGSD[[iMeth]], type = "boundary")
+         iDecision.interim <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+         out.interim[[iMeth]] <-  data.frame(statistic = iConfint.interim[1,"statistic"],
+                                             estimate_ML = iConfint.interim[1,"estimate"],
+                                             se_ML = iConfint.interim[1,"se"],
+                                             info = iInfo.interim[1,"Interim"],
+                                             infoPC = iInfo.interim[1,"Interim.pc"],
+                                             info.pred = iInfo.interim[1,"Decision"],
+                                             infoPC.pred = iInfo.interim[1,"Decision.pc"],
+                                             uk = iBoundary.interim[1,"Ebound"],
+                                             lk = iBoundary.interim[1,"Fbound"],
+                                             decision = iDecision.interim["decision","stage 1"],
+                                             reason = iDecision.interim["reason.interim","stage 1"])
+     }
+     ## currentGSD[[1]]
+     ## plot(currentGSD[[1]])
+ 
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thet + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     out.decision <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+           
+         if(out.interim[[iMeth]]$decision == "stop"){
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+             ## plot(currentGSD[[iMeth]])
+ 
+             iConfint.decision <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.decision  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = iConfint.decision[1,"statistic"],
+                                                 p.value_ML = iConfint.decision[iConfint.decision$method == "ML","p.value"],
+                                                 lower_ML = iConfint.decision[iConfint.decision$method == "ML","lower"],
+                                                 upper_ML = iConfint.decision[iConfint.decision$method == "ML","upper"],
+                                                 estimate_ML = iConfint.decision[iConfint.decision$method == "ML","estimate"],
+                                                 p.value_MUE = iConfint.decision[iConfint.decision$method == "MUE","p.value"],
+                                                 lower_MUE = iConfint.decision[iConfint.decision$method == "MUE","lower"],
+                                                 upper_MUE = iConfint.decision[iConfint.decision$method == "MUE","upper"],
+                                                 estimate_MUE = iConfint.decision[iConfint.decision$method == "MUE","estimate"],
+                                                 info = iInfo.decision[1,"Interim"],
+                                                 infoPC = iInfo.decision[1,"Interim.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = unname(iDecision.decision["decision","stage 2"])
+                                                 )
+ 
+         }else{
+             ## update information
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+ 
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = NA,
+                                                 p.value_ML = NA,
+                                                 lower_ML = NA,
+                                                 upper_ML = NA,
+                                                 estimate_ML = NA,
+                                                 p.value_MUE = NA,
+                                                 lower_MUE = NA,
+                                                 upper_MUE = NA,
+                                                 estimate_MUE = NA,
+                                                 info = iInfo.decision[1,"Decision"],
+                                                 infoPC = iInfo.decision[1,"Decision.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = NA)
+         }
+     }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+ 
+     ## ** finale
+     dFinal <- d
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     out.final <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+         if(out.interim[[iMeth]]$decision == "stop"){
+             out.final[[iMeth]] <- data.frame(statistic = NA,
+                                              p.value_ML = NA,
+                                              lower_ML = NA,
+                                              upper_ML = NA,
+                                              estimate_ML = NA,
+                                              p.value_MUE = NA,
+                                              lower_MUE = NA,
+                                              upper_MUE = NA,
+                                              estimate_MUE = NA,
+                                              info = NA,
+                                              infoPC = NA,
+                                              ck = NA,
+                                              decision = NA)
+ 
+         }else{
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+ 
+             ## plot(test)
+             ## summary(test)
+             iConfint.final <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.final <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.final <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.final  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.final[[iMeth]] <- data.frame(statistic = iConfint.final[1,"statistic"],
+                                              p.value_ML = iConfint.final[iConfint.final$method == "ML","p.value"],
+                                              lower_ML = iConfint.final[iConfint.final$method == "ML","lower"],
+                                              upper_ML = iConfint.final[iConfint.final$method == "ML","upper"],
+                                              estimate_ML = iConfint.final[iConfint.final$method == "ML","estimate"],
+                                              p.value_MUE = iConfint.final[iConfint.final$method == "MUE","p.value"],
+                                              lower_MUE = iConfint.final[iConfint.final$method == "MUE","lower"],
+                                              upper_MUE = iConfint.final[iConfint.final$method == "MUE","upper"],
+                                              estimate_MUE = iConfint.final[iConfint.final$method == "MUE","estimate"],
+                                              info = iInfo.final[1,"Interim"],
+                                              infoPC = iInfo.final[1,"Interim.pc"],
+                                              ck = iBoundary.final[1,"Cbound"],
+                                              decision = unname(coef(currentGSD[[iMeth]], type = "decision")["decision","stage 2"])
+                                              )
+         }
+     }
+                                         # }}}
+ 
+     stopComp <- Sys.time()
+                                         # {{{ Save results
+ 
+     outMerge <- do.call(rbind,lapply(method, function(iMeth){
+         iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+         iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+         iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+         iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+         iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+         return(iMerge)
+     }))
+ 
+     ## outMerge[outMerge$method==3,]
+ 
+     out <- cbind(
+         ## results
+         outMerge,
+         ## simulation details
+         time.interim = thet,
+         seed=myseedi,             
+         nX1.interim = sum(!is.na(di$X1)),
+         nX2.interim = sum(!is.na(di$X2)),
+         nX3.interim = sum(!is.na(di$X3)),
+         ## computation time
+         computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+     )
+     ## names(out) <- myColNames
+     RES <- rbind(RES,out)
+     save(RES,file=paste0(path.res,name,"(tempo)-",iter_sim,".rda"))
+                                         # }}}
+ }
[1] "seed 51224 for j=1 out of 250 (i.e. j=9001 in [9001;9250], as job id is i=37)"
Loading required namespace: nlme
[1] "seed 97952 for j=2 out of 250 (i.e. j=9002 in [9001;9250], as job id is i=37)"
[1] "seed 25707 for j=3 out of 250 (i.e. j=9003 in [9001;9250], as job id is i=37)"
[1] "seed 49913 for j=4 out of 250 (i.e. j=9004 in [9001;9250], as job id is i=37)"
[1] "seed 58136 for j=5 out of 250 (i.e. j=9005 in [9001;9250], as job id is i=37)"
[1] "seed 4995 for j=6 out of 250 (i.e. j=9006 in [9001;9250], as job id is i=37)"
[1] "seed 6578 for j=7 out of 250 (i.e. j=9007 in [9001;9250], as job id is i=37)"
[1] "seed 58755 for j=8 out of 250 (i.e. j=9008 in [9001;9250], as job id is i=37)"
[1] "seed 55970 for j=9 out of 250 (i.e. j=9009 in [9001;9250], as job id is i=37)"
[1] "seed 18743 for j=10 out of 250 (i.e. j=9010 in [9001;9250], as job id is i=37)"
[1] "seed 8802 for j=11 out of 250 (i.e. j=9011 in [9001;9250], as job id is i=37)"
[1] "seed 30093 for j=12 out of 250 (i.e. j=9012 in [9001;9250], as job id is i=37)"
[1] "seed 61907 for j=13 out of 250 (i.e. j=9013 in [9001;9250], as job id is i=37)"
[1] "seed 33777 for j=14 out of 250 (i.e. j=9014 in [9001;9250], as job id is i=37)"
[1] "seed 84831 for j=15 out of 250 (i.e. j=9015 in [9001;9250], as job id is i=37)"
[1] "seed 50599 for j=16 out of 250 (i.e. j=9016 in [9001;9250], as job id is i=37)"
[1] "seed 66820 for j=17 out of 250 (i.e. j=9017 in [9001;9250], as job id is i=37)"
[1] "seed 57061 for j=18 out of 250 (i.e. j=9018 in [9001;9250], as job id is i=37)"
[1] "seed 48369 for j=19 out of 250 (i.e. j=9019 in [9001;9250], as job id is i=37)"
[1] "seed 48768 for j=20 out of 250 (i.e. j=9020 in [9001;9250], as job id is i=37)"
[1] "seed 89156 for j=21 out of 250 (i.e. j=9021 in [9001;9250], as job id is i=37)"
[1] "seed 75489 for j=22 out of 250 (i.e. j=9022 in [9001;9250], as job id is i=37)"
[1] "seed 35501 for j=23 out of 250 (i.e. j=9023 in [9001;9250], as job id is i=37)"
[1] "seed 13712 for j=24 out of 250 (i.e. j=9024 in [9001;9250], as job id is i=37)"
[1] "seed 77283 for j=25 out of 250 (i.e. j=9025 in [9001;9250], as job id is i=37)"
[1] "seed 18001 for j=26 out of 250 (i.e. j=9026 in [9001;9250], as job id is i=37)"
[1] "seed 59676 for j=27 out of 250 (i.e. j=9027 in [9001;9250], as job id is i=37)"
[1] "seed 30907 for j=28 out of 250 (i.e. j=9028 in [9001;9250], as job id is i=37)"
[1] "seed 72512 for j=29 out of 250 (i.e. j=9029 in [9001;9250], as job id is i=37)"
[1] "seed 89004 for j=30 out of 250 (i.e. j=9030 in [9001;9250], as job id is i=37)"
[1] "seed 27418 for j=31 out of 250 (i.e. j=9031 in [9001;9250], as job id is i=37)"
[1] "seed 55807 for j=32 out of 250 (i.e. j=9032 in [9001;9250], as job id is i=37)"
[1] "seed 48367 for j=33 out of 250 (i.e. j=9033 in [9001;9250], as job id is i=37)"
[1] "seed 90393 for j=34 out of 250 (i.e. j=9034 in [9001;9250], as job id is i=37)"
[1] "seed 6254 for j=35 out of 250 (i.e. j=9035 in [9001;9250], as job id is i=37)"
[1] "seed 14229 for j=36 out of 250 (i.e. j=9036 in [9001;9250], as job id is i=37)"
[1] "seed 30282 for j=37 out of 250 (i.e. j=9037 in [9001;9250], as job id is i=37)"
[1] "seed 70949 for j=38 out of 250 (i.e. j=9038 in [9001;9250], as job id is i=37)"
[1] "seed 18569 for j=39 out of 250 (i.e. j=9039 in [9001;9250], as job id is i=37)"
[1] "seed 82040 for j=40 out of 250 (i.e. j=9040 in [9001;9250], as job id is i=37)"
[1] "seed 24854 for j=41 out of 250 (i.e. j=9041 in [9001;9250], as job id is i=37)"
[1] "seed 48491 for j=42 out of 250 (i.e. j=9042 in [9001;9250], as job id is i=37)"
[1] "seed 46691 for j=43 out of 250 (i.e. j=9043 in [9001;9250], as job id is i=37)"
[1] "seed 92389 for j=44 out of 250 (i.e. j=9044 in [9001;9250], as job id is i=37)"
[1] "seed 21970 for j=45 out of 250 (i.e. j=9045 in [9001;9250], as job id is i=37)"
[1] "seed 50996 for j=46 out of 250 (i.e. j=9046 in [9001;9250], as job id is i=37)"
[1] "seed 56223 for j=47 out of 250 (i.e. j=9047 in [9001;9250], as job id is i=37)"
[1] "seed 45980 for j=48 out of 250 (i.e. j=9048 in [9001;9250], as job id is i=37)"
[1] "seed 84062 for j=49 out of 250 (i.e. j=9049 in [9001;9250], as job id is i=37)"
[1] "seed 96631 for j=50 out of 250 (i.e. j=9050 in [9001;9250], as job id is i=37)"
[1] "seed 20526 for j=51 out of 250 (i.e. j=9051 in [9001;9250], as job id is i=37)"
[1] "seed 70932 for j=52 out of 250 (i.e. j=9052 in [9001;9250], as job id is i=37)"
[1] "seed 17400 for j=53 out of 250 (i.e. j=9053 in [9001;9250], as job id is i=37)"
[1] "seed 14290 for j=54 out of 250 (i.e. j=9054 in [9001;9250], as job id is i=37)"
[1] "seed 11278 for j=55 out of 250 (i.e. j=9055 in [9001;9250], as job id is i=37)"
[1] "seed 36374 for j=56 out of 250 (i.e. j=9056 in [9001;9250], as job id is i=37)"
[1] "seed 98289 for j=57 out of 250 (i.e. j=9057 in [9001;9250], as job id is i=37)"
[1] "seed 31420 for j=58 out of 250 (i.e. j=9058 in [9001;9250], as job id is i=37)"
[1] "seed 38611 for j=59 out of 250 (i.e. j=9059 in [9001;9250], as job id is i=37)"
[1] "seed 52562 for j=60 out of 250 (i.e. j=9060 in [9001;9250], as job id is i=37)"
[1] "seed 53509 for j=61 out of 250 (i.e. j=9061 in [9001;9250], as job id is i=37)"
[1] "seed 54407 for j=62 out of 250 (i.e. j=9062 in [9001;9250], as job id is i=37)"
[1] "seed 80835 for j=63 out of 250 (i.e. j=9063 in [9001;9250], as job id is i=37)"
[1] "seed 68525 for j=64 out of 250 (i.e. j=9064 in [9001;9250], as job id is i=37)"
[1] "seed 51591 for j=65 out of 250 (i.e. j=9065 in [9001;9250], as job id is i=37)"
[1] "seed 16859 for j=66 out of 250 (i.e. j=9066 in [9001;9250], as job id is i=37)"
[1] "seed 97065 for j=67 out of 250 (i.e. j=9067 in [9001;9250], as job id is i=37)"
[1] "seed 93247 for j=68 out of 250 (i.e. j=9068 in [9001;9250], as job id is i=37)"
[1] "seed 17175 for j=69 out of 250 (i.e. j=9069 in [9001;9250], as job id is i=37)"
[1] "seed 43793 for j=70 out of 250 (i.e. j=9070 in [9001;9250], as job id is i=37)"
[1] "seed 36502 for j=71 out of 250 (i.e. j=9071 in [9001;9250], as job id is i=37)"
[1] "seed 97452 for j=72 out of 250 (i.e. j=9072 in [9001;9250], as job id is i=37)"
[1] "seed 26110 for j=73 out of 250 (i.e. j=9073 in [9001;9250], as job id is i=37)"
[1] "seed 94412 for j=74 out of 250 (i.e. j=9074 in [9001;9250], as job id is i=37)"
[1] "seed 74834 for j=75 out of 250 (i.e. j=9075 in [9001;9250], as job id is i=37)"
[1] "seed 51096 for j=76 out of 250 (i.e. j=9076 in [9001;9250], as job id is i=37)"
[1] "seed 62509 for j=77 out of 250 (i.e. j=9077 in [9001;9250], as job id is i=37)"
[1] "seed 54639 for j=78 out of 250 (i.e. j=9078 in [9001;9250], as job id is i=37)"
[1] "seed 28744 for j=79 out of 250 (i.e. j=9079 in [9001;9250], as job id is i=37)"
[1] "seed 31551 for j=80 out of 250 (i.e. j=9080 in [9001;9250], as job id is i=37)"
[1] "seed 35841 for j=81 out of 250 (i.e. j=9081 in [9001;9250], as job id is i=37)"
[1] "seed 95675 for j=82 out of 250 (i.e. j=9082 in [9001;9250], as job id is i=37)"
[1] "seed 81055 for j=83 out of 250 (i.e. j=9083 in [9001;9250], as job id is i=37)"
[1] "seed 71615 for j=84 out of 250 (i.e. j=9084 in [9001;9250], as job id is i=37)"
[1] "seed 58088 for j=85 out of 250 (i.e. j=9085 in [9001;9250], as job id is i=37)"
[1] "seed 25661 for j=86 out of 250 (i.e. j=9086 in [9001;9250], as job id is i=37)"
[1] "seed 70762 for j=87 out of 250 (i.e. j=9087 in [9001;9250], as job id is i=37)"
[1] "seed 69263 for j=88 out of 250 (i.e. j=9088 in [9001;9250], as job id is i=37)"
[1] "seed 39079 for j=89 out of 250 (i.e. j=9089 in [9001;9250], as job id is i=37)"
[1] "seed 22265 for j=90 out of 250 (i.e. j=9090 in [9001;9250], as job id is i=37)"
[1] "seed 54312 for j=91 out of 250 (i.e. j=9091 in [9001;9250], as job id is i=37)"
[1] "seed 19186 for j=92 out of 250 (i.e. j=9092 in [9001;9250], as job id is i=37)"
[1] "seed 17922 for j=93 out of 250 (i.e. j=9093 in [9001;9250], as job id is i=37)"
[1] "seed 90333 for j=94 out of 250 (i.e. j=9094 in [9001;9250], as job id is i=37)"
[1] "seed 8298 for j=95 out of 250 (i.e. j=9095 in [9001;9250], as job id is i=37)"
[1] "seed 46167 for j=96 out of 250 (i.e. j=9096 in [9001;9250], as job id is i=37)"
[1] "seed 88068 for j=97 out of 250 (i.e. j=9097 in [9001;9250], as job id is i=37)"
[1] "seed 90775 for j=98 out of 250 (i.e. j=9098 in [9001;9250], as job id is i=37)"
[1] "seed 97797 for j=99 out of 250 (i.e. j=9099 in [9001;9250], as job id is i=37)"
[1] "seed 59076 for j=100 out of 250 (i.e. j=9100 in [9001;9250], as job id is i=37)"
[1] "seed 82106 for j=101 out of 250 (i.e. j=9101 in [9001;9250], as job id is i=37)"
[1] "seed 26361 for j=102 out of 250 (i.e. j=9102 in [9001;9250], as job id is i=37)"
[1] "seed 50849 for j=103 out of 250 (i.e. j=9103 in [9001;9250], as job id is i=37)"
[1] "seed 28127 for j=104 out of 250 (i.e. j=9104 in [9001;9250], as job id is i=37)"
[1] "seed 93368 for j=105 out of 250 (i.e. j=9105 in [9001;9250], as job id is i=37)"
[1] "seed 92732 for j=106 out of 250 (i.e. j=9106 in [9001;9250], as job id is i=37)"
[1] "seed 62219 for j=107 out of 250 (i.e. j=9107 in [9001;9250], as job id is i=37)"
[1] "seed 4166 for j=108 out of 250 (i.e. j=9108 in [9001;9250], as job id is i=37)"
[1] "seed 13737 for j=109 out of 250 (i.e. j=9109 in [9001;9250], as job id is i=37)"
[1] "seed 92976 for j=110 out of 250 (i.e. j=9110 in [9001;9250], as job id is i=37)"
[1] "seed 42692 for j=111 out of 250 (i.e. j=9111 in [9001;9250], as job id is i=37)"
[1] "seed 94966 for j=112 out of 250 (i.e. j=9112 in [9001;9250], as job id is i=37)"
[1] "seed 99982 for j=113 out of 250 (i.e. j=9113 in [9001;9250], as job id is i=37)"
[1] "seed 18899 for j=114 out of 250 (i.e. j=9114 in [9001;9250], as job id is i=37)"
[1] "seed 30446 for j=115 out of 250 (i.e. j=9115 in [9001;9250], as job id is i=37)"
[1] "seed 55870 for j=116 out of 250 (i.e. j=9116 in [9001;9250], as job id is i=37)"
[1] "seed 58035 for j=117 out of 250 (i.e. j=9117 in [9001;9250], as job id is i=37)"
[1] "seed 42007 for j=118 out of 250 (i.e. j=9118 in [9001;9250], as job id is i=37)"
[1] "seed 56106 for j=119 out of 250 (i.e. j=9119 in [9001;9250], as job id is i=37)"
[1] "seed 2202 for j=120 out of 250 (i.e. j=9120 in [9001;9250], as job id is i=37)"
[1] "seed 50186 for j=121 out of 250 (i.e. j=9121 in [9001;9250], as job id is i=37)"
[1] "seed 49142 for j=122 out of 250 (i.e. j=9122 in [9001;9250], as job id is i=37)"
[1] "seed 47985 for j=123 out of 250 (i.e. j=9123 in [9001;9250], as job id is i=37)"
[1] "seed 56722 for j=124 out of 250 (i.e. j=9124 in [9001;9250], as job id is i=37)"
[1] "seed 85400 for j=125 out of 250 (i.e. j=9125 in [9001;9250], as job id is i=37)"
[1] "seed 42748 for j=126 out of 250 (i.e. j=9126 in [9001;9250], as job id is i=37)"
[1] "seed 48906 for j=127 out of 250 (i.e. j=9127 in [9001;9250], as job id is i=37)"
[1] "seed 92199 for j=128 out of 250 (i.e. j=9128 in [9001;9250], as job id is i=37)"
[1] "seed 42907 for j=129 out of 250 (i.e. j=9129 in [9001;9250], as job id is i=37)"
[1] "seed 6257 for j=130 out of 250 (i.e. j=9130 in [9001;9250], as job id is i=37)"
[1] "seed 42410 for j=131 out of 250 (i.e. j=9131 in [9001;9250], as job id is i=37)"
[1] "seed 43964 for j=132 out of 250 (i.e. j=9132 in [9001;9250], as job id is i=37)"
[1] "seed 12684 for j=133 out of 250 (i.e. j=9133 in [9001;9250], as job id is i=37)"
[1] "seed 87237 for j=134 out of 250 (i.e. j=9134 in [9001;9250], as job id is i=37)"
[1] "seed 5490 for j=135 out of 250 (i.e. j=9135 in [9001;9250], as job id is i=37)"
[1] "seed 10014 for j=136 out of 250 (i.e. j=9136 in [9001;9250], as job id is i=37)"
[1] "seed 67889 for j=137 out of 250 (i.e. j=9137 in [9001;9250], as job id is i=37)"
[1] "seed 45503 for j=138 out of 250 (i.e. j=9138 in [9001;9250], as job id is i=37)"
[1] "seed 63660 for j=139 out of 250 (i.e. j=9139 in [9001;9250], as job id is i=37)"
[1] "seed 45090 for j=140 out of 250 (i.e. j=9140 in [9001;9250], as job id is i=37)"
[1] "seed 77325 for j=141 out of 250 (i.e. j=9141 in [9001;9250], as job id is i=37)"
[1] "seed 38939 for j=142 out of 250 (i.e. j=9142 in [9001;9250], as job id is i=37)"
[1] "seed 38535 for j=143 out of 250 (i.e. j=9143 in [9001;9250], as job id is i=37)"
[1] "seed 34040 for j=144 out of 250 (i.e. j=9144 in [9001;9250], as job id is i=37)"
[1] "seed 12658 for j=145 out of 250 (i.e. j=9145 in [9001;9250], as job id is i=37)"
[1] "seed 85380 for j=146 out of 250 (i.e. j=9146 in [9001;9250], as job id is i=37)"
[1] "seed 82910 for j=147 out of 250 (i.e. j=9147 in [9001;9250], as job id is i=37)"
[1] "seed 11226 for j=148 out of 250 (i.e. j=9148 in [9001;9250], as job id is i=37)"
Error in uniroot(function(x) { : 
  f() values at end points not of opposite sign
Calls: update ... update.delayedGSD -> updateBoundaries -> updateMethod1 -> uniroot
In addition: Warning messages:
1: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

2: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

3: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

4: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

5: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

6: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

7: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

8: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

Execution halted
