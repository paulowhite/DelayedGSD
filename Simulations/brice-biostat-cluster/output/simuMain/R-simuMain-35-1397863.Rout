
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### BATCH_simuMain.R --- 
> #----------------------------------------------------------------------
> ## Author: Paul Blanche
> ## Created: Mar  5 2021 (10:56) 
> ## Version: 
> ## Last-Updated: maj  6 2022 (10:22) 
> ##           By: Brice Ozenne
> ##     Update #: 512
> #----------------------------------------------------------------------
> ## 
> ### Commentary: 
> ## 
> ### Change Log:
> #----------------------------------------------------------------------
> ## 
> ### Code:
> 
> rm(list=ls())
>                                    # {{{ parameters
> ## * parameters
> name <- "ScenarioName" # To save the results
> method <- 1:2 # methods used to compute the boundaries
>                                         #---
> myseed <- 140786598
>                                         #--- to plan the trial ----
> NMC <- 250 # number of sequential simulations to run in parallel. Eg. with 250, then we can run 40 scripts in paralell to get N=10,000 runs in total.
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.5,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.55  #(expected) information rate at each decision analysis
> binding <- TRUE
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.6,0.8) # treatment effect
> ar <- (0.86*2)*2 # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As to low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> Miss11 <- 5/104 # miss both V1 and V2
> Miss12 <- 1/104 # miss V1 and but not V2
> Miss21 <- 6/104 # do not miss V1 and but miss V2
> Miss22 <- 92/104 # miss none
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- abs(delta[3]) # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> n <- ceiling(2*2*((allsd[3]/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
> # {{{ Set seeds for parallel computing and reproducibility
> ## * Seed
> iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
> n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
> if(is.na(iter_sim)){iter_sim <- 2}
> if(is.na(n.iter_sim)){n.iter_sim <- 10}
> 
> set.seed(140786598)
> allseeds <- sample.int(n = 10*n.iter_sim*NMC, size = n.iter_sim*NMC, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> # }}}
> 
> # {{{ set path to load and save and othe machine specific variables
> ## * path
> path <- "."
> path.res <- file.path(path,"Results","simuMain")
> if(dir.exists(path.res)==FALSE){
+     if(dir.exists(file.path(path,"Results"))==FALSE){
+     dir.create(file.path(path,"Results"))
+     }
+     dir.create(path.res)
+ }
> path.output <- file.path(path,"output","simuMain")
> if(dir.exists(path.output)==FALSE){
+     if(dir.exists(file.path(path,"output"))==FALSE){
+     dir.create(file.path(path,"output"))
+     }
+     dir.create(path.output)
+ }
> # }}}
> 
> 
> ## * libraries and functions
> library(DelayedGSD)
DelayedGSD version 0.0.2
> ## sourceDir <- function(path, trace = TRUE, ...) {
> ##     for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
> ##         if(trace) cat(nm,":")
> ##         source(file.path(path, nm), ...)
> ##         if(trace) cat("\n")
> ##     }
> ## }
> ## sourceDir(pathToLoad)
>     
> 
> ## * Compute inflation factor and sample size
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+     plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                         alpha=alpha, 
+                                         beta=beta,  
+                                         InfoR.i=informationRates,  
+                                         InfoR.d=c(Id,1),  
+                                         rho_alpha=rho_alpha,  
+                                         rho_beta=rho_beta,  
+                                         method=iMeth,  
+                                         cNotBelowFixedc=FALSE,
+                                         bindingFutility=binding,
+                                         delta=tail(delta,1))
+     ## summary(plannedB[[1]])
+     ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> ##  plot(plannedB[[1]])
> 
> #
> # --- just to check---
> ## n
> ## InfoFixed <- ((qnorm(1-beta)-qnorm(alpha))/(deltaPower))^2
> ## InfoFixed
> ## n/(4*(allsd[3])^2)
> #---
> # }}}
> 
> 
> 
> 
> # {{{ technical details to loop
> RES <- NULL # initialize results to save
> allj <- ((iter_sim-1)*NMC + 1):(iter_sim*NMC) # indices of all iterations (replicates) for this job, accountng for the other jobs running in parallel
> # }}}
> 
> ## * Loop
> for(j in allj){ ## j <- 5 ## 5
+     startComp <- Sys.time()
+     myseedi <- allseeds[j]
+     # {{{ TRACE info (e.g. to check the Rout)
+     print(paste0("seed ",myseedi," for ","j=",which(j==allj)," out of ",NMC, " (i.e. j=",j," in [",(iter_sim-1)*NMC + 1,";",iter_sim*NMC,"], as job id is i=",iter_sim,")"))
+     # }}}
+     # {{{ Missing probabilities
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE) # to additionnally remove 1 more because some FASFL=N
+     colnames(MyMissProb) <- c("V2 missing","V2 not missing")
+     rownames(MyMissProb) <- c("V1 missing","V1 not missing")
+     # }}}
+ 
+                                         # {{{ generate data
+     ## ** simulate
+     res <- GenData(n=n, 
+                    N.fw=2,
+                    rand.block=block,
+                    allsd=allsd,
+                    mean0=mean0,
+                    delta=delta,
+                    ar=ar,
+                    cor.01.1=cor011,
+                    cor.ij.1=corij1,
+                    cor.0j.1=cor0j1,
+                    seed=myseedi,
+                    MissProb=MyMissProb,
+                    DigitsOutcome=2,
+                    TimeFactor=TimeFactor,
+                    DigitsTime=0
+                    )
+     d <- res$d
+     ## head(d,n=20)
+                                         # }}}
+                                         # {{{ reformat data like those of Corine
+     ## Make data long format
+     ## dd <- FormatAsCase(d)
+     ## head(dd)
+     ## summary(dd)
+                                         # }}}
+    
+                                         # {{{ make data available at interim
+                                         # Here we stop inclusion data collection for the interim analysis as soon as
+                                         # half of the participants have completed (or had the opportunity to complete) the follow-up 
+     thet <- d$t3[ceiling(n*PropForInterim)]
+     di <- SelectData(d,t=thet)
+     ## ddi <- FormatAsCase(di) # needed ????
+     ## head(d[d$id==52,])
+                                         # }}}
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thet + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     currentGSD <- vector(mode = "list", length = 3)
+     out.interim <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+ 
+         currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+ 
+         iConfint.interim <- confint(currentGSD[[iMeth]])
+         iInfo.interim <- coef(currentGSD[[iMeth]], type = "information")
+         iBoundary.interim <- coef(currentGSD[[iMeth]], type = "boundary")
+         iDecision.interim <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+         out.interim[[iMeth]] <-  data.frame(statistic = iConfint.interim[1,"statistic"],
+                                             estimate_ML = iConfint.interim[1,"estimate"],
+                                             se_ML = iConfint.interim[1,"se"],
+                                             info = iInfo.interim[1,"Interim"],
+                                             infoPC = iInfo.interim[1,"Interim.pc"],
+                                             info.pred = iInfo.interim[1,"Decision"],
+                                             infoPC.pred = iInfo.interim[1,"Decision.pc"],
+                                             uk = iBoundary.interim[1,"Ebound"],
+                                             lk = iBoundary.interim[1,"Fbound"],
+                                             decision = iDecision.interim["decision","stage 1"],
+                                             reason = iDecision.interim["reason.interim","stage 1"])
+     }
+     ## currentGSD[[1]]
+     ## plot(currentGSD[[1]])
+ 
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thet + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     out.decision <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+           
+         if(out.interim[[iMeth]]$decision == "stop"){
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+             ## plot(currentGSD[[iMeth]])
+ 
+             iConfint.decision <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.decision  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = iConfint.decision[1,"statistic"],
+                                                 p.value_ML = iConfint.decision[iConfint.decision$method == "ML","p.value"],
+                                                 lower_ML = iConfint.decision[iConfint.decision$method == "ML","lower"],
+                                                 upper_ML = iConfint.decision[iConfint.decision$method == "ML","upper"],
+                                                 estimate_ML = iConfint.decision[iConfint.decision$method == "ML","estimate"],
+                                                 p.value_MUE = iConfint.decision[iConfint.decision$method == "MUE","p.value"],
+                                                 lower_MUE = iConfint.decision[iConfint.decision$method == "MUE","lower"],
+                                                 upper_MUE = iConfint.decision[iConfint.decision$method == "MUE","upper"],
+                                                 estimate_MUE = iConfint.decision[iConfint.decision$method == "MUE","estimate"],
+                                                 info = iInfo.decision[1,"Interim"],
+                                                 infoPC = iInfo.decision[1,"Interim.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = unname(iDecision.decision["decision","stage 2"])
+                                                 )
+ 
+         }else{
+             ## update information
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+ 
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = NA,
+                                                 p.value_ML = NA,
+                                                 lower_ML = NA,
+                                                 upper_ML = NA,
+                                                 estimate_ML = NA,
+                                                 p.value_MUE = NA,
+                                                 lower_MUE = NA,
+                                                 upper_MUE = NA,
+                                                 estimate_MUE = NA,
+                                                 info = iInfo.decision[1,"Decision"],
+                                                 infoPC = iInfo.decision[1,"Decision.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = NA)
+         }
+     }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+ 
+     ## ** finale
+     dFinal <- d
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     out.final <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+         if(out.interim[[iMeth]]$decision == "stop"){
+             out.final[[iMeth]] <- data.frame(statistic = NA,
+                                              p.value_ML = NA,
+                                              lower_ML = NA,
+                                              upper_ML = NA,
+                                              estimate_ML = NA,
+                                              p.value_MUE = NA,
+                                              lower_MUE = NA,
+                                              upper_MUE = NA,
+                                              estimate_MUE = NA,
+                                              info = NA,
+                                              infoPC = NA,
+                                              ck = NA,
+                                              decision = NA)
+ 
+         }else{
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+ 
+             ## plot(test)
+             ## summary(test)
+             iConfint.final <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.final <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.final <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.final  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.final[[iMeth]] <- data.frame(statistic = iConfint.final[1,"statistic"],
+                                              p.value_ML = iConfint.final[iConfint.final$method == "ML","p.value"],
+                                              lower_ML = iConfint.final[iConfint.final$method == "ML","lower"],
+                                              upper_ML = iConfint.final[iConfint.final$method == "ML","upper"],
+                                              estimate_ML = iConfint.final[iConfint.final$method == "ML","estimate"],
+                                              p.value_MUE = iConfint.final[iConfint.final$method == "MUE","p.value"],
+                                              lower_MUE = iConfint.final[iConfint.final$method == "MUE","lower"],
+                                              upper_MUE = iConfint.final[iConfint.final$method == "MUE","upper"],
+                                              estimate_MUE = iConfint.final[iConfint.final$method == "MUE","estimate"],
+                                              info = iInfo.final[1,"Interim"],
+                                              infoPC = iInfo.final[1,"Interim.pc"],
+                                              ck = iBoundary.final[1,"Cbound"],
+                                              decision = unname(coef(currentGSD[[iMeth]], type = "decision")["decision","stage 2"])
+                                              )
+         }
+     }
+                                         # }}}
+ 
+     stopComp <- Sys.time()
+                                         # {{{ Save results
+ 
+     outMerge <- do.call(rbind,lapply(method, function(iMeth){
+         iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+         iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+         iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+         iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+         iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+         return(iMerge)
+     }))
+ 
+     ## outMerge[outMerge$method==3,]
+ 
+     out <- cbind(
+         ## results
+         outMerge,
+         ## simulation details
+         time.interim = thet,
+         seed=myseedi,             
+         nX1.interim = sum(!is.na(di$X1)),
+         nX2.interim = sum(!is.na(di$X2)),
+         nX3.interim = sum(!is.na(di$X3)),
+         ## computation time
+         computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+     )
+     ## names(out) <- myColNames
+     RES <- rbind(RES,out)
+     save(RES,file=paste0(path.res,name,"(tempo)-",iter_sim,".rda"))
+                                         # }}}
+ }
[1] "seed 69505 for j=1 out of 250 (i.e. j=8501 in [8501;8750], as job id is i=35)"
Loading required namespace: nlme
[1] "seed 16219 for j=2 out of 250 (i.e. j=8502 in [8501;8750], as job id is i=35)"
[1] "seed 34968 for j=3 out of 250 (i.e. j=8503 in [8501;8750], as job id is i=35)"
[1] "seed 69268 for j=4 out of 250 (i.e. j=8504 in [8501;8750], as job id is i=35)"
[1] "seed 65690 for j=5 out of 250 (i.e. j=8505 in [8501;8750], as job id is i=35)"
[1] "seed 7233 for j=6 out of 250 (i.e. j=8506 in [8501;8750], as job id is i=35)"
[1] "seed 14211 for j=7 out of 250 (i.e. j=8507 in [8501;8750], as job id is i=35)"
[1] "seed 70563 for j=8 out of 250 (i.e. j=8508 in [8501;8750], as job id is i=35)"
[1] "seed 2409 for j=9 out of 250 (i.e. j=8509 in [8501;8750], as job id is i=35)"
[1] "seed 45699 for j=10 out of 250 (i.e. j=8510 in [8501;8750], as job id is i=35)"
[1] "seed 20685 for j=11 out of 250 (i.e. j=8511 in [8501;8750], as job id is i=35)"
[1] "seed 85834 for j=12 out of 250 (i.e. j=8512 in [8501;8750], as job id is i=35)"
[1] "seed 98309 for j=13 out of 250 (i.e. j=8513 in [8501;8750], as job id is i=35)"
[1] "seed 51571 for j=14 out of 250 (i.e. j=8514 in [8501;8750], as job id is i=35)"
[1] "seed 30985 for j=15 out of 250 (i.e. j=8515 in [8501;8750], as job id is i=35)"
[1] "seed 13012 for j=16 out of 250 (i.e. j=8516 in [8501;8750], as job id is i=35)"
[1] "seed 31898 for j=17 out of 250 (i.e. j=8517 in [8501;8750], as job id is i=35)"
[1] "seed 46574 for j=18 out of 250 (i.e. j=8518 in [8501;8750], as job id is i=35)"
[1] "seed 46571 for j=19 out of 250 (i.e. j=8519 in [8501;8750], as job id is i=35)"
[1] "seed 6149 for j=20 out of 250 (i.e. j=8520 in [8501;8750], as job id is i=35)"
[1] "seed 24927 for j=21 out of 250 (i.e. j=8521 in [8501;8750], as job id is i=35)"
[1] "seed 92431 for j=22 out of 250 (i.e. j=8522 in [8501;8750], as job id is i=35)"
[1] "seed 61678 for j=23 out of 250 (i.e. j=8523 in [8501;8750], as job id is i=35)"
[1] "seed 39496 for j=24 out of 250 (i.e. j=8524 in [8501;8750], as job id is i=35)"
[1] "seed 88063 for j=25 out of 250 (i.e. j=8525 in [8501;8750], as job id is i=35)"
[1] "seed 95033 for j=26 out of 250 (i.e. j=8526 in [8501;8750], as job id is i=35)"
[1] "seed 56639 for j=27 out of 250 (i.e. j=8527 in [8501;8750], as job id is i=35)"
[1] "seed 69314 for j=28 out of 250 (i.e. j=8528 in [8501;8750], as job id is i=35)"
[1] "seed 49869 for j=29 out of 250 (i.e. j=8529 in [8501;8750], as job id is i=35)"
[1] "seed 29548 for j=30 out of 250 (i.e. j=8530 in [8501;8750], as job id is i=35)"
[1] "seed 17863 for j=31 out of 250 (i.e. j=8531 in [8501;8750], as job id is i=35)"
[1] "seed 34313 for j=32 out of 250 (i.e. j=8532 in [8501;8750], as job id is i=35)"
[1] "seed 82835 for j=33 out of 250 (i.e. j=8533 in [8501;8750], as job id is i=35)"
[1] "seed 98494 for j=34 out of 250 (i.e. j=8534 in [8501;8750], as job id is i=35)"
[1] "seed 85997 for j=35 out of 250 (i.e. j=8535 in [8501;8750], as job id is i=35)"
[1] "seed 7414 for j=36 out of 250 (i.e. j=8536 in [8501;8750], as job id is i=35)"
[1] "seed 71441 for j=37 out of 250 (i.e. j=8537 in [8501;8750], as job id is i=35)"
[1] "seed 90702 for j=38 out of 250 (i.e. j=8538 in [8501;8750], as job id is i=35)"
[1] "seed 76924 for j=39 out of 250 (i.e. j=8539 in [8501;8750], as job id is i=35)"
[1] "seed 31320 for j=40 out of 250 (i.e. j=8540 in [8501;8750], as job id is i=35)"
[1] "seed 84709 for j=41 out of 250 (i.e. j=8541 in [8501;8750], as job id is i=35)"
[1] "seed 2885 for j=42 out of 250 (i.e. j=8542 in [8501;8750], as job id is i=35)"
[1] "seed 86088 for j=43 out of 250 (i.e. j=8543 in [8501;8750], as job id is i=35)"
[1] "seed 48806 for j=44 out of 250 (i.e. j=8544 in [8501;8750], as job id is i=35)"
[1] "seed 82303 for j=45 out of 250 (i.e. j=8545 in [8501;8750], as job id is i=35)"
[1] "seed 41113 for j=46 out of 250 (i.e. j=8546 in [8501;8750], as job id is i=35)"
[1] "seed 33964 for j=47 out of 250 (i.e. j=8547 in [8501;8750], as job id is i=35)"
[1] "seed 62784 for j=48 out of 250 (i.e. j=8548 in [8501;8750], as job id is i=35)"
[1] "seed 94765 for j=49 out of 250 (i.e. j=8549 in [8501;8750], as job id is i=35)"
[1] "seed 62677 for j=50 out of 250 (i.e. j=8550 in [8501;8750], as job id is i=35)"
[1] "seed 70479 for j=51 out of 250 (i.e. j=8551 in [8501;8750], as job id is i=35)"
[1] "seed 19325 for j=52 out of 250 (i.e. j=8552 in [8501;8750], as job id is i=35)"
[1] "seed 95253 for j=53 out of 250 (i.e. j=8553 in [8501;8750], as job id is i=35)"
[1] "seed 70329 for j=54 out of 250 (i.e. j=8554 in [8501;8750], as job id is i=35)"
[1] "seed 58131 for j=55 out of 250 (i.e. j=8555 in [8501;8750], as job id is i=35)"
[1] "seed 4241 for j=56 out of 250 (i.e. j=8556 in [8501;8750], as job id is i=35)"
[1] "seed 41729 for j=57 out of 250 (i.e. j=8557 in [8501;8750], as job id is i=35)"
[1] "seed 32439 for j=58 out of 250 (i.e. j=8558 in [8501;8750], as job id is i=35)"
[1] "seed 26128 for j=59 out of 250 (i.e. j=8559 in [8501;8750], as job id is i=35)"
[1] "seed 68812 for j=60 out of 250 (i.e. j=8560 in [8501;8750], as job id is i=35)"
[1] "seed 14308 for j=61 out of 250 (i.e. j=8561 in [8501;8750], as job id is i=35)"
[1] "seed 25383 for j=62 out of 250 (i.e. j=8562 in [8501;8750], as job id is i=35)"
[1] "seed 31405 for j=63 out of 250 (i.e. j=8563 in [8501;8750], as job id is i=35)"
[1] "seed 82799 for j=64 out of 250 (i.e. j=8564 in [8501;8750], as job id is i=35)"
[1] "seed 39584 for j=65 out of 250 (i.e. j=8565 in [8501;8750], as job id is i=35)"
[1] "seed 69197 for j=66 out of 250 (i.e. j=8566 in [8501;8750], as job id is i=35)"
[1] "seed 52727 for j=67 out of 250 (i.e. j=8567 in [8501;8750], as job id is i=35)"
[1] "seed 28237 for j=68 out of 250 (i.e. j=8568 in [8501;8750], as job id is i=35)"
[1] "seed 96902 for j=69 out of 250 (i.e. j=8569 in [8501;8750], as job id is i=35)"
[1] "seed 5386 for j=70 out of 250 (i.e. j=8570 in [8501;8750], as job id is i=35)"
[1] "seed 58490 for j=71 out of 250 (i.e. j=8571 in [8501;8750], as job id is i=35)"
[1] "seed 42798 for j=72 out of 250 (i.e. j=8572 in [8501;8750], as job id is i=35)"
[1] "seed 7975 for j=73 out of 250 (i.e. j=8573 in [8501;8750], as job id is i=35)"
[1] "seed 17311 for j=74 out of 250 (i.e. j=8574 in [8501;8750], as job id is i=35)"
[1] "seed 32668 for j=75 out of 250 (i.e. j=8575 in [8501;8750], as job id is i=35)"
[1] "seed 72002 for j=76 out of 250 (i.e. j=8576 in [8501;8750], as job id is i=35)"
[1] "seed 72507 for j=77 out of 250 (i.e. j=8577 in [8501;8750], as job id is i=35)"
[1] "seed 81400 for j=78 out of 250 (i.e. j=8578 in [8501;8750], as job id is i=35)"
[1] "seed 73291 for j=79 out of 250 (i.e. j=8579 in [8501;8750], as job id is i=35)"
[1] "seed 6075 for j=80 out of 250 (i.e. j=8580 in [8501;8750], as job id is i=35)"
[1] "seed 73828 for j=81 out of 250 (i.e. j=8581 in [8501;8750], as job id is i=35)"
[1] "seed 58331 for j=82 out of 250 (i.e. j=8582 in [8501;8750], as job id is i=35)"
[1] "seed 62743 for j=83 out of 250 (i.e. j=8583 in [8501;8750], as job id is i=35)"
[1] "seed 84070 for j=84 out of 250 (i.e. j=8584 in [8501;8750], as job id is i=35)"
[1] "seed 42321 for j=85 out of 250 (i.e. j=8585 in [8501;8750], as job id is i=35)"
[1] "seed 59563 for j=86 out of 250 (i.e. j=8586 in [8501;8750], as job id is i=35)"
[1] "seed 81548 for j=87 out of 250 (i.e. j=8587 in [8501;8750], as job id is i=35)"
[1] "seed 59761 for j=88 out of 250 (i.e. j=8588 in [8501;8750], as job id is i=35)"
[1] "seed 51547 for j=89 out of 250 (i.e. j=8589 in [8501;8750], as job id is i=35)"
[1] "seed 33280 for j=90 out of 250 (i.e. j=8590 in [8501;8750], as job id is i=35)"
[1] "seed 21797 for j=91 out of 250 (i.e. j=8591 in [8501;8750], as job id is i=35)"
[1] "seed 78578 for j=92 out of 250 (i.e. j=8592 in [8501;8750], as job id is i=35)"
[1] "seed 13966 for j=93 out of 250 (i.e. j=8593 in [8501;8750], as job id is i=35)"
[1] "seed 14799 for j=94 out of 250 (i.e. j=8594 in [8501;8750], as job id is i=35)"
[1] "seed 63286 for j=95 out of 250 (i.e. j=8595 in [8501;8750], as job id is i=35)"
[1] "seed 67869 for j=96 out of 250 (i.e. j=8596 in [8501;8750], as job id is i=35)"
[1] "seed 18866 for j=97 out of 250 (i.e. j=8597 in [8501;8750], as job id is i=35)"
[1] "seed 7664 for j=98 out of 250 (i.e. j=8598 in [8501;8750], as job id is i=35)"
[1] "seed 89398 for j=99 out of 250 (i.e. j=8599 in [8501;8750], as job id is i=35)"
[1] "seed 15524 for j=100 out of 250 (i.e. j=8600 in [8501;8750], as job id is i=35)"
[1] "seed 99414 for j=101 out of 250 (i.e. j=8601 in [8501;8750], as job id is i=35)"
[1] "seed 99475 for j=102 out of 250 (i.e. j=8602 in [8501;8750], as job id is i=35)"
[1] "seed 92974 for j=103 out of 250 (i.e. j=8603 in [8501;8750], as job id is i=35)"
[1] "seed 36240 for j=104 out of 250 (i.e. j=8604 in [8501;8750], as job id is i=35)"
[1] "seed 99496 for j=105 out of 250 (i.e. j=8605 in [8501;8750], as job id is i=35)"
[1] "seed 13815 for j=106 out of 250 (i.e. j=8606 in [8501;8750], as job id is i=35)"
[1] "seed 27994 for j=107 out of 250 (i.e. j=8607 in [8501;8750], as job id is i=35)"
[1] "seed 15010 for j=108 out of 250 (i.e. j=8608 in [8501;8750], as job id is i=35)"
[1] "seed 84395 for j=109 out of 250 (i.e. j=8609 in [8501;8750], as job id is i=35)"
[1] "seed 10479 for j=110 out of 250 (i.e. j=8610 in [8501;8750], as job id is i=35)"
[1] "seed 69785 for j=111 out of 250 (i.e. j=8611 in [8501;8750], as job id is i=35)"
[1] "seed 98950 for j=112 out of 250 (i.e. j=8612 in [8501;8750], as job id is i=35)"
[1] "seed 77500 for j=113 out of 250 (i.e. j=8613 in [8501;8750], as job id is i=35)"
[1] "seed 68441 for j=114 out of 250 (i.e. j=8614 in [8501;8750], as job id is i=35)"
[1] "seed 41056 for j=115 out of 250 (i.e. j=8615 in [8501;8750], as job id is i=35)"
[1] "seed 51159 for j=116 out of 250 (i.e. j=8616 in [8501;8750], as job id is i=35)"
[1] "seed 20664 for j=117 out of 250 (i.e. j=8617 in [8501;8750], as job id is i=35)"
[1] "seed 20102 for j=118 out of 250 (i.e. j=8618 in [8501;8750], as job id is i=35)"
[1] "seed 42504 for j=119 out of 250 (i.e. j=8619 in [8501;8750], as job id is i=35)"
[1] "seed 8139 for j=120 out of 250 (i.e. j=8620 in [8501;8750], as job id is i=35)"
[1] "seed 87135 for j=121 out of 250 (i.e. j=8621 in [8501;8750], as job id is i=35)"
[1] "seed 49458 for j=122 out of 250 (i.e. j=8622 in [8501;8750], as job id is i=35)"
[1] "seed 79374 for j=123 out of 250 (i.e. j=8623 in [8501;8750], as job id is i=35)"
[1] "seed 83919 for j=124 out of 250 (i.e. j=8624 in [8501;8750], as job id is i=35)"
[1] "seed 24405 for j=125 out of 250 (i.e. j=8625 in [8501;8750], as job id is i=35)"
[1] "seed 17463 for j=126 out of 250 (i.e. j=8626 in [8501;8750], as job id is i=35)"
[1] "seed 33437 for j=127 out of 250 (i.e. j=8627 in [8501;8750], as job id is i=35)"
[1] "seed 97867 for j=128 out of 250 (i.e. j=8628 in [8501;8750], as job id is i=35)"
[1] "seed 36703 for j=129 out of 250 (i.e. j=8629 in [8501;8750], as job id is i=35)"
[1] "seed 3999 for j=130 out of 250 (i.e. j=8630 in [8501;8750], as job id is i=35)"
[1] "seed 94728 for j=131 out of 250 (i.e. j=8631 in [8501;8750], as job id is i=35)"
Error in uniroot(function(x) { : 
  f() values at end points not of opposite sign
Calls: update ... update.delayedGSD -> updateBoundaries -> updateMethod1 -> uniroot
In addition: There were 12 warnings (use warnings() to see them)
Execution halted
