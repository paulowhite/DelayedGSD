
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### BATCH_simuMain.R --- 
> #----------------------------------------------------------------------
> ## Author: Paul Blanche
> ## Created: Mar  5 2021 (10:56) 
> ## Version: 
> ## Last-Updated: jul  7 2022 (13:56) 
> ##           By: Brice Ozenne
> ##     Update #: 518
> #----------------------------------------------------------------------
> ## 
> ### Commentary: 
> ## 
> ### Change Log:
> #----------------------------------------------------------------------
> ## 
> ### Code:
> 
> ## ** BATCH loop
> ## cd /projects/biostat01/people/hpl802/DelayedGSD/
> ## for ITER in `seq 1 10`;
> ## do
> ## eval 'R CMD BATCH --vanilla "--args iter_sim='$ITER' n.iter_sim=10" BATCH_simuMain.R output/R-simuMain-'$ITER'.Rout &'
> ## done
> 
> ## [1] 1186669
> ## [2] 1186670
> ## [3] 1186671
> ## [4] 1186672
> ## [5] 1186673
> ## [6] 1186674
> ## [7] 1186675
> ## [8] 1186676
> ## [9] 1186677
> ## [10] 1186678
> 
> rm(list=ls())
>                                    # {{{ parameters
> ## * parameters
> name <- "ScenarioName" # To save the results
> method <- 1:2 # methods used to compute the boundaries
>                                         #---
> myseed <- 140786598
>                                         #--- to plan the trial ----
> NMC <- 250 # number of sequential simulations to run in parallel. Eg. with 250, then we can run 40 scripts in paralell to get N=10,000 runs in total.
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.5,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.55  #(expected) information rate at each decision analysis
> binding <- TRUE
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.6,0.8) # treatment effect
> ar <- (0.86*2)*2 # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As to low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> Miss11 <- 5/104 # miss both V1 and V2
> Miss12 <- 1/104 # miss V1 and but not V2
> Miss21 <- 6/104 # do not miss V1 and but miss V2
> Miss22 <- 92/104 # miss none
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- abs(delta[3]) # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> n <- ceiling(2*2*((allsd[3]/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
>                                         # {{{ Set seeds for parallel computing and reproducibility
> ## * Seed
> args <- commandArgs(TRUE) ## BATCH MODE
> if(length(args)>0){
+     for (arg in args){
+         eval(parse(text=arg))
+     }
+ }else{ ## SLUMR
+     iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
+     n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
+ } ## interactive
> if(is.na(iter_sim)){iter_sim <- 1}
> if(is.na(n.iter_sim)){n.iter_sim <- 40}
> 
> set.seed(140786598)
> allseeds <- sample.int(n = 10*n.iter_sim*NMC, size = n.iter_sim*NMC, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> # }}}
> 
> # {{{ set path to load and save and othe machine specific variables
> ## * path
> path <- "."
> path.res <- file.path(path,"Results","simuMain")
> if(dir.exists(path.res)==FALSE){
+     if(dir.exists(file.path(path,"Results"))==FALSE){
+     dir.create(file.path(path,"Results"))
+     }
+     dir.create(path.res)
+ }
> path.output <- file.path(path,"output","simuMain")
> if(dir.exists(path.output)==FALSE){
+     if(dir.exists(file.path(path,"output"))==FALSE){
+     dir.create(file.path(path,"output"))
+     }
+     dir.create(path.output)
+ }
> # }}}
> 
> 
> ## * libraries and functions
> library(DelayedGSD)
DelayedGSD version 0.0.3
> ## sourceDir <- function(path, trace = TRUE, ...) {
> ##     for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
> ##         if(trace) cat(nm,":")
> ##         source(file.path(path, nm), ...)
> ##         if(trace) cat("\n")
> ##     }
> ## }
> ## sourceDir(pathToLoad)
>     
> 
> ## * Compute inflation factor and sample size
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+     plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                         alpha=alpha, 
+                                         beta=beta,  
+                                         InfoR.i=informationRates,  
+                                         InfoR.d=c(Id,1),  
+                                         rho_alpha=rho_alpha,  
+                                         rho_beta=rho_beta,  
+                                         method=iMeth,  
+                                         cNotBelowFixedc=FALSE,
+                                         bindingFutility=binding,
+                                         delta=tail(delta,1))
+     ## summary(plannedB[[1]])
+     ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> ##  plot(plannedB[[1]])
> 
> #
> # --- just to check---
> ## n
> ## InfoFixed <- ((qnorm(1-beta)-qnorm(alpha))/(deltaPower))^2
> ## InfoFixed
> ## n/(4*(allsd[3])^2)
> #---
> # }}}
> 
> 
> 
> 
> # {{{ technical details to loop
> RES <- NULL # initialize results to save
> allj <- ((iter_sim-1)*NMC + 1):(iter_sim*NMC) # indices of all iterations (replicates) for this job, accountng for the other jobs running in parallel
> # }}}
> 
> ## * Loop
> for(j in allj){ ## j <- 51 ## 5
+     startComp <- Sys.time()
+     myseedi <- allseeds[j]
+     # {{{ TRACE info (e.g. to check the Rout)
+     print(paste0("seed ",myseedi," for ","j=",which(j==allj)," out of ",NMC, " (i.e. j=",j," in [",(iter_sim-1)*NMC + 1,";",iter_sim*NMC,"], as job id is i=",iter_sim,")"))
+     # }}}
+     # {{{ Missing probabilities
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE) # to additionnally remove 1 more because some FASFL=N
+     colnames(MyMissProb) <- c("V2 missing","V2 not missing")
+     rownames(MyMissProb) <- c("V1 missing","V1 not missing")
+     # }}}
+ 
+                                         # {{{ generate data
+     ## ** simulate
+     res <- GenData(n=n, 
+                    N.fw=2,
+                    rand.block=block,
+                    allsd=allsd,
+                    mean0=mean0,
+                    delta=delta,
+                    ar=ar,
+                    cor.01.1=cor011,
+                    cor.ij.1=corij1,
+                    cor.0j.1=cor0j1,
+                    seed=myseedi,
+                    MissProb=MyMissProb,
+                    DigitsOutcome=2,
+                    TimeFactor=TimeFactor,
+                    DigitsTime=0
+                    )
+     d <- res$d
+     ## head(d,n=20)
+                                         # }}}
+                                         # {{{ reformat data like those of Corine
+     ## Make data long format
+     ## dd <- FormatAsCase(d)
+     ## head(dd)
+     ## summary(dd)
+                                         # }}}
+    
+                                         # {{{ make data available at interim
+                                         # Here we stop inclusion data collection for the interim analysis as soon as
+                                         # half of the participants have completed (or had the opportunity to complete) the follow-up 
+     thet <- d$t3[ceiling(n*PropForInterim)]
+     di <- SelectData(d,t=thet)
+     ## ddi <- FormatAsCase(di) # needed ????
+     ## head(d[d$id==52,])
+                                         # }}}
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thet + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     currentGSD <- vector(mode = "list", length = 3)
+     out.interim <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+ 
+         currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+ 
+         iConfint.interim <- confint(currentGSD[[iMeth]])
+         iInfo.interim <- coef(currentGSD[[iMeth]], type = "information")
+         iBoundary.interim <- coef(currentGSD[[iMeth]], type = "boundary")
+         iDecision.interim <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+         out.interim[[iMeth]] <-  data.frame(statistic = iConfint.interim[1,"statistic"],
+                                             estimate_ML = iConfint.interim[1,"estimate"],
+                                             se_ML = iConfint.interim[1,"se"],
+                                             info = iInfo.interim[1,"Interim"],
+                                             infoPC = iInfo.interim[1,"Interim.pc"],
+                                             info.pred = iInfo.interim[1,"Decision"],
+                                             infoPC.pred = iInfo.interim[1,"Decision.pc"],
+                                             uk = iBoundary.interim[1,"Ebound"],
+                                             lk = iBoundary.interim[1,"Fbound"],
+                                             decision = iDecision.interim["decision","stage 1"],
+                                             reason = iDecision.interim["reason.interim","stage 1"])
+     }
+     ## currentGSD[[1]]
+     ## plot(currentGSD[[1]])
+ 
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thet + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     out.decision <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+           
+         if(out.interim[[iMeth]]$decision == "stop"){
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+             ## plot(currentGSD[[iMeth]])
+ 
+             iConfint.decision <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.decision  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = iConfint.decision[1,"statistic"],
+                                                 p.value_ML = iConfint.decision[iConfint.decision$method == "ML","p.value"],
+                                                 lower_ML = iConfint.decision[iConfint.decision$method == "ML","lower"],
+                                                 upper_ML = iConfint.decision[iConfint.decision$method == "ML","upper"],
+                                                 estimate_ML = iConfint.decision[iConfint.decision$method == "ML","estimate"],
+                                                 p.value_MUE = iConfint.decision[iConfint.decision$method == "MUE","p.value"],
+                                                 lower_MUE = iConfint.decision[iConfint.decision$method == "MUE","lower"],
+                                                 upper_MUE = iConfint.decision[iConfint.decision$method == "MUE","upper"],
+                                                 estimate_MUE = iConfint.decision[iConfint.decision$method == "MUE","estimate"],
+                                                 info = iInfo.decision[1,"Interim"],
+                                                 infoPC = iInfo.decision[1,"Interim.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = unname(iDecision.decision["decision","stage 2"])
+                                                 )
+ 
+         }else{
+             ## update information
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+ 
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = NA,
+                                                 p.value_ML = NA,
+                                                 lower_ML = NA,
+                                                 upper_ML = NA,
+                                                 estimate_ML = NA,
+                                                 p.value_MUE = NA,
+                                                 lower_MUE = NA,
+                                                 upper_MUE = NA,
+                                                 estimate_MUE = NA,
+                                                 info = iInfo.decision[1,"Decision"],
+                                                 infoPC = iInfo.decision[1,"Decision.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = NA)
+         }
+     }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+ 
+     ## ** finale
+     dFinal <- d
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     out.final <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+         if(out.interim[[iMeth]]$decision == "stop"){
+             out.final[[iMeth]] <- data.frame(statistic = NA,
+                                              p.value_ML = NA,
+                                              lower_ML = NA,
+                                              upper_ML = NA,
+                                              estimate_ML = NA,
+                                              p.value_MUE = NA,
+                                              lower_MUE = NA,
+                                              upper_MUE = NA,
+                                              estimate_MUE = NA,
+                                              info = NA,
+                                              infoPC = NA,
+                                              ck = NA,
+                                              decision = NA)
+ 
+         }else{
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+ 
+             ## plot(test)
+             ## summary(test)
+             iConfint.final <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.final <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.final <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.final  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.final[[iMeth]] <- data.frame(statistic = iConfint.final[1,"statistic"],
+                                              p.value_ML = iConfint.final[iConfint.final$method == "ML","p.value"],
+                                              lower_ML = iConfint.final[iConfint.final$method == "ML","lower"],
+                                              upper_ML = iConfint.final[iConfint.final$method == "ML","upper"],
+                                              estimate_ML = iConfint.final[iConfint.final$method == "ML","estimate"],
+                                              p.value_MUE = iConfint.final[iConfint.final$method == "MUE","p.value"],
+                                              lower_MUE = iConfint.final[iConfint.final$method == "MUE","lower"],
+                                              upper_MUE = iConfint.final[iConfint.final$method == "MUE","upper"],
+                                              estimate_MUE = iConfint.final[iConfint.final$method == "MUE","estimate"],
+                                              info = iInfo.final[1,"Interim"],
+                                              infoPC = iInfo.final[1,"Interim.pc"],
+                                              ck = iBoundary.final[1,"Cbound"],
+                                              decision = unname(coef(currentGSD[[iMeth]], type = "decision")["decision","stage 2"])
+                                              )
+         }
+     }
+                                         # }}}
+ 
+     stopComp <- Sys.time()
+                                         # {{{ Save results
+ 
+     outMerge <- do.call(rbind,lapply(method, function(iMeth){
+         iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+         iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+         iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+         iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+         iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+         return(iMerge)
+     }))
+ 
+     ## outMerge[outMerge$method==3,]
+ 
+     out <- cbind(
+         ## results
+         outMerge,
+         ## simulation details
+         time.interim = thet,
+         seed=myseedi,             
+         nX1.interim = sum(!is.na(di$X1)),
+         nX2.interim = sum(!is.na(di$X2)),
+         nX3.interim = sum(!is.na(di$X3)),
+         ## computation time
+         computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+     )
+     ## names(out) <- myColNames
+     RES <- rbind(RES,out)
+     save(RES,file=paste0(path.res,name,"(tempo)-",iter_sim,".rda"))
+                                         # }}}
+ }
[1] "seed 60451 for j=1 out of 250 (i.e. j=6501 in [6501;6750], as job id is i=27)"
Loading required namespace: nlme
[1] "seed 29518 for j=2 out of 250 (i.e. j=6502 in [6501;6750], as job id is i=27)"
[1] "seed 18471 for j=3 out of 250 (i.e. j=6503 in [6501;6750], as job id is i=27)"
[1] "seed 13950 for j=4 out of 250 (i.e. j=6504 in [6501;6750], as job id is i=27)"
[1] "seed 26512 for j=5 out of 250 (i.e. j=6505 in [6501;6750], as job id is i=27)"
[1] "seed 44640 for j=6 out of 250 (i.e. j=6506 in [6501;6750], as job id is i=27)"
[1] "seed 86953 for j=7 out of 250 (i.e. j=6507 in [6501;6750], as job id is i=27)"
[1] "seed 83426 for j=8 out of 250 (i.e. j=6508 in [6501;6750], as job id is i=27)"
[1] "seed 79847 for j=9 out of 250 (i.e. j=6509 in [6501;6750], as job id is i=27)"
[1] "seed 42688 for j=10 out of 250 (i.e. j=6510 in [6501;6750], as job id is i=27)"
[1] "seed 402 for j=11 out of 250 (i.e. j=6511 in [6501;6750], as job id is i=27)"
[1] "seed 564 for j=12 out of 250 (i.e. j=6512 in [6501;6750], as job id is i=27)"
[1] "seed 28081 for j=13 out of 250 (i.e. j=6513 in [6501;6750], as job id is i=27)"
[1] "seed 44507 for j=14 out of 250 (i.e. j=6514 in [6501;6750], as job id is i=27)"
[1] "seed 56576 for j=15 out of 250 (i.e. j=6515 in [6501;6750], as job id is i=27)"
[1] "seed 21132 for j=16 out of 250 (i.e. j=6516 in [6501;6750], as job id is i=27)"
[1] "seed 29968 for j=17 out of 250 (i.e. j=6517 in [6501;6750], as job id is i=27)"
[1] "seed 39450 for j=18 out of 250 (i.e. j=6518 in [6501;6750], as job id is i=27)"
[1] "seed 90420 for j=19 out of 250 (i.e. j=6519 in [6501;6750], as job id is i=27)"
[1] "seed 84587 for j=20 out of 250 (i.e. j=6520 in [6501;6750], as job id is i=27)"
[1] "seed 47747 for j=21 out of 250 (i.e. j=6521 in [6501;6750], as job id is i=27)"
[1] "seed 75574 for j=22 out of 250 (i.e. j=6522 in [6501;6750], as job id is i=27)"
[1] "seed 18304 for j=23 out of 250 (i.e. j=6523 in [6501;6750], as job id is i=27)"
[1] "seed 60341 for j=24 out of 250 (i.e. j=6524 in [6501;6750], as job id is i=27)"
[1] "seed 75412 for j=25 out of 250 (i.e. j=6525 in [6501;6750], as job id is i=27)"
[1] "seed 75892 for j=26 out of 250 (i.e. j=6526 in [6501;6750], as job id is i=27)"
[1] "seed 97479 for j=27 out of 250 (i.e. j=6527 in [6501;6750], as job id is i=27)"
[1] "seed 8607 for j=28 out of 250 (i.e. j=6528 in [6501;6750], as job id is i=27)"
[1] "seed 23824 for j=29 out of 250 (i.e. j=6529 in [6501;6750], as job id is i=27)"
[1] "seed 28276 for j=30 out of 250 (i.e. j=6530 in [6501;6750], as job id is i=27)"
[1] "seed 43817 for j=31 out of 250 (i.e. j=6531 in [6501;6750], as job id is i=27)"
[1] "seed 43067 for j=32 out of 250 (i.e. j=6532 in [6501;6750], as job id is i=27)"
[1] "seed 18470 for j=33 out of 250 (i.e. j=6533 in [6501;6750], as job id is i=27)"
[1] "seed 29116 for j=34 out of 250 (i.e. j=6534 in [6501;6750], as job id is i=27)"
[1] "seed 75050 for j=35 out of 250 (i.e. j=6535 in [6501;6750], as job id is i=27)"
[1] "seed 54535 for j=36 out of 250 (i.e. j=6536 in [6501;6750], as job id is i=27)"
[1] "seed 36933 for j=37 out of 250 (i.e. j=6537 in [6501;6750], as job id is i=27)"
[1] "seed 19339 for j=38 out of 250 (i.e. j=6538 in [6501;6750], as job id is i=27)"
[1] "seed 72241 for j=39 out of 250 (i.e. j=6539 in [6501;6750], as job id is i=27)"
[1] "seed 59489 for j=40 out of 250 (i.e. j=6540 in [6501;6750], as job id is i=27)"
[1] "seed 3797 for j=41 out of 250 (i.e. j=6541 in [6501;6750], as job id is i=27)"
[1] "seed 67552 for j=42 out of 250 (i.e. j=6542 in [6501;6750], as job id is i=27)"
[1] "seed 68010 for j=43 out of 250 (i.e. j=6543 in [6501;6750], as job id is i=27)"
[1] "seed 17765 for j=44 out of 250 (i.e. j=6544 in [6501;6750], as job id is i=27)"
[1] "seed 11914 for j=45 out of 250 (i.e. j=6545 in [6501;6750], as job id is i=27)"
[1] "seed 93820 for j=46 out of 250 (i.e. j=6546 in [6501;6750], as job id is i=27)"
[1] "seed 15286 for j=47 out of 250 (i.e. j=6547 in [6501;6750], as job id is i=27)"
[1] "seed 53495 for j=48 out of 250 (i.e. j=6548 in [6501;6750], as job id is i=27)"
[1] "seed 49920 for j=49 out of 250 (i.e. j=6549 in [6501;6750], as job id is i=27)"
[1] "seed 37059 for j=50 out of 250 (i.e. j=6550 in [6501;6750], as job id is i=27)"
[1] "seed 6259 for j=51 out of 250 (i.e. j=6551 in [6501;6750], as job id is i=27)"
[1] "seed 72293 for j=52 out of 250 (i.e. j=6552 in [6501;6750], as job id is i=27)"
[1] "seed 6742 for j=53 out of 250 (i.e. j=6553 in [6501;6750], as job id is i=27)"
[1] "seed 99854 for j=54 out of 250 (i.e. j=6554 in [6501;6750], as job id is i=27)"
[1] "seed 91693 for j=55 out of 250 (i.e. j=6555 in [6501;6750], as job id is i=27)"
[1] "seed 4047 for j=56 out of 250 (i.e. j=6556 in [6501;6750], as job id is i=27)"
[1] "seed 25434 for j=57 out of 250 (i.e. j=6557 in [6501;6750], as job id is i=27)"
[1] "seed 18935 for j=58 out of 250 (i.e. j=6558 in [6501;6750], as job id is i=27)"
[1] "seed 43740 for j=59 out of 250 (i.e. j=6559 in [6501;6750], as job id is i=27)"
[1] "seed 76734 for j=60 out of 250 (i.e. j=6560 in [6501;6750], as job id is i=27)"
[1] "seed 76791 for j=61 out of 250 (i.e. j=6561 in [6501;6750], as job id is i=27)"
[1] "seed 56830 for j=62 out of 250 (i.e. j=6562 in [6501;6750], as job id is i=27)"
[1] "seed 39863 for j=63 out of 250 (i.e. j=6563 in [6501;6750], as job id is i=27)"
[1] "seed 67782 for j=64 out of 250 (i.e. j=6564 in [6501;6750], as job id is i=27)"
[1] "seed 86978 for j=65 out of 250 (i.e. j=6565 in [6501;6750], as job id is i=27)"
[1] "seed 38437 for j=66 out of 250 (i.e. j=6566 in [6501;6750], as job id is i=27)"
[1] "seed 34263 for j=67 out of 250 (i.e. j=6567 in [6501;6750], as job id is i=27)"
[1] "seed 32471 for j=68 out of 250 (i.e. j=6568 in [6501;6750], as job id is i=27)"
[1] "seed 36063 for j=69 out of 250 (i.e. j=6569 in [6501;6750], as job id is i=27)"
[1] "seed 48979 for j=70 out of 250 (i.e. j=6570 in [6501;6750], as job id is i=27)"
[1] "seed 60449 for j=71 out of 250 (i.e. j=6571 in [6501;6750], as job id is i=27)"
[1] "seed 74706 for j=72 out of 250 (i.e. j=6572 in [6501;6750], as job id is i=27)"
[1] "seed 48908 for j=73 out of 250 (i.e. j=6573 in [6501;6750], as job id is i=27)"
[1] "seed 57083 for j=74 out of 250 (i.e. j=6574 in [6501;6750], as job id is i=27)"
[1] "seed 42996 for j=75 out of 250 (i.e. j=6575 in [6501;6750], as job id is i=27)"
[1] "seed 59173 for j=76 out of 250 (i.e. j=6576 in [6501;6750], as job id is i=27)"
[1] "seed 45898 for j=77 out of 250 (i.e. j=6577 in [6501;6750], as job id is i=27)"
[1] "seed 10741 for j=78 out of 250 (i.e. j=6578 in [6501;6750], as job id is i=27)"
[1] "seed 57212 for j=79 out of 250 (i.e. j=6579 in [6501;6750], as job id is i=27)"
[1] "seed 12324 for j=80 out of 250 (i.e. j=6580 in [6501;6750], as job id is i=27)"
[1] "seed 81073 for j=81 out of 250 (i.e. j=6581 in [6501;6750], as job id is i=27)"
[1] "seed 81020 for j=82 out of 250 (i.e. j=6582 in [6501;6750], as job id is i=27)"
[1] "seed 37721 for j=83 out of 250 (i.e. j=6583 in [6501;6750], as job id is i=27)"
[1] "seed 79485 for j=84 out of 250 (i.e. j=6584 in [6501;6750], as job id is i=27)"
[1] "seed 68305 for j=85 out of 250 (i.e. j=6585 in [6501;6750], as job id is i=27)"
[1] "seed 65599 for j=86 out of 250 (i.e. j=6586 in [6501;6750], as job id is i=27)"
[1] "seed 63450 for j=87 out of 250 (i.e. j=6587 in [6501;6750], as job id is i=27)"
[1] "seed 96638 for j=88 out of 250 (i.e. j=6588 in [6501;6750], as job id is i=27)"
[1] "seed 17062 for j=89 out of 250 (i.e. j=6589 in [6501;6750], as job id is i=27)"
[1] "seed 80087 for j=90 out of 250 (i.e. j=6590 in [6501;6750], as job id is i=27)"
[1] "seed 5728 for j=91 out of 250 (i.e. j=6591 in [6501;6750], as job id is i=27)"
[1] "seed 21648 for j=92 out of 250 (i.e. j=6592 in [6501;6750], as job id is i=27)"
[1] "seed 64435 for j=93 out of 250 (i.e. j=6593 in [6501;6750], as job id is i=27)"
[1] "seed 83328 for j=94 out of 250 (i.e. j=6594 in [6501;6750], as job id is i=27)"
[1] "seed 18979 for j=95 out of 250 (i.e. j=6595 in [6501;6750], as job id is i=27)"
[1] "seed 18273 for j=96 out of 250 (i.e. j=6596 in [6501;6750], as job id is i=27)"
[1] "seed 35746 for j=97 out of 250 (i.e. j=6597 in [6501;6750], as job id is i=27)"
[1] "seed 64157 for j=98 out of 250 (i.e. j=6598 in [6501;6750], as job id is i=27)"
[1] "seed 55305 for j=99 out of 250 (i.e. j=6599 in [6501;6750], as job id is i=27)"
[1] "seed 38233 for j=100 out of 250 (i.e. j=6600 in [6501;6750], as job id is i=27)"
[1] "seed 95526 for j=101 out of 250 (i.e. j=6601 in [6501;6750], as job id is i=27)"
[1] "seed 8201 for j=102 out of 250 (i.e. j=6602 in [6501;6750], as job id is i=27)"
[1] "seed 53260 for j=103 out of 250 (i.e. j=6603 in [6501;6750], as job id is i=27)"
[1] "seed 317 for j=104 out of 250 (i.e. j=6604 in [6501;6750], as job id is i=27)"
[1] "seed 39513 for j=105 out of 250 (i.e. j=6605 in [6501;6750], as job id is i=27)"
[1] "seed 14913 for j=106 out of 250 (i.e. j=6606 in [6501;6750], as job id is i=27)"
[1] "seed 81261 for j=107 out of 250 (i.e. j=6607 in [6501;6750], as job id is i=27)"
[1] "seed 97495 for j=108 out of 250 (i.e. j=6608 in [6501;6750], as job id is i=27)"
[1] "seed 96620 for j=109 out of 250 (i.e. j=6609 in [6501;6750], as job id is i=27)"
[1] "seed 52107 for j=110 out of 250 (i.e. j=6610 in [6501;6750], as job id is i=27)"
[1] "seed 335 for j=111 out of 250 (i.e. j=6611 in [6501;6750], as job id is i=27)"
[1] "seed 40811 for j=112 out of 250 (i.e. j=6612 in [6501;6750], as job id is i=27)"
[1] "seed 7255 for j=113 out of 250 (i.e. j=6613 in [6501;6750], as job id is i=27)"
[1] "seed 91694 for j=114 out of 250 (i.e. j=6614 in [6501;6750], as job id is i=27)"
[1] "seed 53578 for j=115 out of 250 (i.e. j=6615 in [6501;6750], as job id is i=27)"
[1] "seed 95935 for j=116 out of 250 (i.e. j=6616 in [6501;6750], as job id is i=27)"
[1] "seed 94670 for j=117 out of 250 (i.e. j=6617 in [6501;6750], as job id is i=27)"
[1] "seed 62096 for j=118 out of 250 (i.e. j=6618 in [6501;6750], as job id is i=27)"
[1] "seed 29592 for j=119 out of 250 (i.e. j=6619 in [6501;6750], as job id is i=27)"
[1] "seed 14370 for j=120 out of 250 (i.e. j=6620 in [6501;6750], as job id is i=27)"
[1] "seed 64488 for j=121 out of 250 (i.e. j=6621 in [6501;6750], as job id is i=27)"
[1] "seed 56907 for j=122 out of 250 (i.e. j=6622 in [6501;6750], as job id is i=27)"
[1] "seed 25622 for j=123 out of 250 (i.e. j=6623 in [6501;6750], as job id is i=27)"
[1] "seed 42425 for j=124 out of 250 (i.e. j=6624 in [6501;6750], as job id is i=27)"
[1] "seed 441 for j=125 out of 250 (i.e. j=6625 in [6501;6750], as job id is i=27)"
[1] "seed 93488 for j=126 out of 250 (i.e. j=6626 in [6501;6750], as job id is i=27)"
[1] "seed 21373 for j=127 out of 250 (i.e. j=6627 in [6501;6750], as job id is i=27)"
[1] "seed 9409 for j=128 out of 250 (i.e. j=6628 in [6501;6750], as job id is i=27)"
[1] "seed 15832 for j=129 out of 250 (i.e. j=6629 in [6501;6750], as job id is i=27)"
[1] "seed 64802 for j=130 out of 250 (i.e. j=6630 in [6501;6750], as job id is i=27)"
[1] "seed 32840 for j=131 out of 250 (i.e. j=6631 in [6501;6750], as job id is i=27)"
[1] "seed 48797 for j=132 out of 250 (i.e. j=6632 in [6501;6750], as job id is i=27)"
[1] "seed 54379 for j=133 out of 250 (i.e. j=6633 in [6501;6750], as job id is i=27)"
[1] "seed 57281 for j=134 out of 250 (i.e. j=6634 in [6501;6750], as job id is i=27)"
[1] "seed 2689 for j=135 out of 250 (i.e. j=6635 in [6501;6750], as job id is i=27)"
[1] "seed 68763 for j=136 out of 250 (i.e. j=6636 in [6501;6750], as job id is i=27)"
[1] "seed 73994 for j=137 out of 250 (i.e. j=6637 in [6501;6750], as job id is i=27)"
[1] "seed 31327 for j=138 out of 250 (i.e. j=6638 in [6501;6750], as job id is i=27)"
[1] "seed 67789 for j=139 out of 250 (i.e. j=6639 in [6501;6750], as job id is i=27)"
[1] "seed 43968 for j=140 out of 250 (i.e. j=6640 in [6501;6750], as job id is i=27)"
[1] "seed 81526 for j=141 out of 250 (i.e. j=6641 in [6501;6750], as job id is i=27)"
[1] "seed 73681 for j=142 out of 250 (i.e. j=6642 in [6501;6750], as job id is i=27)"
[1] "seed 25456 for j=143 out of 250 (i.e. j=6643 in [6501;6750], as job id is i=27)"
[1] "seed 61782 for j=144 out of 250 (i.e. j=6644 in [6501;6750], as job id is i=27)"
[1] "seed 21690 for j=145 out of 250 (i.e. j=6645 in [6501;6750], as job id is i=27)"
[1] "seed 168 for j=146 out of 250 (i.e. j=6646 in [6501;6750], as job id is i=27)"
[1] "seed 66803 for j=147 out of 250 (i.e. j=6647 in [6501;6750], as job id is i=27)"
[1] "seed 21615 for j=148 out of 250 (i.e. j=6648 in [6501;6750], as job id is i=27)"
[1] "seed 15579 for j=149 out of 250 (i.e. j=6649 in [6501;6750], as job id is i=27)"
[1] "seed 48129 for j=150 out of 250 (i.e. j=6650 in [6501;6750], as job id is i=27)"
[1] "seed 46640 for j=151 out of 250 (i.e. j=6651 in [6501;6750], as job id is i=27)"
[1] "seed 47472 for j=152 out of 250 (i.e. j=6652 in [6501;6750], as job id is i=27)"
[1] "seed 82471 for j=153 out of 250 (i.e. j=6653 in [6501;6750], as job id is i=27)"
[1] "seed 73464 for j=154 out of 250 (i.e. j=6654 in [6501;6750], as job id is i=27)"
[1] "seed 17205 for j=155 out of 250 (i.e. j=6655 in [6501;6750], as job id is i=27)"
[1] "seed 5733 for j=156 out of 250 (i.e. j=6656 in [6501;6750], as job id is i=27)"
[1] "seed 88671 for j=157 out of 250 (i.e. j=6657 in [6501;6750], as job id is i=27)"
[1] "seed 69917 for j=158 out of 250 (i.e. j=6658 in [6501;6750], as job id is i=27)"
[1] "seed 28810 for j=159 out of 250 (i.e. j=6659 in [6501;6750], as job id is i=27)"
[1] "seed 54978 for j=160 out of 250 (i.e. j=6660 in [6501;6750], as job id is i=27)"
[1] "seed 14460 for j=161 out of 250 (i.e. j=6661 in [6501;6750], as job id is i=27)"
[1] "seed 35343 for j=162 out of 250 (i.e. j=6662 in [6501;6750], as job id is i=27)"
[1] "seed 19246 for j=163 out of 250 (i.e. j=6663 in [6501;6750], as job id is i=27)"
[1] "seed 87526 for j=164 out of 250 (i.e. j=6664 in [6501;6750], as job id is i=27)"
[1] "seed 47148 for j=165 out of 250 (i.e. j=6665 in [6501;6750], as job id is i=27)"
[1] "seed 89009 for j=166 out of 250 (i.e. j=6666 in [6501;6750], as job id is i=27)"
[1] "seed 84939 for j=167 out of 250 (i.e. j=6667 in [6501;6750], as job id is i=27)"
[1] "seed 85435 for j=168 out of 250 (i.e. j=6668 in [6501;6750], as job id is i=27)"
[1] "seed 50424 for j=169 out of 250 (i.e. j=6669 in [6501;6750], as job id is i=27)"
[1] "seed 26029 for j=170 out of 250 (i.e. j=6670 in [6501;6750], as job id is i=27)"
[1] "seed 78530 for j=171 out of 250 (i.e. j=6671 in [6501;6750], as job id is i=27)"
[1] "seed 43827 for j=172 out of 250 (i.e. j=6672 in [6501;6750], as job id is i=27)"
[1] "seed 81828 for j=173 out of 250 (i.e. j=6673 in [6501;6750], as job id is i=27)"
[1] "seed 71324 for j=174 out of 250 (i.e. j=6674 in [6501;6750], as job id is i=27)"
[1] "seed 87458 for j=175 out of 250 (i.e. j=6675 in [6501;6750], as job id is i=27)"
[1] "seed 69489 for j=176 out of 250 (i.e. j=6676 in [6501;6750], as job id is i=27)"
[1] "seed 3125 for j=177 out of 250 (i.e. j=6677 in [6501;6750], as job id is i=27)"
[1] "seed 82879 for j=178 out of 250 (i.e. j=6678 in [6501;6750], as job id is i=27)"
[1] "seed 70260 for j=179 out of 250 (i.e. j=6679 in [6501;6750], as job id is i=27)"
[1] "seed 6351 for j=180 out of 250 (i.e. j=6680 in [6501;6750], as job id is i=27)"
[1] "seed 81069 for j=181 out of 250 (i.e. j=6681 in [6501;6750], as job id is i=27)"
[1] "seed 44739 for j=182 out of 250 (i.e. j=6682 in [6501;6750], as job id is i=27)"
[1] "seed 76922 for j=183 out of 250 (i.e. j=6683 in [6501;6750], as job id is i=27)"
[1] "seed 11241 for j=184 out of 250 (i.e. j=6684 in [6501;6750], as job id is i=27)"
[1] "seed 38938 for j=185 out of 250 (i.e. j=6685 in [6501;6750], as job id is i=27)"
[1] "seed 46758 for j=186 out of 250 (i.e. j=6686 in [6501;6750], as job id is i=27)"
[1] "seed 11774 for j=187 out of 250 (i.e. j=6687 in [6501;6750], as job id is i=27)"
[1] "seed 57283 for j=188 out of 250 (i.e. j=6688 in [6501;6750], as job id is i=27)"
[1] "seed 86831 for j=189 out of 250 (i.e. j=6689 in [6501;6750], as job id is i=27)"
[1] "seed 48617 for j=190 out of 250 (i.e. j=6690 in [6501;6750], as job id is i=27)"
[1] "seed 54382 for j=191 out of 250 (i.e. j=6691 in [6501;6750], as job id is i=27)"
[1] "seed 36162 for j=192 out of 250 (i.e. j=6692 in [6501;6750], as job id is i=27)"
[1] "seed 97034 for j=193 out of 250 (i.e. j=6693 in [6501;6750], as job id is i=27)"
[1] "seed 20261 for j=194 out of 250 (i.e. j=6694 in [6501;6750], as job id is i=27)"
[1] "seed 82759 for j=195 out of 250 (i.e. j=6695 in [6501;6750], as job id is i=27)"
[1] "seed 29475 for j=196 out of 250 (i.e. j=6696 in [6501;6750], as job id is i=27)"
[1] "seed 84180 for j=197 out of 250 (i.e. j=6697 in [6501;6750], as job id is i=27)"
[1] "seed 76157 for j=198 out of 250 (i.e. j=6698 in [6501;6750], as job id is i=27)"
[1] "seed 87014 for j=199 out of 250 (i.e. j=6699 in [6501;6750], as job id is i=27)"
[1] "seed 70603 for j=200 out of 250 (i.e. j=6700 in [6501;6750], as job id is i=27)"
[1] "seed 30207 for j=201 out of 250 (i.e. j=6701 in [6501;6750], as job id is i=27)"
[1] "seed 66616 for j=202 out of 250 (i.e. j=6702 in [6501;6750], as job id is i=27)"
[1] "seed 70498 for j=203 out of 250 (i.e. j=6703 in [6501;6750], as job id is i=27)"
[1] "seed 91351 for j=204 out of 250 (i.e. j=6704 in [6501;6750], as job id is i=27)"
[1] "seed 14896 for j=205 out of 250 (i.e. j=6705 in [6501;6750], as job id is i=27)"
[1] "seed 27303 for j=206 out of 250 (i.e. j=6706 in [6501;6750], as job id is i=27)"
[1] "seed 31229 for j=207 out of 250 (i.e. j=6707 in [6501;6750], as job id is i=27)"
[1] "seed 46157 for j=208 out of 250 (i.e. j=6708 in [6501;6750], as job id is i=27)"
[1] "seed 35917 for j=209 out of 250 (i.e. j=6709 in [6501;6750], as job id is i=27)"
[1] "seed 70189 for j=210 out of 250 (i.e. j=6710 in [6501;6750], as job id is i=27)"
[1] "seed 46671 for j=211 out of 250 (i.e. j=6711 in [6501;6750], as job id is i=27)"
[1] "seed 50744 for j=212 out of 250 (i.e. j=6712 in [6501;6750], as job id is i=27)"
[1] "seed 53027 for j=213 out of 250 (i.e. j=6713 in [6501;6750], as job id is i=27)"
[1] "seed 60828 for j=214 out of 250 (i.e. j=6714 in [6501;6750], as job id is i=27)"
[1] "seed 24124 for j=215 out of 250 (i.e. j=6715 in [6501;6750], as job id is i=27)"
[1] "seed 12683 for j=216 out of 250 (i.e. j=6716 in [6501;6750], as job id is i=27)"
[1] "seed 18507 for j=217 out of 250 (i.e. j=6717 in [6501;6750], as job id is i=27)"
[1] "seed 68158 for j=218 out of 250 (i.e. j=6718 in [6501;6750], as job id is i=27)"
[1] "seed 11646 for j=219 out of 250 (i.e. j=6719 in [6501;6750], as job id is i=27)"
[1] "seed 31556 for j=220 out of 250 (i.e. j=6720 in [6501;6750], as job id is i=27)"
[1] "seed 87206 for j=221 out of 250 (i.e. j=6721 in [6501;6750], as job id is i=27)"
[1] "seed 36912 for j=222 out of 250 (i.e. j=6722 in [6501;6750], as job id is i=27)"
[1] "seed 99953 for j=223 out of 250 (i.e. j=6723 in [6501;6750], as job id is i=27)"
[1] "seed 57077 for j=224 out of 250 (i.e. j=6724 in [6501;6750], as job id is i=27)"
[1] "seed 40163 for j=225 out of 250 (i.e. j=6725 in [6501;6750], as job id is i=27)"
[1] "seed 29532 for j=226 out of 250 (i.e. j=6726 in [6501;6750], as job id is i=27)"
[1] "seed 61306 for j=227 out of 250 (i.e. j=6727 in [6501;6750], as job id is i=27)"
[1] "seed 2206 for j=228 out of 250 (i.e. j=6728 in [6501;6750], as job id is i=27)"
[1] "seed 7453 for j=229 out of 250 (i.e. j=6729 in [6501;6750], as job id is i=27)"
[1] "seed 46503 for j=230 out of 250 (i.e. j=6730 in [6501;6750], as job id is i=27)"
[1] "seed 76280 for j=231 out of 250 (i.e. j=6731 in [6501;6750], as job id is i=27)"
[1] "seed 87235 for j=232 out of 250 (i.e. j=6732 in [6501;6750], as job id is i=27)"
[1] "seed 62134 for j=233 out of 250 (i.e. j=6733 in [6501;6750], as job id is i=27)"
[1] "seed 12761 for j=234 out of 250 (i.e. j=6734 in [6501;6750], as job id is i=27)"
[1] "seed 75369 for j=235 out of 250 (i.e. j=6735 in [6501;6750], as job id is i=27)"
[1] "seed 25385 for j=236 out of 250 (i.e. j=6736 in [6501;6750], as job id is i=27)"
[1] "seed 38479 for j=237 out of 250 (i.e. j=6737 in [6501;6750], as job id is i=27)"
[1] "seed 85468 for j=238 out of 250 (i.e. j=6738 in [6501;6750], as job id is i=27)"
[1] "seed 82369 for j=239 out of 250 (i.e. j=6739 in [6501;6750], as job id is i=27)"
[1] "seed 73923 for j=240 out of 250 (i.e. j=6740 in [6501;6750], as job id is i=27)"
[1] "seed 82978 for j=241 out of 250 (i.e. j=6741 in [6501;6750], as job id is i=27)"
[1] "seed 84090 for j=242 out of 250 (i.e. j=6742 in [6501;6750], as job id is i=27)"
[1] "seed 99521 for j=243 out of 250 (i.e. j=6743 in [6501;6750], as job id is i=27)"
[1] "seed 72639 for j=244 out of 250 (i.e. j=6744 in [6501;6750], as job id is i=27)"
[1] "seed 11377 for j=245 out of 250 (i.e. j=6745 in [6501;6750], as job id is i=27)"
[1] "seed 95110 for j=246 out of 250 (i.e. j=6746 in [6501;6750], as job id is i=27)"
[1] "seed 34971 for j=247 out of 250 (i.e. j=6747 in [6501;6750], as job id is i=27)"
[1] "seed 46548 for j=248 out of 250 (i.e. j=6748 in [6501;6750], as job id is i=27)"
[1] "seed 25411 for j=249 out of 250 (i.e. j=6749 in [6501;6750], as job id is i=27)"
[1] "seed 46275 for j=250 out of 250 (i.e. j=6750 in [6501;6750], as job id is i=27)"
There were 22 warnings (use warnings() to see them)
> rownames(RES) <- NULL
> save(RES,file=paste0(path.res,name,"-",iter_sim,".rda"))
> 
> ## * Summary results
> sessionInfo()
R version 4.1.2 (2021-11-01)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux 8.5 (Ootpa)

Matrix products: default
BLAS:   /opt/software/R/4.1.2/lib64/R/lib/libRblas.so
LAPACK: /opt/software/R/4.1.2/lib64/R/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] mvtnorm_1.1-3    DelayedGSD_0.0.3

loaded via a namespace (and not attached):
 [1] BB_2019.10-1     magrittr_2.0.3   tidyselect_1.1.2 munsell_0.5.0   
 [5] lattice_0.20-45  colorspace_2.0-3 xtable_1.8-4     R6_2.5.1        
 [9] quadprog_1.5-8   rlang_1.0.3      fansi_1.0.3      dplyr_1.0.9     
[13] grid_4.1.2       nlme_3.1-153     gtable_0.3.0     gsDesign_3.3.0  
[17] utf8_1.2.2       cli_3.3.0        ellipsis_0.3.2   tibble_3.1.7    
[21] lifecycle_1.0.1  crayon_1.5.1     purrr_0.3.4      ggplot2_3.3.6   
[25] tidyr_1.2.0      vctrs_0.4.1      glue_1.6.2       compiler_4.1.2  
[29] pillar_1.7.0     generics_0.1.3   scales_1.2.0     pkgconfig_2.0.3 
> summary(RES)
     method        stage           type             statistic     
 Min.   :1.0   Min.   :1.000   Length:1500        Min.   :0.0343  
 1st Qu.:1.0   1st Qu.:1.000   Class :character   1st Qu.:1.5995  
 Median :1.5   Median :1.000   Mode  :character   Median :2.3904  
 Mean   :1.5   Mean   :1.333                      Mean   :2.3186  
 3rd Qu.:2.0   3rd Qu.:2.000                      3rd Qu.:3.0408  
 Max.   :2.0   Max.   :2.000                      Max.   :5.0280  
                                                  NA's   :500     
  estimate_ML          se_ML             info           infoPC      
 Min.   :-0.1284   Min.   :0.3384   Min.   :4.379   Min.   :0.3422  
 1st Qu.: 0.5744   1st Qu.:0.3843   1st Qu.:5.746   1st Qu.:0.4490  
 Median : 0.8473   Median :0.4006   Median :6.293   Median :0.4917  
 Mean   : 0.8185   Mean   :0.4016   Mean   :6.352   Mean   :0.4964  
 3rd Qu.: 1.0700   3rd Qu.:0.4200   3rd Qu.:6.863   3rd Qu.:0.5363  
 Max.   : 1.7771   Max.   :0.4779   Max.   :9.168   Max.   :0.7164  
 NA's   :500       NA's   :1000     NA's   :168     NA's   :168     
   info.pred      infoPC.pred           uk              lk         
 Min.   :4.667   Min.   :0.3647   Min.   :2.269   Min.   :-0.3137  
 1st Qu.:6.003   1st Qu.:0.4691   1st Qu.:2.457   1st Qu.: 0.1453  
 Median :6.604   Median :0.5160   Median :2.517   Median : 0.3262  
 Mean   :6.670   Mean   :0.5212   Mean   :2.516   Mean   : 0.3320  
 3rd Qu.:7.249   3rd Qu.:0.5665   3rd Qu.:2.582   3rd Qu.: 0.4928  
 Max.   :9.418   Max.   :0.7359   Max.   :2.756   Max.   : 1.0421  
 NA's   :1000    NA's   :1000     NA's   :1000    NA's   :1000     
   decision            reason            p.value_ML        lower_ML      
 Length:1500        Length:1500        Min.   :0.0000   Min.   :-0.9714  
 Class :character   Class :character   1st Qu.:0.0010   1st Qu.:-0.0292  
 Mode  :character   Mode  :character   Median :0.0056   Median : 0.1723  
                                       Mean   :0.0722   Mean   : 0.1280  
                                       3rd Qu.:0.0320   3rd Qu.: 0.3319  
                                       Max.   :0.9039   Max.   : 0.9405  
                                       NA's   :1000     NA's   :1000     
    upper_ML       p.value_MUE       lower_MUE         upper_MUE     
 Min.   :0.6476   Min.   :0.0000   Min.   :-0.9673   Min.   :0.6435  
 1st Qu.:1.2541   1st Qu.:0.0032   1st Qu.:-0.0444   1st Qu.:1.2461  
 Median :1.5381   Median :0.0068   Median : 0.0873   Median :1.5002  
 Mean   :1.5652   Mean   :0.0484   Mean   : 0.0872   Mean   :1.5705  
 3rd Qu.:1.8595   3rd Qu.:0.0193   3rd Qu.: 0.2059   3rd Qu.:1.8690  
 Max.   :2.6137   Max.   :0.7827   Max.   : 1.6632   Max.   :3.0655  
 NA's   :1000     NA's   :1000     NA's   :1000      NA's   :1000    
  estimate_MUE           ck          time.interim        seed      
 Min.   :-0.1272   Min.   :-0.090   Min.   :537.0   Min.   :  168  
 1st Qu.: 0.6115   1st Qu.: 1.402   1st Qu.:585.0   1st Qu.:25622  
 Median : 0.8417   Median : 1.452   Median :601.5   Median :48707  
 Mean   : 0.8384   Mean   : 1.420   Mean   :602.5   Mean   :49752  
 3rd Qu.: 1.0625   3rd Qu.: 1.514   3rd Qu.:622.0   3rd Qu.:73994  
 Max.   : 2.2641   Max.   : 1.684   Max.   :677.0   Max.   :99953  
 NA's   :1000      NA's   :668                                     
  nX1.interim     nX2.interim     nX3.interim    computation.time
 Min.   :145.0   Min.   :131.0   Min.   :120.0   Min.   :0.722   
 1st Qu.:147.0   1st Qu.:135.0   1st Qu.:125.0   1st Qu.:0.910   
 Median :149.0   Median :137.0   Median :127.0   Median :1.006   
 Mean   :148.7   Mean   :136.6   Mean   :127.2   Mean   :1.035   
 3rd Qu.:150.0   3rd Qu.:138.0   3rd Qu.:129.0   3rd Qu.:1.159   
 Max.   :155.0   Max.   :143.0   Max.   :134.0   Max.   :3.821   
                                                                 
> 
> #----------------------------------------------------------------------
> ### BATCH_simuMain.R ends here
> 
> proc.time()
   user  system elapsed 
260.468   0.988 272.741 
