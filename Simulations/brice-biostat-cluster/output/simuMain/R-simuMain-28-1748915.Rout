
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### BATCH_simuMain.R --- 
> #----------------------------------------------------------------------
> ## Author: Paul Blanche
> ## Created: Mar  5 2021 (10:56) 
> ## Version: 
> ## Last-Updated: jul  7 2022 (13:56) 
> ##           By: Brice Ozenne
> ##     Update #: 518
> #----------------------------------------------------------------------
> ## 
> ### Commentary: 
> ## 
> ### Change Log:
> #----------------------------------------------------------------------
> ## 
> ### Code:
> 
> ## ** BATCH loop
> ## cd /projects/biostat01/people/hpl802/DelayedGSD/
> ## for ITER in `seq 1 10`;
> ## do
> ## eval 'R CMD BATCH --vanilla "--args iter_sim='$ITER' n.iter_sim=10" BATCH_simuMain.R output/R-simuMain-'$ITER'.Rout &'
> ## done
> 
> ## [1] 1186669
> ## [2] 1186670
> ## [3] 1186671
> ## [4] 1186672
> ## [5] 1186673
> ## [6] 1186674
> ## [7] 1186675
> ## [8] 1186676
> ## [9] 1186677
> ## [10] 1186678
> 
> rm(list=ls())
>                                    # {{{ parameters
> ## * parameters
> name <- "ScenarioName" # To save the results
> method <- 1:2 # methods used to compute the boundaries
>                                         #---
> myseed <- 140786598
>                                         #--- to plan the trial ----
> NMC <- 250 # number of sequential simulations to run in parallel. Eg. with 250, then we can run 40 scripts in paralell to get N=10,000 runs in total.
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.5,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.55  #(expected) information rate at each decision analysis
> binding <- TRUE
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.6,0.8) # treatment effect
> ar <- (0.86*2)*2 # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As to low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> Miss11 <- 5/104 # miss both V1 and V2
> Miss12 <- 1/104 # miss V1 and but not V2
> Miss21 <- 6/104 # do not miss V1 and but miss V2
> Miss22 <- 92/104 # miss none
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- abs(delta[3]) # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> n <- ceiling(2*2*((allsd[3]/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
>                                         # {{{ Set seeds for parallel computing and reproducibility
> ## * Seed
> args <- commandArgs(TRUE) ## BATCH MODE
> if(length(args)>0){
+     for (arg in args){
+         eval(parse(text=arg))
+     }
+ }else{ ## SLUMR
+     iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
+     n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
+ } ## interactive
> if(is.na(iter_sim)){iter_sim <- 1}
> if(is.na(n.iter_sim)){n.iter_sim <- 40}
> 
> set.seed(140786598)
> allseeds <- sample.int(n = 10*n.iter_sim*NMC, size = n.iter_sim*NMC, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> # }}}
> 
> # {{{ set path to load and save and othe machine specific variables
> ## * path
> path <- "."
> path.res <- file.path(path,"Results","simuMain")
> if(dir.exists(path.res)==FALSE){
+     if(dir.exists(file.path(path,"Results"))==FALSE){
+     dir.create(file.path(path,"Results"))
+     }
+     dir.create(path.res)
+ }
> path.output <- file.path(path,"output","simuMain")
> if(dir.exists(path.output)==FALSE){
+     if(dir.exists(file.path(path,"output"))==FALSE){
+     dir.create(file.path(path,"output"))
+     }
+     dir.create(path.output)
+ }
> # }}}
> 
> 
> ## * libraries and functions
> library(DelayedGSD)
DelayedGSD version 0.0.3
> ## sourceDir <- function(path, trace = TRUE, ...) {
> ##     for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
> ##         if(trace) cat(nm,":")
> ##         source(file.path(path, nm), ...)
> ##         if(trace) cat("\n")
> ##     }
> ## }
> ## sourceDir(pathToLoad)
>     
> 
> ## * Compute inflation factor and sample size
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+     plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                         alpha=alpha, 
+                                         beta=beta,  
+                                         InfoR.i=informationRates,  
+                                         InfoR.d=c(Id,1),  
+                                         rho_alpha=rho_alpha,  
+                                         rho_beta=rho_beta,  
+                                         method=iMeth,  
+                                         cNotBelowFixedc=FALSE,
+                                         bindingFutility=binding,
+                                         delta=tail(delta,1))
+     ## summary(plannedB[[1]])
+     ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> ##  plot(plannedB[[1]])
> 
> #
> # --- just to check---
> ## n
> ## InfoFixed <- ((qnorm(1-beta)-qnorm(alpha))/(deltaPower))^2
> ## InfoFixed
> ## n/(4*(allsd[3])^2)
> #---
> # }}}
> 
> 
> 
> 
> # {{{ technical details to loop
> RES <- NULL # initialize results to save
> allj <- ((iter_sim-1)*NMC + 1):(iter_sim*NMC) # indices of all iterations (replicates) for this job, accountng for the other jobs running in parallel
> # }}}
> 
> ## * Loop
> for(j in allj){ ## j <- 51 ## 5
+     startComp <- Sys.time()
+     myseedi <- allseeds[j]
+     # {{{ TRACE info (e.g. to check the Rout)
+     print(paste0("seed ",myseedi," for ","j=",which(j==allj)," out of ",NMC, " (i.e. j=",j," in [",(iter_sim-1)*NMC + 1,";",iter_sim*NMC,"], as job id is i=",iter_sim,")"))
+     # }}}
+     # {{{ Missing probabilities
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE) # to additionnally remove 1 more because some FASFL=N
+     colnames(MyMissProb) <- c("V2 missing","V2 not missing")
+     rownames(MyMissProb) <- c("V1 missing","V1 not missing")
+     # }}}
+ 
+                                         # {{{ generate data
+     ## ** simulate
+     res <- GenData(n=n, 
+                    N.fw=2,
+                    rand.block=block,
+                    allsd=allsd,
+                    mean0=mean0,
+                    delta=delta,
+                    ar=ar,
+                    cor.01.1=cor011,
+                    cor.ij.1=corij1,
+                    cor.0j.1=cor0j1,
+                    seed=myseedi,
+                    MissProb=MyMissProb,
+                    DigitsOutcome=2,
+                    TimeFactor=TimeFactor,
+                    DigitsTime=0
+                    )
+     d <- res$d
+     ## head(d,n=20)
+                                         # }}}
+                                         # {{{ reformat data like those of Corine
+     ## Make data long format
+     ## dd <- FormatAsCase(d)
+     ## head(dd)
+     ## summary(dd)
+                                         # }}}
+    
+                                         # {{{ make data available at interim
+                                         # Here we stop inclusion data collection for the interim analysis as soon as
+                                         # half of the participants have completed (or had the opportunity to complete) the follow-up 
+     thet <- d$t3[ceiling(n*PropForInterim)]
+     di <- SelectData(d,t=thet)
+     ## ddi <- FormatAsCase(di) # needed ????
+     ## head(d[d$id==52,])
+                                         # }}}
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thet + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     currentGSD <- vector(mode = "list", length = 3)
+     out.interim <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+ 
+         currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+ 
+         iConfint.interim <- confint(currentGSD[[iMeth]])
+         iInfo.interim <- coef(currentGSD[[iMeth]], type = "information")
+         iBoundary.interim <- coef(currentGSD[[iMeth]], type = "boundary")
+         iDecision.interim <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+         out.interim[[iMeth]] <-  data.frame(statistic = iConfint.interim[1,"statistic"],
+                                             estimate_ML = iConfint.interim[1,"estimate"],
+                                             se_ML = iConfint.interim[1,"se"],
+                                             info = iInfo.interim[1,"Interim"],
+                                             infoPC = iInfo.interim[1,"Interim.pc"],
+                                             info.pred = iInfo.interim[1,"Decision"],
+                                             infoPC.pred = iInfo.interim[1,"Decision.pc"],
+                                             uk = iBoundary.interim[1,"Ebound"],
+                                             lk = iBoundary.interim[1,"Fbound"],
+                                             decision = iDecision.interim["decision","stage 1"],
+                                             reason = iDecision.interim["reason.interim","stage 1"])
+     }
+     ## currentGSD[[1]]
+     ## plot(currentGSD[[1]])
+ 
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thet + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     out.decision <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+           
+         if(out.interim[[iMeth]]$decision == "stop"){
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+             ## plot(currentGSD[[iMeth]])
+ 
+             iConfint.decision <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.decision  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = iConfint.decision[1,"statistic"],
+                                                 p.value_ML = iConfint.decision[iConfint.decision$method == "ML","p.value"],
+                                                 lower_ML = iConfint.decision[iConfint.decision$method == "ML","lower"],
+                                                 upper_ML = iConfint.decision[iConfint.decision$method == "ML","upper"],
+                                                 estimate_ML = iConfint.decision[iConfint.decision$method == "ML","estimate"],
+                                                 p.value_MUE = iConfint.decision[iConfint.decision$method == "MUE","p.value"],
+                                                 lower_MUE = iConfint.decision[iConfint.decision$method == "MUE","lower"],
+                                                 upper_MUE = iConfint.decision[iConfint.decision$method == "MUE","upper"],
+                                                 estimate_MUE = iConfint.decision[iConfint.decision$method == "MUE","estimate"],
+                                                 info = iInfo.decision[1,"Interim"],
+                                                 infoPC = iInfo.decision[1,"Interim.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = unname(iDecision.decision["decision","stage 2"])
+                                                 )
+ 
+         }else{
+             ## update information
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+ 
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = NA,
+                                                 p.value_ML = NA,
+                                                 lower_ML = NA,
+                                                 upper_ML = NA,
+                                                 estimate_ML = NA,
+                                                 p.value_MUE = NA,
+                                                 lower_MUE = NA,
+                                                 upper_MUE = NA,
+                                                 estimate_MUE = NA,
+                                                 info = iInfo.decision[1,"Decision"],
+                                                 infoPC = iInfo.decision[1,"Decision.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = NA)
+         }
+     }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+ 
+     ## ** finale
+     dFinal <- d
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     out.final <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+         if(out.interim[[iMeth]]$decision == "stop"){
+             out.final[[iMeth]] <- data.frame(statistic = NA,
+                                              p.value_ML = NA,
+                                              lower_ML = NA,
+                                              upper_ML = NA,
+                                              estimate_ML = NA,
+                                              p.value_MUE = NA,
+                                              lower_MUE = NA,
+                                              upper_MUE = NA,
+                                              estimate_MUE = NA,
+                                              info = NA,
+                                              infoPC = NA,
+                                              ck = NA,
+                                              decision = NA)
+ 
+         }else{
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+ 
+             ## plot(test)
+             ## summary(test)
+             iConfint.final <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.final <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.final <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.final  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.final[[iMeth]] <- data.frame(statistic = iConfint.final[1,"statistic"],
+                                              p.value_ML = iConfint.final[iConfint.final$method == "ML","p.value"],
+                                              lower_ML = iConfint.final[iConfint.final$method == "ML","lower"],
+                                              upper_ML = iConfint.final[iConfint.final$method == "ML","upper"],
+                                              estimate_ML = iConfint.final[iConfint.final$method == "ML","estimate"],
+                                              p.value_MUE = iConfint.final[iConfint.final$method == "MUE","p.value"],
+                                              lower_MUE = iConfint.final[iConfint.final$method == "MUE","lower"],
+                                              upper_MUE = iConfint.final[iConfint.final$method == "MUE","upper"],
+                                              estimate_MUE = iConfint.final[iConfint.final$method == "MUE","estimate"],
+                                              info = iInfo.final[1,"Interim"],
+                                              infoPC = iInfo.final[1,"Interim.pc"],
+                                              ck = iBoundary.final[1,"Cbound"],
+                                              decision = unname(coef(currentGSD[[iMeth]], type = "decision")["decision","stage 2"])
+                                              )
+         }
+     }
+                                         # }}}
+ 
+     stopComp <- Sys.time()
+                                         # {{{ Save results
+ 
+     outMerge <- do.call(rbind,lapply(method, function(iMeth){
+         iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+         iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+         iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+         iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+         iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+         return(iMerge)
+     }))
+ 
+     ## outMerge[outMerge$method==3,]
+ 
+     out <- cbind(
+         ## results
+         outMerge,
+         ## simulation details
+         time.interim = thet,
+         seed=myseedi,             
+         nX1.interim = sum(!is.na(di$X1)),
+         nX2.interim = sum(!is.na(di$X2)),
+         nX3.interim = sum(!is.na(di$X3)),
+         ## computation time
+         computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+     )
+     ## names(out) <- myColNames
+     RES <- rbind(RES,out)
+     save(RES,file=paste0(path.res,name,"(tempo)-",iter_sim,".rda"))
+                                         # }}}
+ }
[1] "seed 13675 for j=1 out of 250 (i.e. j=6751 in [6751;7000], as job id is i=28)"
Loading required namespace: nlme
[1] "seed 86203 for j=2 out of 250 (i.e. j=6752 in [6751;7000], as job id is i=28)"
[1] "seed 41878 for j=3 out of 250 (i.e. j=6753 in [6751;7000], as job id is i=28)"
[1] "seed 32557 for j=4 out of 250 (i.e. j=6754 in [6751;7000], as job id is i=28)"
[1] "seed 61662 for j=5 out of 250 (i.e. j=6755 in [6751;7000], as job id is i=28)"
[1] "seed 71160 for j=6 out of 250 (i.e. j=6756 in [6751;7000], as job id is i=28)"
[1] "seed 8240 for j=7 out of 250 (i.e. j=6757 in [6751;7000], as job id is i=28)"
[1] "seed 47728 for j=8 out of 250 (i.e. j=6758 in [6751;7000], as job id is i=28)"
[1] "seed 28256 for j=9 out of 250 (i.e. j=6759 in [6751;7000], as job id is i=28)"
[1] "seed 99754 for j=10 out of 250 (i.e. j=6760 in [6751;7000], as job id is i=28)"
[1] "seed 83076 for j=11 out of 250 (i.e. j=6761 in [6751;7000], as job id is i=28)"
[1] "seed 67241 for j=12 out of 250 (i.e. j=6762 in [6751;7000], as job id is i=28)"
[1] "seed 70967 for j=13 out of 250 (i.e. j=6763 in [6751;7000], as job id is i=28)"
[1] "seed 81095 for j=14 out of 250 (i.e. j=6764 in [6751;7000], as job id is i=28)"
[1] "seed 73411 for j=15 out of 250 (i.e. j=6765 in [6751;7000], as job id is i=28)"
[1] "seed 23097 for j=16 out of 250 (i.e. j=6766 in [6751;7000], as job id is i=28)"
[1] "seed 64190 for j=17 out of 250 (i.e. j=6767 in [6751;7000], as job id is i=28)"
[1] "seed 58793 for j=18 out of 250 (i.e. j=6768 in [6751;7000], as job id is i=28)"
[1] "seed 17112 for j=19 out of 250 (i.e. j=6769 in [6751;7000], as job id is i=28)"
[1] "seed 13517 for j=20 out of 250 (i.e. j=6770 in [6751;7000], as job id is i=28)"
[1] "seed 37175 for j=21 out of 250 (i.e. j=6771 in [6751;7000], as job id is i=28)"
[1] "seed 86312 for j=22 out of 250 (i.e. j=6772 in [6751;7000], as job id is i=28)"
[1] "seed 23283 for j=23 out of 250 (i.e. j=6773 in [6751;7000], as job id is i=28)"
[1] "seed 18018 for j=24 out of 250 (i.e. j=6774 in [6751;7000], as job id is i=28)"
[1] "seed 21439 for j=25 out of 250 (i.e. j=6775 in [6751;7000], as job id is i=28)"
[1] "seed 71815 for j=26 out of 250 (i.e. j=6776 in [6751;7000], as job id is i=28)"
[1] "seed 9715 for j=27 out of 250 (i.e. j=6777 in [6751;7000], as job id is i=28)"
[1] "seed 4626 for j=28 out of 250 (i.e. j=6778 in [6751;7000], as job id is i=28)"
[1] "seed 71678 for j=29 out of 250 (i.e. j=6779 in [6751;7000], as job id is i=28)"
[1] "seed 5167 for j=30 out of 250 (i.e. j=6780 in [6751;7000], as job id is i=28)"
[1] "seed 61388 for j=31 out of 250 (i.e. j=6781 in [6751;7000], as job id is i=28)"
[1] "seed 48898 for j=32 out of 250 (i.e. j=6782 in [6751;7000], as job id is i=28)"
[1] "seed 86207 for j=33 out of 250 (i.e. j=6783 in [6751;7000], as job id is i=28)"
[1] "seed 29599 for j=34 out of 250 (i.e. j=6784 in [6751;7000], as job id is i=28)"
[1] "seed 62309 for j=35 out of 250 (i.e. j=6785 in [6751;7000], as job id is i=28)"
[1] "seed 22504 for j=36 out of 250 (i.e. j=6786 in [6751;7000], as job id is i=28)"
[1] "seed 81448 for j=37 out of 250 (i.e. j=6787 in [6751;7000], as job id is i=28)"
[1] "seed 64932 for j=38 out of 250 (i.e. j=6788 in [6751;7000], as job id is i=28)"
[1] "seed 87201 for j=39 out of 250 (i.e. j=6789 in [6751;7000], as job id is i=28)"
[1] "seed 44667 for j=40 out of 250 (i.e. j=6790 in [6751;7000], as job id is i=28)"
[1] "seed 78773 for j=41 out of 250 (i.e. j=6791 in [6751;7000], as job id is i=28)"
[1] "seed 91768 for j=42 out of 250 (i.e. j=6792 in [6751;7000], as job id is i=28)"
[1] "seed 49559 for j=43 out of 250 (i.e. j=6793 in [6751;7000], as job id is i=28)"
[1] "seed 91026 for j=44 out of 250 (i.e. j=6794 in [6751;7000], as job id is i=28)"
[1] "seed 14060 for j=45 out of 250 (i.e. j=6795 in [6751;7000], as job id is i=28)"
[1] "seed 60292 for j=46 out of 250 (i.e. j=6796 in [6751;7000], as job id is i=28)"
[1] "seed 60842 for j=47 out of 250 (i.e. j=6797 in [6751;7000], as job id is i=28)"
[1] "seed 18724 for j=48 out of 250 (i.e. j=6798 in [6751;7000], as job id is i=28)"
[1] "seed 97538 for j=49 out of 250 (i.e. j=6799 in [6751;7000], as job id is i=28)"
[1] "seed 53480 for j=50 out of 250 (i.e. j=6800 in [6751;7000], as job id is i=28)"
[1] "seed 69819 for j=51 out of 250 (i.e. j=6801 in [6751;7000], as job id is i=28)"
[1] "seed 74129 for j=52 out of 250 (i.e. j=6802 in [6751;7000], as job id is i=28)"
[1] "seed 61706 for j=53 out of 250 (i.e. j=6803 in [6751;7000], as job id is i=28)"
[1] "seed 78743 for j=54 out of 250 (i.e. j=6804 in [6751;7000], as job id is i=28)"
[1] "seed 98772 for j=55 out of 250 (i.e. j=6805 in [6751;7000], as job id is i=28)"
[1] "seed 55740 for j=56 out of 250 (i.e. j=6806 in [6751;7000], as job id is i=28)"
[1] "seed 39011 for j=57 out of 250 (i.e. j=6807 in [6751;7000], as job id is i=28)"
[1] "seed 13381 for j=58 out of 250 (i.e. j=6808 in [6751;7000], as job id is i=28)"
[1] "seed 70355 for j=59 out of 250 (i.e. j=6809 in [6751;7000], as job id is i=28)"
[1] "seed 86034 for j=60 out of 250 (i.e. j=6810 in [6751;7000], as job id is i=28)"
[1] "seed 16054 for j=61 out of 250 (i.e. j=6811 in [6751;7000], as job id is i=28)"
[1] "seed 55268 for j=62 out of 250 (i.e. j=6812 in [6751;7000], as job id is i=28)"
[1] "seed 82568 for j=63 out of 250 (i.e. j=6813 in [6751;7000], as job id is i=28)"
[1] "seed 17860 for j=64 out of 250 (i.e. j=6814 in [6751;7000], as job id is i=28)"
[1] "seed 86412 for j=65 out of 250 (i.e. j=6815 in [6751;7000], as job id is i=28)"
[1] "seed 84311 for j=66 out of 250 (i.e. j=6816 in [6751;7000], as job id is i=28)"
[1] "seed 28711 for j=67 out of 250 (i.e. j=6817 in [6751;7000], as job id is i=28)"
[1] "seed 76927 for j=68 out of 250 (i.e. j=6818 in [6751;7000], as job id is i=28)"
[1] "seed 78254 for j=69 out of 250 (i.e. j=6819 in [6751;7000], as job id is i=28)"
[1] "seed 11324 for j=70 out of 250 (i.e. j=6820 in [6751;7000], as job id is i=28)"
[1] "seed 73219 for j=71 out of 250 (i.e. j=6821 in [6751;7000], as job id is i=28)"
[1] "seed 61439 for j=72 out of 250 (i.e. j=6822 in [6751;7000], as job id is i=28)"
[1] "seed 51612 for j=73 out of 250 (i.e. j=6823 in [6751;7000], as job id is i=28)"
[1] "seed 23274 for j=74 out of 250 (i.e. j=6824 in [6751;7000], as job id is i=28)"
[1] "seed 82140 for j=75 out of 250 (i.e. j=6825 in [6751;7000], as job id is i=28)"
[1] "seed 2901 for j=76 out of 250 (i.e. j=6826 in [6751;7000], as job id is i=28)"
[1] "seed 37058 for j=77 out of 250 (i.e. j=6827 in [6751;7000], as job id is i=28)"
[1] "seed 25816 for j=78 out of 250 (i.e. j=6828 in [6751;7000], as job id is i=28)"
[1] "seed 70297 for j=79 out of 250 (i.e. j=6829 in [6751;7000], as job id is i=28)"
[1] "seed 20166 for j=80 out of 250 (i.e. j=6830 in [6751;7000], as job id is i=28)"
[1] "seed 34542 for j=81 out of 250 (i.e. j=6831 in [6751;7000], as job id is i=28)"
[1] "seed 86937 for j=82 out of 250 (i.e. j=6832 in [6751;7000], as job id is i=28)"
[1] "seed 36748 for j=83 out of 250 (i.e. j=6833 in [6751;7000], as job id is i=28)"
[1] "seed 35034 for j=84 out of 250 (i.e. j=6834 in [6751;7000], as job id is i=28)"
[1] "seed 70447 for j=85 out of 250 (i.e. j=6835 in [6751;7000], as job id is i=28)"
[1] "seed 88375 for j=86 out of 250 (i.e. j=6836 in [6751;7000], as job id is i=28)"
[1] "seed 98360 for j=87 out of 250 (i.e. j=6837 in [6751;7000], as job id is i=28)"
[1] "seed 9547 for j=88 out of 250 (i.e. j=6838 in [6751;7000], as job id is i=28)"
[1] "seed 71414 for j=89 out of 250 (i.e. j=6839 in [6751;7000], as job id is i=28)"
[1] "seed 76817 for j=90 out of 250 (i.e. j=6840 in [6751;7000], as job id is i=28)"
[1] "seed 1716 for j=91 out of 250 (i.e. j=6841 in [6751;7000], as job id is i=28)"
[1] "seed 28787 for j=92 out of 250 (i.e. j=6842 in [6751;7000], as job id is i=28)"
[1] "seed 85697 for j=93 out of 250 (i.e. j=6843 in [6751;7000], as job id is i=28)"
[1] "seed 58526 for j=94 out of 250 (i.e. j=6844 in [6751;7000], as job id is i=28)"
[1] "seed 70278 for j=95 out of 250 (i.e. j=6845 in [6751;7000], as job id is i=28)"
[1] "seed 61368 for j=96 out of 250 (i.e. j=6846 in [6751;7000], as job id is i=28)"
[1] "seed 40029 for j=97 out of 250 (i.e. j=6847 in [6751;7000], as job id is i=28)"
[1] "seed 12572 for j=98 out of 250 (i.e. j=6848 in [6751;7000], as job id is i=28)"
[1] "seed 44182 for j=99 out of 250 (i.e. j=6849 in [6751;7000], as job id is i=28)"
[1] "seed 36461 for j=100 out of 250 (i.e. j=6850 in [6751;7000], as job id is i=28)"
[1] "seed 34343 for j=101 out of 250 (i.e. j=6851 in [6751;7000], as job id is i=28)"
[1] "seed 49626 for j=102 out of 250 (i.e. j=6852 in [6751;7000], as job id is i=28)"
[1] "seed 84035 for j=103 out of 250 (i.e. j=6853 in [6751;7000], as job id is i=28)"
[1] "seed 61645 for j=104 out of 250 (i.e. j=6854 in [6751;7000], as job id is i=28)"
[1] "seed 50004 for j=105 out of 250 (i.e. j=6855 in [6751;7000], as job id is i=28)"
[1] "seed 71512 for j=106 out of 250 (i.e. j=6856 in [6751;7000], as job id is i=28)"
[1] "seed 22744 for j=107 out of 250 (i.e. j=6857 in [6751;7000], as job id is i=28)"
[1] "seed 91860 for j=108 out of 250 (i.e. j=6858 in [6751;7000], as job id is i=28)"
[1] "seed 59978 for j=109 out of 250 (i.e. j=6859 in [6751;7000], as job id is i=28)"
[1] "seed 1952 for j=110 out of 250 (i.e. j=6860 in [6751;7000], as job id is i=28)"
[1] "seed 31411 for j=111 out of 250 (i.e. j=6861 in [6751;7000], as job id is i=28)"
[1] "seed 70684 for j=112 out of 250 (i.e. j=6862 in [6751;7000], as job id is i=28)"
[1] "seed 41354 for j=113 out of 250 (i.e. j=6863 in [6751;7000], as job id is i=28)"
[1] "seed 5279 for j=114 out of 250 (i.e. j=6864 in [6751;7000], as job id is i=28)"
[1] "seed 78909 for j=115 out of 250 (i.e. j=6865 in [6751;7000], as job id is i=28)"
[1] "seed 61580 for j=116 out of 250 (i.e. j=6866 in [6751;7000], as job id is i=28)"
[1] "seed 16779 for j=117 out of 250 (i.e. j=6867 in [6751;7000], as job id is i=28)"
[1] "seed 90604 for j=118 out of 250 (i.e. j=6868 in [6751;7000], as job id is i=28)"
[1] "seed 98891 for j=119 out of 250 (i.e. j=6869 in [6751;7000], as job id is i=28)"
[1] "seed 67926 for j=120 out of 250 (i.e. j=6870 in [6751;7000], as job id is i=28)"
[1] "seed 82026 for j=121 out of 250 (i.e. j=6871 in [6751;7000], as job id is i=28)"
[1] "seed 10687 for j=122 out of 250 (i.e. j=6872 in [6751;7000], as job id is i=28)"
[1] "seed 17443 for j=123 out of 250 (i.e. j=6873 in [6751;7000], as job id is i=28)"
[1] "seed 39459 for j=124 out of 250 (i.e. j=6874 in [6751;7000], as job id is i=28)"
[1] "seed 16298 for j=125 out of 250 (i.e. j=6875 in [6751;7000], as job id is i=28)"
[1] "seed 70087 for j=126 out of 250 (i.e. j=6876 in [6751;7000], as job id is i=28)"
[1] "seed 42059 for j=127 out of 250 (i.e. j=6877 in [6751;7000], as job id is i=28)"
[1] "seed 51019 for j=128 out of 250 (i.e. j=6878 in [6751;7000], as job id is i=28)"
[1] "seed 84773 for j=129 out of 250 (i.e. j=6879 in [6751;7000], as job id is i=28)"
[1] "seed 91470 for j=130 out of 250 (i.e. j=6880 in [6751;7000], as job id is i=28)"
[1] "seed 39064 for j=131 out of 250 (i.e. j=6881 in [6751;7000], as job id is i=28)"
[1] "seed 13616 for j=132 out of 250 (i.e. j=6882 in [6751;7000], as job id is i=28)"
[1] "seed 74469 for j=133 out of 250 (i.e. j=6883 in [6751;7000], as job id is i=28)"
[1] "seed 69473 for j=134 out of 250 (i.e. j=6884 in [6751;7000], as job id is i=28)"
[1] "seed 84858 for j=135 out of 250 (i.e. j=6885 in [6751;7000], as job id is i=28)"
[1] "seed 31703 for j=136 out of 250 (i.e. j=6886 in [6751;7000], as job id is i=28)"
[1] "seed 46525 for j=137 out of 250 (i.e. j=6887 in [6751;7000], as job id is i=28)"
[1] "seed 38448 for j=138 out of 250 (i.e. j=6888 in [6751;7000], as job id is i=28)"
[1] "seed 19836 for j=139 out of 250 (i.e. j=6889 in [6751;7000], as job id is i=28)"
[1] "seed 20364 for j=140 out of 250 (i.e. j=6890 in [6751;7000], as job id is i=28)"
[1] "seed 77886 for j=141 out of 250 (i.e. j=6891 in [6751;7000], as job id is i=28)"
[1] "seed 36891 for j=142 out of 250 (i.e. j=6892 in [6751;7000], as job id is i=28)"
[1] "seed 69374 for j=143 out of 250 (i.e. j=6893 in [6751;7000], as job id is i=28)"
[1] "seed 99141 for j=144 out of 250 (i.e. j=6894 in [6751;7000], as job id is i=28)"
[1] "seed 68796 for j=145 out of 250 (i.e. j=6895 in [6751;7000], as job id is i=28)"
[1] "seed 3802 for j=146 out of 250 (i.e. j=6896 in [6751;7000], as job id is i=28)"
[1] "seed 95121 for j=147 out of 250 (i.e. j=6897 in [6751;7000], as job id is i=28)"
[1] "seed 44663 for j=148 out of 250 (i.e. j=6898 in [6751;7000], as job id is i=28)"
[1] "seed 39906 for j=149 out of 250 (i.e. j=6899 in [6751;7000], as job id is i=28)"
[1] "seed 55327 for j=150 out of 250 (i.e. j=6900 in [6751;7000], as job id is i=28)"
[1] "seed 30413 for j=151 out of 250 (i.e. j=6901 in [6751;7000], as job id is i=28)"
[1] "seed 70120 for j=152 out of 250 (i.e. j=6902 in [6751;7000], as job id is i=28)"
[1] "seed 14122 for j=153 out of 250 (i.e. j=6903 in [6751;7000], as job id is i=28)"
[1] "seed 52894 for j=154 out of 250 (i.e. j=6904 in [6751;7000], as job id is i=28)"
[1] "seed 20381 for j=155 out of 250 (i.e. j=6905 in [6751;7000], as job id is i=28)"
[1] "seed 45999 for j=156 out of 250 (i.e. j=6906 in [6751;7000], as job id is i=28)"
[1] "seed 32487 for j=157 out of 250 (i.e. j=6907 in [6751;7000], as job id is i=28)"
[1] "seed 64209 for j=158 out of 250 (i.e. j=6908 in [6751;7000], as job id is i=28)"
[1] "seed 71192 for j=159 out of 250 (i.e. j=6909 in [6751;7000], as job id is i=28)"
[1] "seed 50701 for j=160 out of 250 (i.e. j=6910 in [6751;7000], as job id is i=28)"
[1] "seed 77070 for j=161 out of 250 (i.e. j=6911 in [6751;7000], as job id is i=28)"
[1] "seed 14543 for j=162 out of 250 (i.e. j=6912 in [6751;7000], as job id is i=28)"
[1] "seed 97157 for j=163 out of 250 (i.e. j=6913 in [6751;7000], as job id is i=28)"
[1] "seed 53023 for j=164 out of 250 (i.e. j=6914 in [6751;7000], as job id is i=28)"
[1] "seed 19039 for j=165 out of 250 (i.e. j=6915 in [6751;7000], as job id is i=28)"
[1] "seed 3529 for j=166 out of 250 (i.e. j=6916 in [6751;7000], as job id is i=28)"
[1] "seed 51651 for j=167 out of 250 (i.e. j=6917 in [6751;7000], as job id is i=28)"
[1] "seed 29214 for j=168 out of 250 (i.e. j=6918 in [6751;7000], as job id is i=28)"
[1] "seed 33099 for j=169 out of 250 (i.e. j=6919 in [6751;7000], as job id is i=28)"
[1] "seed 40464 for j=170 out of 250 (i.e. j=6920 in [6751;7000], as job id is i=28)"
[1] "seed 80381 for j=171 out of 250 (i.e. j=6921 in [6751;7000], as job id is i=28)"
[1] "seed 18063 for j=172 out of 250 (i.e. j=6922 in [6751;7000], as job id is i=28)"
[1] "seed 66930 for j=173 out of 250 (i.e. j=6923 in [6751;7000], as job id is i=28)"
[1] "seed 69531 for j=174 out of 250 (i.e. j=6924 in [6751;7000], as job id is i=28)"
[1] "seed 11397 for j=175 out of 250 (i.e. j=6925 in [6751;7000], as job id is i=28)"
[1] "seed 84060 for j=176 out of 250 (i.e. j=6926 in [6751;7000], as job id is i=28)"
[1] "seed 2593 for j=177 out of 250 (i.e. j=6927 in [6751;7000], as job id is i=28)"
[1] "seed 69233 for j=178 out of 250 (i.e. j=6928 in [6751;7000], as job id is i=28)"
[1] "seed 89000 for j=179 out of 250 (i.e. j=6929 in [6751;7000], as job id is i=28)"
[1] "seed 64093 for j=180 out of 250 (i.e. j=6930 in [6751;7000], as job id is i=28)"
[1] "seed 30492 for j=181 out of 250 (i.e. j=6931 in [6751;7000], as job id is i=28)"
[1] "seed 17766 for j=182 out of 250 (i.e. j=6932 in [6751;7000], as job id is i=28)"
[1] "seed 31909 for j=183 out of 250 (i.e. j=6933 in [6751;7000], as job id is i=28)"
[1] "seed 28924 for j=184 out of 250 (i.e. j=6934 in [6751;7000], as job id is i=28)"
[1] "seed 90099 for j=185 out of 250 (i.e. j=6935 in [6751;7000], as job id is i=28)"
[1] "seed 47954 for j=186 out of 250 (i.e. j=6936 in [6751;7000], as job id is i=28)"
[1] "seed 47924 for j=187 out of 250 (i.e. j=6937 in [6751;7000], as job id is i=28)"
[1] "seed 31935 for j=188 out of 250 (i.e. j=6938 in [6751;7000], as job id is i=28)"
[1] "seed 85531 for j=189 out of 250 (i.e. j=6939 in [6751;7000], as job id is i=28)"
[1] "seed 68123 for j=190 out of 250 (i.e. j=6940 in [6751;7000], as job id is i=28)"
[1] "seed 94138 for j=191 out of 250 (i.e. j=6941 in [6751;7000], as job id is i=28)"
[1] "seed 94992 for j=192 out of 250 (i.e. j=6942 in [6751;7000], as job id is i=28)"
[1] "seed 96789 for j=193 out of 250 (i.e. j=6943 in [6751;7000], as job id is i=28)"
[1] "seed 70054 for j=194 out of 250 (i.e. j=6944 in [6751;7000], as job id is i=28)"
[1] "seed 70733 for j=195 out of 250 (i.e. j=6945 in [6751;7000], as job id is i=28)"
[1] "seed 45364 for j=196 out of 250 (i.e. j=6946 in [6751;7000], as job id is i=28)"
[1] "seed 13780 for j=197 out of 250 (i.e. j=6947 in [6751;7000], as job id is i=28)"
[1] "seed 10209 for j=198 out of 250 (i.e. j=6948 in [6751;7000], as job id is i=28)"
[1] "seed 56946 for j=199 out of 250 (i.e. j=6949 in [6751;7000], as job id is i=28)"
[1] "seed 84503 for j=200 out of 250 (i.e. j=6950 in [6751;7000], as job id is i=28)"
[1] "seed 89173 for j=201 out of 250 (i.e. j=6951 in [6751;7000], as job id is i=28)"
[1] "seed 1726 for j=202 out of 250 (i.e. j=6952 in [6751;7000], as job id is i=28)"
[1] "seed 77748 for j=203 out of 250 (i.e. j=6953 in [6751;7000], as job id is i=28)"
[1] "seed 6426 for j=204 out of 250 (i.e. j=6954 in [6751;7000], as job id is i=28)"
[1] "seed 87422 for j=205 out of 250 (i.e. j=6955 in [6751;7000], as job id is i=28)"
[1] "seed 83813 for j=206 out of 250 (i.e. j=6956 in [6751;7000], as job id is i=28)"
[1] "seed 1734 for j=207 out of 250 (i.e. j=6957 in [6751;7000], as job id is i=28)"
[1] "seed 6773 for j=208 out of 250 (i.e. j=6958 in [6751;7000], as job id is i=28)"
[1] "seed 74322 for j=209 out of 250 (i.e. j=6959 in [6751;7000], as job id is i=28)"
[1] "seed 3175 for j=210 out of 250 (i.e. j=6960 in [6751;7000], as job id is i=28)"
[1] "seed 70356 for j=211 out of 250 (i.e. j=6961 in [6751;7000], as job id is i=28)"
[1] "seed 561 for j=212 out of 250 (i.e. j=6962 in [6751;7000], as job id is i=28)"
[1] "seed 32206 for j=213 out of 250 (i.e. j=6963 in [6751;7000], as job id is i=28)"
[1] "seed 17562 for j=214 out of 250 (i.e. j=6964 in [6751;7000], as job id is i=28)"
[1] "seed 31931 for j=215 out of 250 (i.e. j=6965 in [6751;7000], as job id is i=28)"
[1] "seed 86759 for j=216 out of 250 (i.e. j=6966 in [6751;7000], as job id is i=28)"
[1] "seed 52208 for j=217 out of 250 (i.e. j=6967 in [6751;7000], as job id is i=28)"
[1] "seed 29801 for j=218 out of 250 (i.e. j=6968 in [6751;7000], as job id is i=28)"
[1] "seed 30686 for j=219 out of 250 (i.e. j=6969 in [6751;7000], as job id is i=28)"
[1] "seed 84109 for j=220 out of 250 (i.e. j=6970 in [6751;7000], as job id is i=28)"
[1] "seed 89452 for j=221 out of 250 (i.e. j=6971 in [6751;7000], as job id is i=28)"
[1] "seed 32438 for j=222 out of 250 (i.e. j=6972 in [6751;7000], as job id is i=28)"
[1] "seed 42160 for j=223 out of 250 (i.e. j=6973 in [6751;7000], as job id is i=28)"
[1] "seed 78633 for j=224 out of 250 (i.e. j=6974 in [6751;7000], as job id is i=28)"
[1] "seed 93484 for j=225 out of 250 (i.e. j=6975 in [6751;7000], as job id is i=28)"
[1] "seed 44116 for j=226 out of 250 (i.e. j=6976 in [6751;7000], as job id is i=28)"
[1] "seed 76735 for j=227 out of 250 (i.e. j=6977 in [6751;7000], as job id is i=28)"
[1] "seed 44152 for j=228 out of 250 (i.e. j=6978 in [6751;7000], as job id is i=28)"
[1] "seed 17596 for j=229 out of 250 (i.e. j=6979 in [6751;7000], as job id is i=28)"
[1] "seed 24973 for j=230 out of 250 (i.e. j=6980 in [6751;7000], as job id is i=28)"
[1] "seed 43048 for j=231 out of 250 (i.e. j=6981 in [6751;7000], as job id is i=28)"
[1] "seed 48482 for j=232 out of 250 (i.e. j=6982 in [6751;7000], as job id is i=28)"
[1] "seed 35256 for j=233 out of 250 (i.e. j=6983 in [6751;7000], as job id is i=28)"
[1] "seed 72971 for j=234 out of 250 (i.e. j=6984 in [6751;7000], as job id is i=28)"
[1] "seed 13997 for j=235 out of 250 (i.e. j=6985 in [6751;7000], as job id is i=28)"
[1] "seed 89586 for j=236 out of 250 (i.e. j=6986 in [6751;7000], as job id is i=28)"
[1] "seed 13907 for j=237 out of 250 (i.e. j=6987 in [6751;7000], as job id is i=28)"
[1] "seed 69781 for j=238 out of 250 (i.e. j=6988 in [6751;7000], as job id is i=28)"
[1] "seed 62676 for j=239 out of 250 (i.e. j=6989 in [6751;7000], as job id is i=28)"
[1] "seed 42721 for j=240 out of 250 (i.e. j=6990 in [6751;7000], as job id is i=28)"
[1] "seed 65941 for j=241 out of 250 (i.e. j=6991 in [6751;7000], as job id is i=28)"
[1] "seed 43245 for j=242 out of 250 (i.e. j=6992 in [6751;7000], as job id is i=28)"
[1] "seed 25534 for j=243 out of 250 (i.e. j=6993 in [6751;7000], as job id is i=28)"
[1] "seed 69212 for j=244 out of 250 (i.e. j=6994 in [6751;7000], as job id is i=28)"
[1] "seed 57686 for j=245 out of 250 (i.e. j=6995 in [6751;7000], as job id is i=28)"
[1] "seed 33023 for j=246 out of 250 (i.e. j=6996 in [6751;7000], as job id is i=28)"
[1] "seed 93950 for j=247 out of 250 (i.e. j=6997 in [6751;7000], as job id is i=28)"
[1] "seed 67168 for j=248 out of 250 (i.e. j=6998 in [6751;7000], as job id is i=28)"
[1] "seed 90442 for j=249 out of 250 (i.e. j=6999 in [6751;7000], as job id is i=28)"
[1] "seed 21929 for j=250 out of 250 (i.e. j=7000 in [6751;7000], as job id is i=28)"
There were 24 warnings (use warnings() to see them)
> rownames(RES) <- NULL
> save(RES,file=paste0(path.res,name,"-",iter_sim,".rda"))
> 
> ## * Summary results
> sessionInfo()
R version 4.1.2 (2021-11-01)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux 8.5 (Ootpa)

Matrix products: default
BLAS:   /opt/software/R/4.1.2/lib64/R/lib/libRblas.so
LAPACK: /opt/software/R/4.1.2/lib64/R/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] mvtnorm_1.1-3    DelayedGSD_0.0.3

loaded via a namespace (and not attached):
 [1] BB_2019.10-1     magrittr_2.0.3   tidyselect_1.1.2 munsell_0.5.0   
 [5] lattice_0.20-45  colorspace_2.0-3 xtable_1.8-4     R6_2.5.1        
 [9] quadprog_1.5-8   rlang_1.0.3      fansi_1.0.3      dplyr_1.0.9     
[13] grid_4.1.2       nlme_3.1-153     gtable_0.3.0     gsDesign_3.3.0  
[17] utf8_1.2.2       cli_3.3.0        ellipsis_0.3.2   tibble_3.1.7    
[21] lifecycle_1.0.1  crayon_1.5.1     purrr_0.3.4      ggplot2_3.3.6   
[25] tidyr_1.2.0      vctrs_0.4.1      glue_1.6.2       compiler_4.1.2  
[29] pillar_1.7.0     generics_0.1.3   scales_1.2.0     pkgconfig_2.0.3 
> summary(RES)
     method        stage           type             statistic     
 Min.   :1.0   Min.   :1.000   Length:1500        Min.   :0.0374  
 1st Qu.:1.0   1st Qu.:1.000   Class :character   1st Qu.:1.6320  
 Median :1.5   Median :1.000   Mode  :character   Median :2.4347  
 Mean   :1.5   Mean   :1.333                      Mean   :2.3373  
 3rd Qu.:2.0   3rd Qu.:2.000                      3rd Qu.:3.0358  
 Max.   :2.0   Max.   :2.000                      Max.   :6.3914  
                                                  NA's   :500     
  estimate_ML          se_ML             info           infoPC      
 Min.   :-0.4742   Min.   :0.3277   Min.   :4.252   Min.   :0.3322  
 1st Qu.: 0.5491   1st Qu.:0.3842   1st Qu.:5.811   1st Qu.:0.4541  
 Median : 0.8323   Median :0.4015   Median :6.338   Median :0.4952  
 Mean   : 0.8222   Mean   :0.4009   Mean   :6.384   Mean   :0.4988  
 3rd Qu.: 1.0809   3rd Qu.:0.4171   3rd Qu.:6.843   3rd Qu.:0.5347  
 Max.   : 2.2529   Max.   :0.4850   Max.   :9.313   Max.   :0.7277  
 NA's   :500       NA's   :1000     NA's   :176     NA's   :176     
   info.pred      infoPC.pred           uk              lk         
 Min.   :4.529   Min.   :0.3539   Min.   :2.219   Min.   :-0.3631  
 1st Qu.:6.115   1st Qu.:0.4778   1st Qu.:2.457   1st Qu.: 0.1709  
 Median :6.601   Median :0.5158   Median :2.520   Median : 0.3177  
 Mean   :6.690   Mean   :0.5227   Mean   :2.513   Mean   : 0.3384  
 3rd Qu.:7.178   3rd Qu.:0.5609   3rd Qu.:2.573   3rd Qu.: 0.4937  
 Max.   :9.787   Max.   :0.7647   Max.   :2.775   Max.   : 1.1933  
 NA's   :1000    NA's   :1000     NA's   :1000    NA's   :1000     
   decision            reason            p.value_ML        lower_ML      
 Length:1500        Length:1500        Min.   :0.0000   Min.   :-0.9485  
 Class :character   Class :character   1st Qu.:0.0015   1st Qu.:-0.0228  
 Mode  :character   Mode  :character   Median :0.0053   Median : 0.1668  
                                       Mean   :0.0612   Mean   : 0.1389  
                                       3rd Qu.:0.0304   3rd Qu.: 0.3238  
                                       Max.   :0.8850   Max.   : 1.4191  
                                       NA's   :1000     NA's   :1000     
    upper_ML       p.value_MUE       lower_MUE         upper_MUE     
 Min.   :0.6913   Min.   :0.0000   Min.   :-0.9443   Min.   :0.6865  
 1st Qu.:1.2751   1st Qu.:0.0022   1st Qu.:-0.0323   1st Qu.:1.2780  
 Median :1.5140   Median :0.0070   Median : 0.0812   Median :1.4901  
 Mean   :1.5813   Mean   :0.0444   Mean   : 0.1125   Mean   :1.5930  
 3rd Qu.:1.8796   3rd Qu.:0.0172   3rd Qu.: 0.2299   3rd Qu.:1.9303  
 Max.   :2.9676   Max.   :1.0000   Max.   : 1.7401   Max.   :3.2544  
 NA's   :1000     NA's   :1000     NA's   :1000      NA's   :1000    
  estimate_MUE           ck          time.interim        seed      
 Min.   :-0.1289   Min.   :0.0199   Min.   :508.0   Min.   :  561  
 1st Qu.: 0.6231   1st Qu.:1.4088   1st Qu.:582.0   1st Qu.:28787  
 Median : 0.8150   Median :1.4641   Median :600.5   Median :52551  
 Mean   : 0.8589   Mean   :1.4260   Mean   :600.4   Mean   :51690  
 3rd Qu.: 1.0642   3rd Qu.:1.5139   3rd Qu.:620.0   3rd Qu.:74469  
 Max.   : 2.3890   Max.   :1.7397   Max.   :669.0   Max.   :99754  
 NA's   :1000      NA's   :676                                     
  nX1.interim     nX2.interim     nX3.interim    computation.time
 Min.   :146.0   Min.   :131.0   Min.   :120.0   Min.   :0.713   
 1st Qu.:148.0   1st Qu.:135.0   1st Qu.:125.0   1st Qu.:0.909   
 Median :149.0   Median :137.0   Median :127.0   Median :0.985   
 Mean   :148.8   Mean   :136.8   Mean   :127.1   Mean   :1.012   
 3rd Qu.:150.0   3rd Qu.:138.0   3rd Qu.:129.0   3rd Qu.:1.090   
 Max.   :154.0   Max.   :144.0   Max.   :135.0   Max.   :3.763   
                                                                 
> 
> #----------------------------------------------------------------------
> ### BATCH_simuMain.R ends here
> 
> proc.time()
   user  system elapsed 
255.789   0.401 266.442 
