
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### BATCH_simuMain.R --- 
> #----------------------------------------------------------------------
> ## Author: Paul Blanche
> ## Created: Mar  5 2021 (10:56) 
> ## Version: 
> ## Last-Updated: maj  6 2022 (10:22) 
> ##           By: Brice Ozenne
> ##     Update #: 512
> #----------------------------------------------------------------------
> ## 
> ### Commentary: 
> ## 
> ### Change Log:
> #----------------------------------------------------------------------
> ## 
> ### Code:
> 
> rm(list=ls())
>                                    # {{{ parameters
> ## * parameters
> name <- "ScenarioName" # To save the results
> method <- 1:2 # methods used to compute the boundaries
>                                         #---
> myseed <- 140786598
>                                         #--- to plan the trial ----
> NMC <- 250 # number of sequential simulations to run in parallel. Eg. with 250, then we can run 40 scripts in paralell to get N=10,000 runs in total.
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.5,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.55  #(expected) information rate at each decision analysis
> binding <- TRUE
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.6,0.8) # treatment effect
> ar <- (0.86*2)*2 # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As to low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> Miss11 <- 5/104 # miss both V1 and V2
> Miss12 <- 1/104 # miss V1 and but not V2
> Miss21 <- 6/104 # do not miss V1 and but miss V2
> Miss22 <- 92/104 # miss none
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- abs(delta[3]) # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> n <- ceiling(2*2*((allsd[3]/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
> # {{{ Set seeds for parallel computing and reproducibility
> ## * Seed
> iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
> n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
> if(is.na(iter_sim)){iter_sim <- 2}
> if(is.na(n.iter_sim)){n.iter_sim <- 10}
> 
> set.seed(140786598)
> allseeds <- sample.int(n = 10*n.iter_sim*NMC, size = n.iter_sim*NMC, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> # }}}
> 
> # {{{ set path to load and save and othe machine specific variables
> ## * path
> path <- "."
> path.res <- file.path(path,"Results","simuMain")
> if(dir.exists(path.res)==FALSE){
+     if(dir.exists(file.path(path,"Results"))==FALSE){
+     dir.create(file.path(path,"Results"))
+     }
+     dir.create(path.res)
+ }
> path.output <- file.path(path,"output","simuMain")
> if(dir.exists(path.output)==FALSE){
+     if(dir.exists(file.path(path,"output"))==FALSE){
+     dir.create(file.path(path,"output"))
+     }
+     dir.create(path.output)
+ }
> # }}}
> 
> 
> ## * libraries and functions
> library(DelayedGSD)
DelayedGSD version 0.0.2
> ## sourceDir <- function(path, trace = TRUE, ...) {
> ##     for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
> ##         if(trace) cat(nm,":")
> ##         source(file.path(path, nm), ...)
> ##         if(trace) cat("\n")
> ##     }
> ## }
> ## sourceDir(pathToLoad)
>     
> 
> ## * Compute inflation factor and sample size
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+     plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                         alpha=alpha, 
+                                         beta=beta,  
+                                         InfoR.i=informationRates,  
+                                         InfoR.d=c(Id,1),  
+                                         rho_alpha=rho_alpha,  
+                                         rho_beta=rho_beta,  
+                                         method=iMeth,  
+                                         cNotBelowFixedc=FALSE,
+                                         bindingFutility=binding,
+                                         delta=tail(delta,1))
+     ## summary(plannedB[[1]])
+     ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> ##  plot(plannedB[[1]])
> 
> #
> # --- just to check---
> ## n
> ## InfoFixed <- ((qnorm(1-beta)-qnorm(alpha))/(deltaPower))^2
> ## InfoFixed
> ## n/(4*(allsd[3])^2)
> #---
> # }}}
> 
> 
> 
> 
> # {{{ technical details to loop
> RES <- NULL # initialize results to save
> allj <- ((iter_sim-1)*NMC + 1):(iter_sim*NMC) # indices of all iterations (replicates) for this job, accountng for the other jobs running in parallel
> # }}}
> 
> ## * Loop
> for(j in allj){ ## j <- 5 ## 5
+     startComp <- Sys.time()
+     myseedi <- allseeds[j]
+     # {{{ TRACE info (e.g. to check the Rout)
+     print(paste0("seed ",myseedi," for ","j=",which(j==allj)," out of ",NMC, " (i.e. j=",j," in [",(iter_sim-1)*NMC + 1,";",iter_sim*NMC,"], as job id is i=",iter_sim,")"))
+     # }}}
+     # {{{ Missing probabilities
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE) # to additionnally remove 1 more because some FASFL=N
+     colnames(MyMissProb) <- c("V2 missing","V2 not missing")
+     rownames(MyMissProb) <- c("V1 missing","V1 not missing")
+     # }}}
+ 
+                                         # {{{ generate data
+     ## ** simulate
+     res <- GenData(n=n, 
+                    N.fw=2,
+                    rand.block=block,
+                    allsd=allsd,
+                    mean0=mean0,
+                    delta=delta,
+                    ar=ar,
+                    cor.01.1=cor011,
+                    cor.ij.1=corij1,
+                    cor.0j.1=cor0j1,
+                    seed=myseedi,
+                    MissProb=MyMissProb,
+                    DigitsOutcome=2,
+                    TimeFactor=TimeFactor,
+                    DigitsTime=0
+                    )
+     d <- res$d
+     ## head(d,n=20)
+                                         # }}}
+                                         # {{{ reformat data like those of Corine
+     ## Make data long format
+     ## dd <- FormatAsCase(d)
+     ## head(dd)
+     ## summary(dd)
+                                         # }}}
+    
+                                         # {{{ make data available at interim
+                                         # Here we stop inclusion data collection for the interim analysis as soon as
+                                         # half of the participants have completed (or had the opportunity to complete) the follow-up 
+     thet <- d$t3[ceiling(n*PropForInterim)]
+     di <- SelectData(d,t=thet)
+     ## ddi <- FormatAsCase(di) # needed ????
+     ## head(d[d$id==52,])
+                                         # }}}
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thet + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     currentGSD <- vector(mode = "list", length = 3)
+     out.interim <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+ 
+         currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+ 
+         iConfint.interim <- confint(currentGSD[[iMeth]])
+         iInfo.interim <- coef(currentGSD[[iMeth]], type = "information")
+         iBoundary.interim <- coef(currentGSD[[iMeth]], type = "boundary")
+         iDecision.interim <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+         out.interim[[iMeth]] <-  data.frame(statistic = iConfint.interim[1,"statistic"],
+                                             estimate_ML = iConfint.interim[1,"estimate"],
+                                             se_ML = iConfint.interim[1,"se"],
+                                             info = iInfo.interim[1,"Interim"],
+                                             infoPC = iInfo.interim[1,"Interim.pc"],
+                                             info.pred = iInfo.interim[1,"Decision"],
+                                             infoPC.pred = iInfo.interim[1,"Decision.pc"],
+                                             uk = iBoundary.interim[1,"Ebound"],
+                                             lk = iBoundary.interim[1,"Fbound"],
+                                             decision = iDecision.interim["decision","stage 1"],
+                                             reason = iDecision.interim["reason.interim","stage 1"])
+     }
+     ## currentGSD[[1]]
+     ## plot(currentGSD[[1]])
+ 
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thet + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     out.decision <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+           
+         if(out.interim[[iMeth]]$decision == "stop"){
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+             ## plot(currentGSD[[iMeth]])
+ 
+             iConfint.decision <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.decision  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = iConfint.decision[1,"statistic"],
+                                                 p.value_ML = iConfint.decision[iConfint.decision$method == "ML","p.value"],
+                                                 lower_ML = iConfint.decision[iConfint.decision$method == "ML","lower"],
+                                                 upper_ML = iConfint.decision[iConfint.decision$method == "ML","upper"],
+                                                 estimate_ML = iConfint.decision[iConfint.decision$method == "ML","estimate"],
+                                                 p.value_MUE = iConfint.decision[iConfint.decision$method == "MUE","p.value"],
+                                                 lower_MUE = iConfint.decision[iConfint.decision$method == "MUE","lower"],
+                                                 upper_MUE = iConfint.decision[iConfint.decision$method == "MUE","upper"],
+                                                 estimate_MUE = iConfint.decision[iConfint.decision$method == "MUE","estimate"],
+                                                 info = iInfo.decision[1,"Interim"],
+                                                 infoPC = iInfo.decision[1,"Interim.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = unname(iDecision.decision["decision","stage 2"])
+                                                 )
+ 
+         }else{
+             ## update information
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+ 
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = NA,
+                                                 p.value_ML = NA,
+                                                 lower_ML = NA,
+                                                 upper_ML = NA,
+                                                 estimate_ML = NA,
+                                                 p.value_MUE = NA,
+                                                 lower_MUE = NA,
+                                                 upper_MUE = NA,
+                                                 estimate_MUE = NA,
+                                                 info = iInfo.decision[1,"Decision"],
+                                                 infoPC = iInfo.decision[1,"Decision.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = NA)
+         }
+     }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+ 
+     ## ** finale
+     dFinal <- d
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     out.final <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+         if(out.interim[[iMeth]]$decision == "stop"){
+             out.final[[iMeth]] <- data.frame(statistic = NA,
+                                              p.value_ML = NA,
+                                              lower_ML = NA,
+                                              upper_ML = NA,
+                                              estimate_ML = NA,
+                                              p.value_MUE = NA,
+                                              lower_MUE = NA,
+                                              upper_MUE = NA,
+                                              estimate_MUE = NA,
+                                              info = NA,
+                                              infoPC = NA,
+                                              ck = NA,
+                                              decision = NA)
+ 
+         }else{
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+ 
+             ## plot(test)
+             ## summary(test)
+             iConfint.final <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.final <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.final <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.final  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.final[[iMeth]] <- data.frame(statistic = iConfint.final[1,"statistic"],
+                                              p.value_ML = iConfint.final[iConfint.final$method == "ML","p.value"],
+                                              lower_ML = iConfint.final[iConfint.final$method == "ML","lower"],
+                                              upper_ML = iConfint.final[iConfint.final$method == "ML","upper"],
+                                              estimate_ML = iConfint.final[iConfint.final$method == "ML","estimate"],
+                                              p.value_MUE = iConfint.final[iConfint.final$method == "MUE","p.value"],
+                                              lower_MUE = iConfint.final[iConfint.final$method == "MUE","lower"],
+                                              upper_MUE = iConfint.final[iConfint.final$method == "MUE","upper"],
+                                              estimate_MUE = iConfint.final[iConfint.final$method == "MUE","estimate"],
+                                              info = iInfo.final[1,"Interim"],
+                                              infoPC = iInfo.final[1,"Interim.pc"],
+                                              ck = iBoundary.final[1,"Cbound"],
+                                              decision = unname(coef(currentGSD[[iMeth]], type = "decision")["decision","stage 2"])
+                                              )
+         }
+     }
+                                         # }}}
+ 
+     stopComp <- Sys.time()
+                                         # {{{ Save results
+ 
+     outMerge <- do.call(rbind,lapply(method, function(iMeth){
+         iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+         iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+         iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+         iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+         iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+         return(iMerge)
+     }))
+ 
+     ## outMerge[outMerge$method==3,]
+ 
+     out <- cbind(
+         ## results
+         outMerge,
+         ## simulation details
+         time.interim = thet,
+         seed=myseedi,             
+         nX1.interim = sum(!is.na(di$X1)),
+         nX2.interim = sum(!is.na(di$X2)),
+         nX3.interim = sum(!is.na(di$X3)),
+         ## computation time
+         computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+     )
+     ## names(out) <- myColNames
+     RES <- rbind(RES,out)
+     save(RES,file=paste0(path.res,name,"(tempo)-",iter_sim,".rda"))
+                                         # }}}
+ }
[1] "seed 66872 for j=1 out of 250 (i.e. j=6001 in [6001;6250], as job id is i=25)"
Loading required namespace: nlme
[1] "seed 50553 for j=2 out of 250 (i.e. j=6002 in [6001;6250], as job id is i=25)"
[1] "seed 37717 for j=3 out of 250 (i.e. j=6003 in [6001;6250], as job id is i=25)"
[1] "seed 26885 for j=4 out of 250 (i.e. j=6004 in [6001;6250], as job id is i=25)"
[1] "seed 39528 for j=5 out of 250 (i.e. j=6005 in [6001;6250], as job id is i=25)"
[1] "seed 52101 for j=6 out of 250 (i.e. j=6006 in [6001;6250], as job id is i=25)"
[1] "seed 68571 for j=7 out of 250 (i.e. j=6007 in [6001;6250], as job id is i=25)"
[1] "seed 55855 for j=8 out of 250 (i.e. j=6008 in [6001;6250], as job id is i=25)"
[1] "seed 44026 for j=9 out of 250 (i.e. j=6009 in [6001;6250], as job id is i=25)"
[1] "seed 18539 for j=10 out of 250 (i.e. j=6010 in [6001;6250], as job id is i=25)"
[1] "seed 41795 for j=11 out of 250 (i.e. j=6011 in [6001;6250], as job id is i=25)"
[1] "seed 4269 for j=12 out of 250 (i.e. j=6012 in [6001;6250], as job id is i=25)"
[1] "seed 98638 for j=13 out of 250 (i.e. j=6013 in [6001;6250], as job id is i=25)"
[1] "seed 75356 for j=14 out of 250 (i.e. j=6014 in [6001;6250], as job id is i=25)"
[1] "seed 52600 for j=15 out of 250 (i.e. j=6015 in [6001;6250], as job id is i=25)"
[1] "seed 10825 for j=16 out of 250 (i.e. j=6016 in [6001;6250], as job id is i=25)"
[1] "seed 20538 for j=17 out of 250 (i.e. j=6017 in [6001;6250], as job id is i=25)"
[1] "seed 46509 for j=18 out of 250 (i.e. j=6018 in [6001;6250], as job id is i=25)"
[1] "seed 85157 for j=19 out of 250 (i.e. j=6019 in [6001;6250], as job id is i=25)"
[1] "seed 29183 for j=20 out of 250 (i.e. j=6020 in [6001;6250], as job id is i=25)"
[1] "seed 32493 for j=21 out of 250 (i.e. j=6021 in [6001;6250], as job id is i=25)"
[1] "seed 8577 for j=22 out of 250 (i.e. j=6022 in [6001;6250], as job id is i=25)"
[1] "seed 57654 for j=23 out of 250 (i.e. j=6023 in [6001;6250], as job id is i=25)"
[1] "seed 16440 for j=24 out of 250 (i.e. j=6024 in [6001;6250], as job id is i=25)"
[1] "seed 9344 for j=25 out of 250 (i.e. j=6025 in [6001;6250], as job id is i=25)"
[1] "seed 46061 for j=26 out of 250 (i.e. j=6026 in [6001;6250], as job id is i=25)"
[1] "seed 12406 for j=27 out of 250 (i.e. j=6027 in [6001;6250], as job id is i=25)"
[1] "seed 25045 for j=28 out of 250 (i.e. j=6028 in [6001;6250], as job id is i=25)"
[1] "seed 52021 for j=29 out of 250 (i.e. j=6029 in [6001;6250], as job id is i=25)"
[1] "seed 41630 for j=30 out of 250 (i.e. j=6030 in [6001;6250], as job id is i=25)"
[1] "seed 89730 for j=31 out of 250 (i.e. j=6031 in [6001;6250], as job id is i=25)"
[1] "seed 10501 for j=32 out of 250 (i.e. j=6032 in [6001;6250], as job id is i=25)"
[1] "seed 24389 for j=33 out of 250 (i.e. j=6033 in [6001;6250], as job id is i=25)"
[1] "seed 91375 for j=34 out of 250 (i.e. j=6034 in [6001;6250], as job id is i=25)"
[1] "seed 94061 for j=35 out of 250 (i.e. j=6035 in [6001;6250], as job id is i=25)"
[1] "seed 36968 for j=36 out of 250 (i.e. j=6036 in [6001;6250], as job id is i=25)"
[1] "seed 68471 for j=37 out of 250 (i.e. j=6037 in [6001;6250], as job id is i=25)"
[1] "seed 51233 for j=38 out of 250 (i.e. j=6038 in [6001;6250], as job id is i=25)"
[1] "seed 75219 for j=39 out of 250 (i.e. j=6039 in [6001;6250], as job id is i=25)"
[1] "seed 52968 for j=40 out of 250 (i.e. j=6040 in [6001;6250], as job id is i=25)"
[1] "seed 70456 for j=41 out of 250 (i.e. j=6041 in [6001;6250], as job id is i=25)"
[1] "seed 6544 for j=42 out of 250 (i.e. j=6042 in [6001;6250], as job id is i=25)"
[1] "seed 99879 for j=43 out of 250 (i.e. j=6043 in [6001;6250], as job id is i=25)"
[1] "seed 35161 for j=44 out of 250 (i.e. j=6044 in [6001;6250], as job id is i=25)"
[1] "seed 76738 for j=45 out of 250 (i.e. j=6045 in [6001;6250], as job id is i=25)"
[1] "seed 657 for j=46 out of 250 (i.e. j=6046 in [6001;6250], as job id is i=25)"
[1] "seed 66076 for j=47 out of 250 (i.e. j=6047 in [6001;6250], as job id is i=25)"
[1] "seed 1504 for j=48 out of 250 (i.e. j=6048 in [6001;6250], as job id is i=25)"
[1] "seed 737 for j=49 out of 250 (i.e. j=6049 in [6001;6250], as job id is i=25)"
[1] "seed 75460 for j=50 out of 250 (i.e. j=6050 in [6001;6250], as job id is i=25)"
[1] "seed 26344 for j=51 out of 250 (i.e. j=6051 in [6001;6250], as job id is i=25)"
[1] "seed 90057 for j=52 out of 250 (i.e. j=6052 in [6001;6250], as job id is i=25)"
[1] "seed 79958 for j=53 out of 250 (i.e. j=6053 in [6001;6250], as job id is i=25)"
[1] "seed 35667 for j=54 out of 250 (i.e. j=6054 in [6001;6250], as job id is i=25)"
[1] "seed 13519 for j=55 out of 250 (i.e. j=6055 in [6001;6250], as job id is i=25)"
[1] "seed 78603 for j=56 out of 250 (i.e. j=6056 in [6001;6250], as job id is i=25)"
[1] "seed 80792 for j=57 out of 250 (i.e. j=6057 in [6001;6250], as job id is i=25)"
[1] "seed 56627 for j=58 out of 250 (i.e. j=6058 in [6001;6250], as job id is i=25)"
[1] "seed 89471 for j=59 out of 250 (i.e. j=6059 in [6001;6250], as job id is i=25)"
[1] "seed 93209 for j=60 out of 250 (i.e. j=6060 in [6001;6250], as job id is i=25)"
[1] "seed 39670 for j=61 out of 250 (i.e. j=6061 in [6001;6250], as job id is i=25)"
[1] "seed 44555 for j=62 out of 250 (i.e. j=6062 in [6001;6250], as job id is i=25)"
[1] "seed 51098 for j=63 out of 250 (i.e. j=6063 in [6001;6250], as job id is i=25)"
[1] "seed 69551 for j=64 out of 250 (i.e. j=6064 in [6001;6250], as job id is i=25)"
[1] "seed 22856 for j=65 out of 250 (i.e. j=6065 in [6001;6250], as job id is i=25)"
[1] "seed 70531 for j=66 out of 250 (i.e. j=6066 in [6001;6250], as job id is i=25)"
[1] "seed 59134 for j=67 out of 250 (i.e. j=6067 in [6001;6250], as job id is i=25)"
[1] "seed 27108 for j=68 out of 250 (i.e. j=6068 in [6001;6250], as job id is i=25)"
[1] "seed 77294 for j=69 out of 250 (i.e. j=6069 in [6001;6250], as job id is i=25)"
[1] "seed 67285 for j=70 out of 250 (i.e. j=6070 in [6001;6250], as job id is i=25)"
[1] "seed 90409 for j=71 out of 250 (i.e. j=6071 in [6001;6250], as job id is i=25)"
[1] "seed 68647 for j=72 out of 250 (i.e. j=6072 in [6001;6250], as job id is i=25)"
[1] "seed 22572 for j=73 out of 250 (i.e. j=6073 in [6001;6250], as job id is i=25)"
[1] "seed 12538 for j=74 out of 250 (i.e. j=6074 in [6001;6250], as job id is i=25)"
[1] "seed 30259 for j=75 out of 250 (i.e. j=6075 in [6001;6250], as job id is i=25)"
[1] "seed 15176 for j=76 out of 250 (i.e. j=6076 in [6001;6250], as job id is i=25)"
[1] "seed 80520 for j=77 out of 250 (i.e. j=6077 in [6001;6250], as job id is i=25)"
[1] "seed 91289 for j=78 out of 250 (i.e. j=6078 in [6001;6250], as job id is i=25)"
[1] "seed 6661 for j=79 out of 250 (i.e. j=6079 in [6001;6250], as job id is i=25)"
[1] "seed 35049 for j=80 out of 250 (i.e. j=6080 in [6001;6250], as job id is i=25)"
[1] "seed 67904 for j=81 out of 250 (i.e. j=6081 in [6001;6250], as job id is i=25)"
[1] "seed 8799 for j=82 out of 250 (i.e. j=6082 in [6001;6250], as job id is i=25)"
[1] "seed 3421 for j=83 out of 250 (i.e. j=6083 in [6001;6250], as job id is i=25)"
[1] "seed 38702 for j=84 out of 250 (i.e. j=6084 in [6001;6250], as job id is i=25)"
[1] "seed 46632 for j=85 out of 250 (i.e. j=6085 in [6001;6250], as job id is i=25)"
[1] "seed 65143 for j=86 out of 250 (i.e. j=6086 in [6001;6250], as job id is i=25)"
[1] "seed 97385 for j=87 out of 250 (i.e. j=6087 in [6001;6250], as job id is i=25)"
[1] "seed 2017 for j=88 out of 250 (i.e. j=6088 in [6001;6250], as job id is i=25)"
[1] "seed 22715 for j=89 out of 250 (i.e. j=6089 in [6001;6250], as job id is i=25)"
[1] "seed 10448 for j=90 out of 250 (i.e. j=6090 in [6001;6250], as job id is i=25)"
[1] "seed 5378 for j=91 out of 250 (i.e. j=6091 in [6001;6250], as job id is i=25)"
[1] "seed 14631 for j=92 out of 250 (i.e. j=6092 in [6001;6250], as job id is i=25)"
[1] "seed 31436 for j=93 out of 250 (i.e. j=6093 in [6001;6250], as job id is i=25)"
[1] "seed 78210 for j=94 out of 250 (i.e. j=6094 in [6001;6250], as job id is i=25)"
[1] "seed 97461 for j=95 out of 250 (i.e. j=6095 in [6001;6250], as job id is i=25)"
[1] "seed 34477 for j=96 out of 250 (i.e. j=6096 in [6001;6250], as job id is i=25)"
[1] "seed 99086 for j=97 out of 250 (i.e. j=6097 in [6001;6250], as job id is i=25)"
[1] "seed 43975 for j=98 out of 250 (i.e. j=6098 in [6001;6250], as job id is i=25)"
[1] "seed 66431 for j=99 out of 250 (i.e. j=6099 in [6001;6250], as job id is i=25)"
[1] "seed 1295 for j=100 out of 250 (i.e. j=6100 in [6001;6250], as job id is i=25)"
[1] "seed 32200 for j=101 out of 250 (i.e. j=6101 in [6001;6250], as job id is i=25)"
[1] "seed 78403 for j=102 out of 250 (i.e. j=6102 in [6001;6250], as job id is i=25)"
[1] "seed 60727 for j=103 out of 250 (i.e. j=6103 in [6001;6250], as job id is i=25)"
[1] "seed 38399 for j=104 out of 250 (i.e. j=6104 in [6001;6250], as job id is i=25)"
[1] "seed 3051 for j=105 out of 250 (i.e. j=6105 in [6001;6250], as job id is i=25)"
[1] "seed 63833 for j=106 out of 250 (i.e. j=6106 in [6001;6250], as job id is i=25)"
[1] "seed 68728 for j=107 out of 250 (i.e. j=6107 in [6001;6250], as job id is i=25)"
[1] "seed 69194 for j=108 out of 250 (i.e. j=6108 in [6001;6250], as job id is i=25)"
[1] "seed 91992 for j=109 out of 250 (i.e. j=6109 in [6001;6250], as job id is i=25)"
[1] "seed 28402 for j=110 out of 250 (i.e. j=6110 in [6001;6250], as job id is i=25)"
[1] "seed 29869 for j=111 out of 250 (i.e. j=6111 in [6001;6250], as job id is i=25)"
[1] "seed 79419 for j=112 out of 250 (i.e. j=6112 in [6001;6250], as job id is i=25)"
[1] "seed 96510 for j=113 out of 250 (i.e. j=6113 in [6001;6250], as job id is i=25)"
[1] "seed 79669 for j=114 out of 250 (i.e. j=6114 in [6001;6250], as job id is i=25)"
[1] "seed 96649 for j=115 out of 250 (i.e. j=6115 in [6001;6250], as job id is i=25)"
[1] "seed 14206 for j=116 out of 250 (i.e. j=6116 in [6001;6250], as job id is i=25)"
[1] "seed 69476 for j=117 out of 250 (i.e. j=6117 in [6001;6250], as job id is i=25)"
[1] "seed 41406 for j=118 out of 250 (i.e. j=6118 in [6001;6250], as job id is i=25)"
[1] "seed 99688 for j=119 out of 250 (i.e. j=6119 in [6001;6250], as job id is i=25)"
[1] "seed 57534 for j=120 out of 250 (i.e. j=6120 in [6001;6250], as job id is i=25)"
[1] "seed 99248 for j=121 out of 250 (i.e. j=6121 in [6001;6250], as job id is i=25)"
[1] "seed 26262 for j=122 out of 250 (i.e. j=6122 in [6001;6250], as job id is i=25)"
[1] "seed 3889 for j=123 out of 250 (i.e. j=6123 in [6001;6250], as job id is i=25)"
[1] "seed 47496 for j=124 out of 250 (i.e. j=6124 in [6001;6250], as job id is i=25)"
[1] "seed 48570 for j=125 out of 250 (i.e. j=6125 in [6001;6250], as job id is i=25)"
[1] "seed 10303 for j=126 out of 250 (i.e. j=6126 in [6001;6250], as job id is i=25)"
[1] "seed 67149 for j=127 out of 250 (i.e. j=6127 in [6001;6250], as job id is i=25)"
[1] "seed 61865 for j=128 out of 250 (i.e. j=6128 in [6001;6250], as job id is i=25)"
[1] "seed 51388 for j=129 out of 250 (i.e. j=6129 in [6001;6250], as job id is i=25)"
[1] "seed 11107 for j=130 out of 250 (i.e. j=6130 in [6001;6250], as job id is i=25)"
[1] "seed 8189 for j=131 out of 250 (i.e. j=6131 in [6001;6250], as job id is i=25)"
[1] "seed 22307 for j=132 out of 250 (i.e. j=6132 in [6001;6250], as job id is i=25)"
[1] "seed 44891 for j=133 out of 250 (i.e. j=6133 in [6001;6250], as job id is i=25)"
[1] "seed 38724 for j=134 out of 250 (i.e. j=6134 in [6001;6250], as job id is i=25)"
[1] "seed 34399 for j=135 out of 250 (i.e. j=6135 in [6001;6250], as job id is i=25)"
[1] "seed 31419 for j=136 out of 250 (i.e. j=6136 in [6001;6250], as job id is i=25)"
[1] "seed 50232 for j=137 out of 250 (i.e. j=6137 in [6001;6250], as job id is i=25)"
[1] "seed 92251 for j=138 out of 250 (i.e. j=6138 in [6001;6250], as job id is i=25)"
[1] "seed 22036 for j=139 out of 250 (i.e. j=6139 in [6001;6250], as job id is i=25)"
[1] "seed 40462 for j=140 out of 250 (i.e. j=6140 in [6001;6250], as job id is i=25)"
[1] "seed 55758 for j=141 out of 250 (i.e. j=6141 in [6001;6250], as job id is i=25)"
[1] "seed 96270 for j=142 out of 250 (i.e. j=6142 in [6001;6250], as job id is i=25)"
[1] "seed 25755 for j=143 out of 250 (i.e. j=6143 in [6001;6250], as job id is i=25)"
[1] "seed 45643 for j=144 out of 250 (i.e. j=6144 in [6001;6250], as job id is i=25)"
[1] "seed 91876 for j=145 out of 250 (i.e. j=6145 in [6001;6250], as job id is i=25)"
[1] "seed 22505 for j=146 out of 250 (i.e. j=6146 in [6001;6250], as job id is i=25)"
[1] "seed 95221 for j=147 out of 250 (i.e. j=6147 in [6001;6250], as job id is i=25)"
[1] "seed 71030 for j=148 out of 250 (i.e. j=6148 in [6001;6250], as job id is i=25)"
[1] "seed 82989 for j=149 out of 250 (i.e. j=6149 in [6001;6250], as job id is i=25)"
[1] "seed 87360 for j=150 out of 250 (i.e. j=6150 in [6001;6250], as job id is i=25)"
[1] "seed 71317 for j=151 out of 250 (i.e. j=6151 in [6001;6250], as job id is i=25)"
[1] "seed 56347 for j=152 out of 250 (i.e. j=6152 in [6001;6250], as job id is i=25)"
[1] "seed 95818 for j=153 out of 250 (i.e. j=6153 in [6001;6250], as job id is i=25)"
[1] "seed 47945 for j=154 out of 250 (i.e. j=6154 in [6001;6250], as job id is i=25)"
[1] "seed 27665 for j=155 out of 250 (i.e. j=6155 in [6001;6250], as job id is i=25)"
[1] "seed 12260 for j=156 out of 250 (i.e. j=6156 in [6001;6250], as job id is i=25)"
[1] "seed 39794 for j=157 out of 250 (i.e. j=6157 in [6001;6250], as job id is i=25)"
[1] "seed 85488 for j=158 out of 250 (i.e. j=6158 in [6001;6250], as job id is i=25)"
Error in uniroot(function(x) { : 
  f() values at end points not of opposite sign
Calls: update ... update.delayedGSD -> updateBoundaries -> updateMethod1 -> uniroot
In addition: There were 12 warnings (use warnings() to see them)
Execution halted
