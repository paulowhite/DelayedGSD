
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### BATCH_simuMain.R --- 
> #----------------------------------------------------------------------
> ## Author: Paul Blanche
> ## Created: Mar  5 2021 (10:56) 
> ## Version: 
> ## Last-Updated: maj  6 2022 (10:22) 
> ##           By: Brice Ozenne
> ##     Update #: 512
> #----------------------------------------------------------------------
> ## 
> ### Commentary: 
> ## 
> ### Change Log:
> #----------------------------------------------------------------------
> ## 
> ### Code:
> 
> rm(list=ls())
>                                    # {{{ parameters
> ## * parameters
> name <- "ScenarioName" # To save the results
> method <- 1:2 # methods used to compute the boundaries
>                                         #---
> myseed <- 140786598
>                                         #--- to plan the trial ----
> NMC <- 250 # number of sequential simulations to run in parallel. Eg. with 250, then we can run 40 scripts in paralell to get N=10,000 runs in total.
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.5,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.55  #(expected) information rate at each decision analysis
> binding <- TRUE
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.6,0.8) # treatment effect
> ar <- (0.86*2)*2 # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As to low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> Miss11 <- 5/104 # miss both V1 and V2
> Miss12 <- 1/104 # miss V1 and but not V2
> Miss21 <- 6/104 # do not miss V1 and but miss V2
> Miss22 <- 92/104 # miss none
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- abs(delta[3]) # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> n <- ceiling(2*2*((allsd[3]/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
> # {{{ Set seeds for parallel computing and reproducibility
> ## * Seed
> iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
> n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
> if(is.na(iter_sim)){iter_sim <- 2}
> if(is.na(n.iter_sim)){n.iter_sim <- 10}
> 
> set.seed(140786598)
> allseeds <- sample.int(n = 10*n.iter_sim*NMC, size = n.iter_sim*NMC, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> # }}}
> 
> # {{{ set path to load and save and othe machine specific variables
> ## * path
> path <- "."
> path.res <- file.path(path,"Results","simuMain")
> if(dir.exists(path.res)==FALSE){
+     if(dir.exists(file.path(path,"Results"))==FALSE){
+     dir.create(file.path(path,"Results"))
+     }
+     dir.create(path.res)
+ }
> path.output <- file.path(path,"output","simuMain")
> if(dir.exists(path.output)==FALSE){
+     if(dir.exists(file.path(path,"output"))==FALSE){
+     dir.create(file.path(path,"output"))
+     }
+     dir.create(path.output)
+ }
> # }}}
> 
> 
> ## * libraries and functions
> library(DelayedGSD)
DelayedGSD version 0.0.2
> ## sourceDir <- function(path, trace = TRUE, ...) {
> ##     for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
> ##         if(trace) cat(nm,":")
> ##         source(file.path(path, nm), ...)
> ##         if(trace) cat("\n")
> ##     }
> ## }
> ## sourceDir(pathToLoad)
>     
> 
> ## * Compute inflation factor and sample size
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+     plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                         alpha=alpha, 
+                                         beta=beta,  
+                                         InfoR.i=informationRates,  
+                                         InfoR.d=c(Id,1),  
+                                         rho_alpha=rho_alpha,  
+                                         rho_beta=rho_beta,  
+                                         method=iMeth,  
+                                         cNotBelowFixedc=FALSE,
+                                         bindingFutility=binding,
+                                         delta=tail(delta,1))
+     ## summary(plannedB[[1]])
+     ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> ##  plot(plannedB[[1]])
> 
> #
> # --- just to check---
> ## n
> ## InfoFixed <- ((qnorm(1-beta)-qnorm(alpha))/(deltaPower))^2
> ## InfoFixed
> ## n/(4*(allsd[3])^2)
> #---
> # }}}
> 
> 
> 
> 
> # {{{ technical details to loop
> RES <- NULL # initialize results to save
> allj <- ((iter_sim-1)*NMC + 1):(iter_sim*NMC) # indices of all iterations (replicates) for this job, accountng for the other jobs running in parallel
> # }}}
> 
> ## * Loop
> for(j in allj){ ## j <- 5 ## 5
+     startComp <- Sys.time()
+     myseedi <- allseeds[j]
+     # {{{ TRACE info (e.g. to check the Rout)
+     print(paste0("seed ",myseedi," for ","j=",which(j==allj)," out of ",NMC, " (i.e. j=",j," in [",(iter_sim-1)*NMC + 1,";",iter_sim*NMC,"], as job id is i=",iter_sim,")"))
+     # }}}
+     # {{{ Missing probabilities
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE) # to additionnally remove 1 more because some FASFL=N
+     colnames(MyMissProb) <- c("V2 missing","V2 not missing")
+     rownames(MyMissProb) <- c("V1 missing","V1 not missing")
+     # }}}
+ 
+                                         # {{{ generate data
+     ## ** simulate
+     res <- GenData(n=n, 
+                    N.fw=2,
+                    rand.block=block,
+                    allsd=allsd,
+                    mean0=mean0,
+                    delta=delta,
+                    ar=ar,
+                    cor.01.1=cor011,
+                    cor.ij.1=corij1,
+                    cor.0j.1=cor0j1,
+                    seed=myseedi,
+                    MissProb=MyMissProb,
+                    DigitsOutcome=2,
+                    TimeFactor=TimeFactor,
+                    DigitsTime=0
+                    )
+     d <- res$d
+     ## head(d,n=20)
+                                         # }}}
+                                         # {{{ reformat data like those of Corine
+     ## Make data long format
+     ## dd <- FormatAsCase(d)
+     ## head(dd)
+     ## summary(dd)
+                                         # }}}
+    
+                                         # {{{ make data available at interim
+                                         # Here we stop inclusion data collection for the interim analysis as soon as
+                                         # half of the participants have completed (or had the opportunity to complete) the follow-up 
+     thet <- d$t3[ceiling(n*PropForInterim)]
+     di <- SelectData(d,t=thet)
+     ## ddi <- FormatAsCase(di) # needed ????
+     ## head(d[d$id==52,])
+                                         # }}}
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thet + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     currentGSD <- vector(mode = "list", length = 3)
+     out.interim <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+ 
+         currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+ 
+         iConfint.interim <- confint(currentGSD[[iMeth]])
+         iInfo.interim <- coef(currentGSD[[iMeth]], type = "information")
+         iBoundary.interim <- coef(currentGSD[[iMeth]], type = "boundary")
+         iDecision.interim <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+         out.interim[[iMeth]] <-  data.frame(statistic = iConfint.interim[1,"statistic"],
+                                             estimate_ML = iConfint.interim[1,"estimate"],
+                                             se_ML = iConfint.interim[1,"se"],
+                                             info = iInfo.interim[1,"Interim"],
+                                             infoPC = iInfo.interim[1,"Interim.pc"],
+                                             info.pred = iInfo.interim[1,"Decision"],
+                                             infoPC.pred = iInfo.interim[1,"Decision.pc"],
+                                             uk = iBoundary.interim[1,"Ebound"],
+                                             lk = iBoundary.interim[1,"Fbound"],
+                                             decision = iDecision.interim["decision","stage 1"],
+                                             reason = iDecision.interim["reason.interim","stage 1"])
+     }
+     ## currentGSD[[1]]
+     ## plot(currentGSD[[1]])
+ 
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thet + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     out.decision <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+           
+         if(out.interim[[iMeth]]$decision == "stop"){
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+             ## plot(currentGSD[[iMeth]])
+ 
+             iConfint.decision <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.decision  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = iConfint.decision[1,"statistic"],
+                                                 p.value_ML = iConfint.decision[iConfint.decision$method == "ML","p.value"],
+                                                 lower_ML = iConfint.decision[iConfint.decision$method == "ML","lower"],
+                                                 upper_ML = iConfint.decision[iConfint.decision$method == "ML","upper"],
+                                                 estimate_ML = iConfint.decision[iConfint.decision$method == "ML","estimate"],
+                                                 p.value_MUE = iConfint.decision[iConfint.decision$method == "MUE","p.value"],
+                                                 lower_MUE = iConfint.decision[iConfint.decision$method == "MUE","lower"],
+                                                 upper_MUE = iConfint.decision[iConfint.decision$method == "MUE","upper"],
+                                                 estimate_MUE = iConfint.decision[iConfint.decision$method == "MUE","estimate"],
+                                                 info = iInfo.decision[1,"Interim"],
+                                                 infoPC = iInfo.decision[1,"Interim.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = unname(iDecision.decision["decision","stage 2"])
+                                                 )
+ 
+         }else{
+             ## update information
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+ 
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = NA,
+                                                 p.value_ML = NA,
+                                                 lower_ML = NA,
+                                                 upper_ML = NA,
+                                                 estimate_ML = NA,
+                                                 p.value_MUE = NA,
+                                                 lower_MUE = NA,
+                                                 upper_MUE = NA,
+                                                 estimate_MUE = NA,
+                                                 info = iInfo.decision[1,"Decision"],
+                                                 infoPC = iInfo.decision[1,"Decision.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = NA)
+         }
+     }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+ 
+     ## ** finale
+     dFinal <- d
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     out.final <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+         if(out.interim[[iMeth]]$decision == "stop"){
+             out.final[[iMeth]] <- data.frame(statistic = NA,
+                                              p.value_ML = NA,
+                                              lower_ML = NA,
+                                              upper_ML = NA,
+                                              estimate_ML = NA,
+                                              p.value_MUE = NA,
+                                              lower_MUE = NA,
+                                              upper_MUE = NA,
+                                              estimate_MUE = NA,
+                                              info = NA,
+                                              infoPC = NA,
+                                              ck = NA,
+                                              decision = NA)
+ 
+         }else{
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+ 
+             ## plot(test)
+             ## summary(test)
+             iConfint.final <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.final <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.final <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.final  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.final[[iMeth]] <- data.frame(statistic = iConfint.final[1,"statistic"],
+                                              p.value_ML = iConfint.final[iConfint.final$method == "ML","p.value"],
+                                              lower_ML = iConfint.final[iConfint.final$method == "ML","lower"],
+                                              upper_ML = iConfint.final[iConfint.final$method == "ML","upper"],
+                                              estimate_ML = iConfint.final[iConfint.final$method == "ML","estimate"],
+                                              p.value_MUE = iConfint.final[iConfint.final$method == "MUE","p.value"],
+                                              lower_MUE = iConfint.final[iConfint.final$method == "MUE","lower"],
+                                              upper_MUE = iConfint.final[iConfint.final$method == "MUE","upper"],
+                                              estimate_MUE = iConfint.final[iConfint.final$method == "MUE","estimate"],
+                                              info = iInfo.final[1,"Interim"],
+                                              infoPC = iInfo.final[1,"Interim.pc"],
+                                              ck = iBoundary.final[1,"Cbound"],
+                                              decision = unname(coef(currentGSD[[iMeth]], type = "decision")["decision","stage 2"])
+                                              )
+         }
+     }
+                                         # }}}
+ 
+     stopComp <- Sys.time()
+                                         # {{{ Save results
+ 
+     outMerge <- do.call(rbind,lapply(method, function(iMeth){
+         iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+         iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+         iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+         iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+         iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+         return(iMerge)
+     }))
+ 
+     ## outMerge[outMerge$method==3,]
+ 
+     out <- cbind(
+         ## results
+         outMerge,
+         ## simulation details
+         time.interim = thet,
+         seed=myseedi,             
+         nX1.interim = sum(!is.na(di$X1)),
+         nX2.interim = sum(!is.na(di$X2)),
+         nX3.interim = sum(!is.na(di$X3)),
+         ## computation time
+         computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+     )
+     ## names(out) <- myColNames
+     RES <- rbind(RES,out)
+     save(RES,file=paste0(path.res,name,"(tempo)-",iter_sim,".rda"))
+                                         # }}}
+ }
[1] "seed 55029 for j=1 out of 250 (i.e. j=7751 in [7751;8000], as job id is i=32)"
Loading required namespace: nlme
[1] "seed 82444 for j=2 out of 250 (i.e. j=7752 in [7751;8000], as job id is i=32)"
[1] "seed 59158 for j=3 out of 250 (i.e. j=7753 in [7751;8000], as job id is i=32)"
[1] "seed 43189 for j=4 out of 250 (i.e. j=7754 in [7751;8000], as job id is i=32)"
[1] "seed 31912 for j=5 out of 250 (i.e. j=7755 in [7751;8000], as job id is i=32)"
[1] "seed 77402 for j=6 out of 250 (i.e. j=7756 in [7751;8000], as job id is i=32)"
[1] "seed 95921 for j=7 out of 250 (i.e. j=7757 in [7751;8000], as job id is i=32)"
[1] "seed 87652 for j=8 out of 250 (i.e. j=7758 in [7751;8000], as job id is i=32)"
[1] "seed 42140 for j=9 out of 250 (i.e. j=7759 in [7751;8000], as job id is i=32)"
[1] "seed 99381 for j=10 out of 250 (i.e. j=7760 in [7751;8000], as job id is i=32)"
[1] "seed 21669 for j=11 out of 250 (i.e. j=7761 in [7751;8000], as job id is i=32)"
[1] "seed 28025 for j=12 out of 250 (i.e. j=7762 in [7751;8000], as job id is i=32)"
[1] "seed 32477 for j=13 out of 250 (i.e. j=7763 in [7751;8000], as job id is i=32)"
[1] "seed 26132 for j=14 out of 250 (i.e. j=7764 in [7751;8000], as job id is i=32)"
[1] "seed 85883 for j=15 out of 250 (i.e. j=7765 in [7751;8000], as job id is i=32)"
[1] "seed 1671 for j=16 out of 250 (i.e. j=7766 in [7751;8000], as job id is i=32)"
[1] "seed 2995 for j=17 out of 250 (i.e. j=7767 in [7751;8000], as job id is i=32)"
[1] "seed 64078 for j=18 out of 250 (i.e. j=7768 in [7751;8000], as job id is i=32)"
[1] "seed 94448 for j=19 out of 250 (i.e. j=7769 in [7751;8000], as job id is i=32)"
[1] "seed 41109 for j=20 out of 250 (i.e. j=7770 in [7751;8000], as job id is i=32)"
[1] "seed 86847 for j=21 out of 250 (i.e. j=7771 in [7751;8000], as job id is i=32)"
[1] "seed 55881 for j=22 out of 250 (i.e. j=7772 in [7751;8000], as job id is i=32)"
[1] "seed 98677 for j=23 out of 250 (i.e. j=7773 in [7751;8000], as job id is i=32)"
[1] "seed 68852 for j=24 out of 250 (i.e. j=7774 in [7751;8000], as job id is i=32)"
[1] "seed 61408 for j=25 out of 250 (i.e. j=7775 in [7751;8000], as job id is i=32)"
[1] "seed 91409 for j=26 out of 250 (i.e. j=7776 in [7751;8000], as job id is i=32)"
[1] "seed 11242 for j=27 out of 250 (i.e. j=7777 in [7751;8000], as job id is i=32)"
[1] "seed 16256 for j=28 out of 250 (i.e. j=7778 in [7751;8000], as job id is i=32)"
[1] "seed 30934 for j=29 out of 250 (i.e. j=7779 in [7751;8000], as job id is i=32)"
[1] "seed 52150 for j=30 out of 250 (i.e. j=7780 in [7751;8000], as job id is i=32)"
[1] "seed 12836 for j=31 out of 250 (i.e. j=7781 in [7751;8000], as job id is i=32)"
[1] "seed 20228 for j=32 out of 250 (i.e. j=7782 in [7751;8000], as job id is i=32)"
[1] "seed 86725 for j=33 out of 250 (i.e. j=7783 in [7751;8000], as job id is i=32)"
[1] "seed 5974 for j=34 out of 250 (i.e. j=7784 in [7751;8000], as job id is i=32)"
[1] "seed 93581 for j=35 out of 250 (i.e. j=7785 in [7751;8000], as job id is i=32)"
[1] "seed 59429 for j=36 out of 250 (i.e. j=7786 in [7751;8000], as job id is i=32)"
[1] "seed 47937 for j=37 out of 250 (i.e. j=7787 in [7751;8000], as job id is i=32)"
[1] "seed 59610 for j=38 out of 250 (i.e. j=7788 in [7751;8000], as job id is i=32)"
[1] "seed 17123 for j=39 out of 250 (i.e. j=7789 in [7751;8000], as job id is i=32)"
[1] "seed 36963 for j=40 out of 250 (i.e. j=7790 in [7751;8000], as job id is i=32)"
[1] "seed 78776 for j=41 out of 250 (i.e. j=7791 in [7751;8000], as job id is i=32)"
[1] "seed 23502 for j=42 out of 250 (i.e. j=7792 in [7751;8000], as job id is i=32)"
[1] "seed 96290 for j=43 out of 250 (i.e. j=7793 in [7751;8000], as job id is i=32)"
[1] "seed 36611 for j=44 out of 250 (i.e. j=7794 in [7751;8000], as job id is i=32)"
[1] "seed 82621 for j=45 out of 250 (i.e. j=7795 in [7751;8000], as job id is i=32)"
[1] "seed 7003 for j=46 out of 250 (i.e. j=7796 in [7751;8000], as job id is i=32)"
[1] "seed 98373 for j=47 out of 250 (i.e. j=7797 in [7751;8000], as job id is i=32)"
[1] "seed 62552 for j=48 out of 250 (i.e. j=7798 in [7751;8000], as job id is i=32)"
[1] "seed 67975 for j=49 out of 250 (i.e. j=7799 in [7751;8000], as job id is i=32)"
[1] "seed 20056 for j=50 out of 250 (i.e. j=7800 in [7751;8000], as job id is i=32)"
[1] "seed 1890 for j=51 out of 250 (i.e. j=7801 in [7751;8000], as job id is i=32)"
[1] "seed 58887 for j=52 out of 250 (i.e. j=7802 in [7751;8000], as job id is i=32)"
[1] "seed 79796 for j=53 out of 250 (i.e. j=7803 in [7751;8000], as job id is i=32)"
[1] "seed 58168 for j=54 out of 250 (i.e. j=7804 in [7751;8000], as job id is i=32)"
[1] "seed 63333 for j=55 out of 250 (i.e. j=7805 in [7751;8000], as job id is i=32)"
[1] "seed 287 for j=56 out of 250 (i.e. j=7806 in [7751;8000], as job id is i=32)"
[1] "seed 95562 for j=57 out of 250 (i.e. j=7807 in [7751;8000], as job id is i=32)"
[1] "seed 33260 for j=58 out of 250 (i.e. j=7808 in [7751;8000], as job id is i=32)"
[1] "seed 30300 for j=59 out of 250 (i.e. j=7809 in [7751;8000], as job id is i=32)"
[1] "seed 22808 for j=60 out of 250 (i.e. j=7810 in [7751;8000], as job id is i=32)"
[1] "seed 6743 for j=61 out of 250 (i.e. j=7811 in [7751;8000], as job id is i=32)"
[1] "seed 53840 for j=62 out of 250 (i.e. j=7812 in [7751;8000], as job id is i=32)"
[1] "seed 13482 for j=63 out of 250 (i.e. j=7813 in [7751;8000], as job id is i=32)"
[1] "seed 19694 for j=64 out of 250 (i.e. j=7814 in [7751;8000], as job id is i=32)"
[1] "seed 83199 for j=65 out of 250 (i.e. j=7815 in [7751;8000], as job id is i=32)"
[1] "seed 84568 for j=66 out of 250 (i.e. j=7816 in [7751;8000], as job id is i=32)"
[1] "seed 29558 for j=67 out of 250 (i.e. j=7817 in [7751;8000], as job id is i=32)"
[1] "seed 15999 for j=68 out of 250 (i.e. j=7818 in [7751;8000], as job id is i=32)"
[1] "seed 88533 for j=69 out of 250 (i.e. j=7819 in [7751;8000], as job id is i=32)"
[1] "seed 79368 for j=70 out of 250 (i.e. j=7820 in [7751;8000], as job id is i=32)"
[1] "seed 36344 for j=71 out of 250 (i.e. j=7821 in [7751;8000], as job id is i=32)"
[1] "seed 68292 for j=72 out of 250 (i.e. j=7822 in [7751;8000], as job id is i=32)"
[1] "seed 47959 for j=73 out of 250 (i.e. j=7823 in [7751;8000], as job id is i=32)"
[1] "seed 45694 for j=74 out of 250 (i.e. j=7824 in [7751;8000], as job id is i=32)"
[1] "seed 30362 for j=75 out of 250 (i.e. j=7825 in [7751;8000], as job id is i=32)"
[1] "seed 60502 for j=76 out of 250 (i.e. j=7826 in [7751;8000], as job id is i=32)"
[1] "seed 13477 for j=77 out of 250 (i.e. j=7827 in [7751;8000], as job id is i=32)"
[1] "seed 49883 for j=78 out of 250 (i.e. j=7828 in [7751;8000], as job id is i=32)"
[1] "seed 81743 for j=79 out of 250 (i.e. j=7829 in [7751;8000], as job id is i=32)"
[1] "seed 56412 for j=80 out of 250 (i.e. j=7830 in [7751;8000], as job id is i=32)"
[1] "seed 80237 for j=81 out of 250 (i.e. j=7831 in [7751;8000], as job id is i=32)"
[1] "seed 36614 for j=82 out of 250 (i.e. j=7832 in [7751;8000], as job id is i=32)"
[1] "seed 33883 for j=83 out of 250 (i.e. j=7833 in [7751;8000], as job id is i=32)"
[1] "seed 26215 for j=84 out of 250 (i.e. j=7834 in [7751;8000], as job id is i=32)"
[1] "seed 80649 for j=85 out of 250 (i.e. j=7835 in [7751;8000], as job id is i=32)"
[1] "seed 4156 for j=86 out of 250 (i.e. j=7836 in [7751;8000], as job id is i=32)"
[1] "seed 22175 for j=87 out of 250 (i.e. j=7837 in [7751;8000], as job id is i=32)"
[1] "seed 41291 for j=88 out of 250 (i.e. j=7838 in [7751;8000], as job id is i=32)"
[1] "seed 4740 for j=89 out of 250 (i.e. j=7839 in [7751;8000], as job id is i=32)"
[1] "seed 31044 for j=90 out of 250 (i.e. j=7840 in [7751;8000], as job id is i=32)"
[1] "seed 41361 for j=91 out of 250 (i.e. j=7841 in [7751;8000], as job id is i=32)"
[1] "seed 89149 for j=92 out of 250 (i.e. j=7842 in [7751;8000], as job id is i=32)"
[1] "seed 27131 for j=93 out of 250 (i.e. j=7843 in [7751;8000], as job id is i=32)"
[1] "seed 57952 for j=94 out of 250 (i.e. j=7844 in [7751;8000], as job id is i=32)"
[1] "seed 61227 for j=95 out of 250 (i.e. j=7845 in [7751;8000], as job id is i=32)"
[1] "seed 53061 for j=96 out of 250 (i.e. j=7846 in [7751;8000], as job id is i=32)"
[1] "seed 32004 for j=97 out of 250 (i.e. j=7847 in [7751;8000], as job id is i=32)"
[1] "seed 48492 for j=98 out of 250 (i.e. j=7848 in [7751;8000], as job id is i=32)"
[1] "seed 96302 for j=99 out of 250 (i.e. j=7849 in [7751;8000], as job id is i=32)"
[1] "seed 61597 for j=100 out of 250 (i.e. j=7850 in [7751;8000], as job id is i=32)"
[1] "seed 63233 for j=101 out of 250 (i.e. j=7851 in [7751;8000], as job id is i=32)"
[1] "seed 67083 for j=102 out of 250 (i.e. j=7852 in [7751;8000], as job id is i=32)"
[1] "seed 1623 for j=103 out of 250 (i.e. j=7853 in [7751;8000], as job id is i=32)"
[1] "seed 68302 for j=104 out of 250 (i.e. j=7854 in [7751;8000], as job id is i=32)"
[1] "seed 99206 for j=105 out of 250 (i.e. j=7855 in [7751;8000], as job id is i=32)"
[1] "seed 22231 for j=106 out of 250 (i.e. j=7856 in [7751;8000], as job id is i=32)"
[1] "seed 44630 for j=107 out of 250 (i.e. j=7857 in [7751;8000], as job id is i=32)"
[1] "seed 98364 for j=108 out of 250 (i.e. j=7858 in [7751;8000], as job id is i=32)"
[1] "seed 44719 for j=109 out of 250 (i.e. j=7859 in [7751;8000], as job id is i=32)"
[1] "seed 28008 for j=110 out of 250 (i.e. j=7860 in [7751;8000], as job id is i=32)"
[1] "seed 83541 for j=111 out of 250 (i.e. j=7861 in [7751;8000], as job id is i=32)"
[1] "seed 62547 for j=112 out of 250 (i.e. j=7862 in [7751;8000], as job id is i=32)"
[1] "seed 71811 for j=113 out of 250 (i.e. j=7863 in [7751;8000], as job id is i=32)"
[1] "seed 9109 for j=114 out of 250 (i.e. j=7864 in [7751;8000], as job id is i=32)"
[1] "seed 90721 for j=115 out of 250 (i.e. j=7865 in [7751;8000], as job id is i=32)"
[1] "seed 99428 for j=116 out of 250 (i.e. j=7866 in [7751;8000], as job id is i=32)"
[1] "seed 73055 for j=117 out of 250 (i.e. j=7867 in [7751;8000], as job id is i=32)"
[1] "seed 41850 for j=118 out of 250 (i.e. j=7868 in [7751;8000], as job id is i=32)"
[1] "seed 77796 for j=119 out of 250 (i.e. j=7869 in [7751;8000], as job id is i=32)"
[1] "seed 83897 for j=120 out of 250 (i.e. j=7870 in [7751;8000], as job id is i=32)"
[1] "seed 11888 for j=121 out of 250 (i.e. j=7871 in [7751;8000], as job id is i=32)"
[1] "seed 95097 for j=122 out of 250 (i.e. j=7872 in [7751;8000], as job id is i=32)"
[1] "seed 28643 for j=123 out of 250 (i.e. j=7873 in [7751;8000], as job id is i=32)"
[1] "seed 66373 for j=124 out of 250 (i.e. j=7874 in [7751;8000], as job id is i=32)"
[1] "seed 96313 for j=125 out of 250 (i.e. j=7875 in [7751;8000], as job id is i=32)"
[1] "seed 36624 for j=126 out of 250 (i.e. j=7876 in [7751;8000], as job id is i=32)"
[1] "seed 2687 for j=127 out of 250 (i.e. j=7877 in [7751;8000], as job id is i=32)"
[1] "seed 4677 for j=128 out of 250 (i.e. j=7878 in [7751;8000], as job id is i=32)"
[1] "seed 5900 for j=129 out of 250 (i.e. j=7879 in [7751;8000], as job id is i=32)"
[1] "seed 3182 for j=130 out of 250 (i.e. j=7880 in [7751;8000], as job id is i=32)"
[1] "seed 54899 for j=131 out of 250 (i.e. j=7881 in [7751;8000], as job id is i=32)"
[1] "seed 52917 for j=132 out of 250 (i.e. j=7882 in [7751;8000], as job id is i=32)"
[1] "seed 18995 for j=133 out of 250 (i.e. j=7883 in [7751;8000], as job id is i=32)"
[1] "seed 36301 for j=134 out of 250 (i.e. j=7884 in [7751;8000], as job id is i=32)"
[1] "seed 13458 for j=135 out of 250 (i.e. j=7885 in [7751;8000], as job id is i=32)"
[1] "seed 72603 for j=136 out of 250 (i.e. j=7886 in [7751;8000], as job id is i=32)"
[1] "seed 55936 for j=137 out of 250 (i.e. j=7887 in [7751;8000], as job id is i=32)"
[1] "seed 64862 for j=138 out of 250 (i.e. j=7888 in [7751;8000], as job id is i=32)"
[1] "seed 4213 for j=139 out of 250 (i.e. j=7889 in [7751;8000], as job id is i=32)"
[1] "seed 68001 for j=140 out of 250 (i.e. j=7890 in [7751;8000], as job id is i=32)"
[1] "seed 64208 for j=141 out of 250 (i.e. j=7891 in [7751;8000], as job id is i=32)"
[1] "seed 62174 for j=142 out of 250 (i.e. j=7892 in [7751;8000], as job id is i=32)"
[1] "seed 18734 for j=143 out of 250 (i.e. j=7893 in [7751;8000], as job id is i=32)"
[1] "seed 60763 for j=144 out of 250 (i.e. j=7894 in [7751;8000], as job id is i=32)"
[1] "seed 72568 for j=145 out of 250 (i.e. j=7895 in [7751;8000], as job id is i=32)"
[1] "seed 22838 for j=146 out of 250 (i.e. j=7896 in [7751;8000], as job id is i=32)"
[1] "seed 7870 for j=147 out of 250 (i.e. j=7897 in [7751;8000], as job id is i=32)"
[1] "seed 58007 for j=148 out of 250 (i.e. j=7898 in [7751;8000], as job id is i=32)"
[1] "seed 92095 for j=149 out of 250 (i.e. j=7899 in [7751;8000], as job id is i=32)"
[1] "seed 65276 for j=150 out of 250 (i.e. j=7900 in [7751;8000], as job id is i=32)"
[1] "seed 66970 for j=151 out of 250 (i.e. j=7901 in [7751;8000], as job id is i=32)"
[1] "seed 34063 for j=152 out of 250 (i.e. j=7902 in [7751;8000], as job id is i=32)"
[1] "seed 6446 for j=153 out of 250 (i.e. j=7903 in [7751;8000], as job id is i=32)"
[1] "seed 99012 for j=154 out of 250 (i.e. j=7904 in [7751;8000], as job id is i=32)"
[1] "seed 71857 for j=155 out of 250 (i.e. j=7905 in [7751;8000], as job id is i=32)"
[1] "seed 88219 for j=156 out of 250 (i.e. j=7906 in [7751;8000], as job id is i=32)"
Error in uniroot(function(x) { : 
  f() values at end points not of opposite sign
Calls: update ... update.delayedGSD -> updateBoundaries -> updateMethod1 -> uniroot
In addition: Warning messages:
1: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

2: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

3: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

4: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

5: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

6: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

7: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

8: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

9: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

10: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

Execution halted
