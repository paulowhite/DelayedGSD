
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### BATCH_simuMain.R --- 
> #----------------------------------------------------------------------
> ## Author: Paul Blanche
> ## Created: Mar  5 2021 (10:56) 
> ## Version: 
> ## Last-Updated: jul  7 2022 (13:56) 
> ##           By: Brice Ozenne
> ##     Update #: 518
> #----------------------------------------------------------------------
> ## 
> ### Commentary: 
> ## 
> ### Change Log:
> #----------------------------------------------------------------------
> ## 
> ### Code:
> 
> ## ** BATCH loop
> ## cd /projects/biostat01/people/hpl802/DelayedGSD/
> ## for ITER in `seq 1 10`;
> ## do
> ## eval 'R CMD BATCH --vanilla "--args iter_sim='$ITER' n.iter_sim=10" BATCH_simuMain.R output/R-simuMain-'$ITER'.Rout &'
> ## done
> 
> ## [1] 1186669
> ## [2] 1186670
> ## [3] 1186671
> ## [4] 1186672
> ## [5] 1186673
> ## [6] 1186674
> ## [7] 1186675
> ## [8] 1186676
> ## [9] 1186677
> ## [10] 1186678
> 
> rm(list=ls())
>                                    # {{{ parameters
> ## * parameters
> name <- "ScenarioName" # To save the results
> method <- 1:2 # methods used to compute the boundaries
>                                         #---
> myseed <- 140786598
>                                         #--- to plan the trial ----
> NMC <- 250 # number of sequential simulations to run in parallel. Eg. with 250, then we can run 40 scripts in paralell to get N=10,000 runs in total.
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.5,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.55  #(expected) information rate at each decision analysis
> binding <- TRUE
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.6,0.8) # treatment effect
> ar <- (0.86*2)*2 # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As to low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> Miss11 <- 5/104 # miss both V1 and V2
> Miss12 <- 1/104 # miss V1 and but not V2
> Miss21 <- 6/104 # do not miss V1 and but miss V2
> Miss22 <- 92/104 # miss none
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- abs(delta[3]) # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> n <- ceiling(2*2*((allsd[3]/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
>                                         # {{{ Set seeds for parallel computing and reproducibility
> ## * Seed
> args <- commandArgs(TRUE) ## BATCH MODE
> if(length(args)>0){
+     for (arg in args){
+         eval(parse(text=arg))
+     }
+ }else{ ## SLUMR
+     iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
+     n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
+ } ## interactive
> if(is.na(iter_sim)){iter_sim <- 1}
> if(is.na(n.iter_sim)){n.iter_sim <- 40}
> 
> set.seed(140786598)
> allseeds <- sample.int(n = 10*n.iter_sim*NMC, size = n.iter_sim*NMC, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> # }}}
> 
> # {{{ set path to load and save and othe machine specific variables
> ## * path
> path <- "."
> path.res <- file.path(path,"Results","simuMain")
> if(dir.exists(path.res)==FALSE){
+     if(dir.exists(file.path(path,"Results"))==FALSE){
+     dir.create(file.path(path,"Results"))
+     }
+     dir.create(path.res)
+ }
> path.output <- file.path(path,"output","simuMain")
> if(dir.exists(path.output)==FALSE){
+     if(dir.exists(file.path(path,"output"))==FALSE){
+     dir.create(file.path(path,"output"))
+     }
+     dir.create(path.output)
+ }
> # }}}
> 
> 
> ## * libraries and functions
> library(DelayedGSD)
DelayedGSD version 0.0.3
> ## sourceDir <- function(path, trace = TRUE, ...) {
> ##     for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
> ##         if(trace) cat(nm,":")
> ##         source(file.path(path, nm), ...)
> ##         if(trace) cat("\n")
> ##     }
> ## }
> ## sourceDir(pathToLoad)
>     
> 
> ## * Compute inflation factor and sample size
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+     plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                         alpha=alpha, 
+                                         beta=beta,  
+                                         InfoR.i=informationRates,  
+                                         InfoR.d=c(Id,1),  
+                                         rho_alpha=rho_alpha,  
+                                         rho_beta=rho_beta,  
+                                         method=iMeth,  
+                                         cNotBelowFixedc=FALSE,
+                                         bindingFutility=binding,
+                                         delta=tail(delta,1))
+     ## summary(plannedB[[1]])
+     ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> ##  plot(plannedB[[1]])
> 
> #
> # --- just to check---
> ## n
> ## InfoFixed <- ((qnorm(1-beta)-qnorm(alpha))/(deltaPower))^2
> ## InfoFixed
> ## n/(4*(allsd[3])^2)
> #---
> # }}}
> 
> 
> 
> 
> # {{{ technical details to loop
> RES <- NULL # initialize results to save
> allj <- ((iter_sim-1)*NMC + 1):(iter_sim*NMC) # indices of all iterations (replicates) for this job, accountng for the other jobs running in parallel
> # }}}
> 
> ## * Loop
> for(j in allj){ ## j <- 51 ## 5
+     startComp <- Sys.time()
+     myseedi <- allseeds[j]
+     # {{{ TRACE info (e.g. to check the Rout)
+     print(paste0("seed ",myseedi," for ","j=",which(j==allj)," out of ",NMC, " (i.e. j=",j," in [",(iter_sim-1)*NMC + 1,";",iter_sim*NMC,"], as job id is i=",iter_sim,")"))
+     # }}}
+     # {{{ Missing probabilities
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE) # to additionnally remove 1 more because some FASFL=N
+     colnames(MyMissProb) <- c("V2 missing","V2 not missing")
+     rownames(MyMissProb) <- c("V1 missing","V1 not missing")
+     # }}}
+ 
+                                         # {{{ generate data
+     ## ** simulate
+     res <- GenData(n=n, 
+                    N.fw=2,
+                    rand.block=block,
+                    allsd=allsd,
+                    mean0=mean0,
+                    delta=delta,
+                    ar=ar,
+                    cor.01.1=cor011,
+                    cor.ij.1=corij1,
+                    cor.0j.1=cor0j1,
+                    seed=myseedi,
+                    MissProb=MyMissProb,
+                    DigitsOutcome=2,
+                    TimeFactor=TimeFactor,
+                    DigitsTime=0
+                    )
+     d <- res$d
+     ## head(d,n=20)
+                                         # }}}
+                                         # {{{ reformat data like those of Corine
+     ## Make data long format
+     ## dd <- FormatAsCase(d)
+     ## head(dd)
+     ## summary(dd)
+                                         # }}}
+    
+                                         # {{{ make data available at interim
+                                         # Here we stop inclusion data collection for the interim analysis as soon as
+                                         # half of the participants have completed (or had the opportunity to complete) the follow-up 
+     thet <- d$t3[ceiling(n*PropForInterim)]
+     di <- SelectData(d,t=thet)
+     ## ddi <- FormatAsCase(di) # needed ????
+     ## head(d[d$id==52,])
+                                         # }}}
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thet + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     currentGSD <- vector(mode = "list", length = 3)
+     out.interim <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+ 
+         currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+ 
+         iConfint.interim <- confint(currentGSD[[iMeth]])
+         iInfo.interim <- coef(currentGSD[[iMeth]], type = "information")
+         iBoundary.interim <- coef(currentGSD[[iMeth]], type = "boundary")
+         iDecision.interim <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+         out.interim[[iMeth]] <-  data.frame(statistic = iConfint.interim[1,"statistic"],
+                                             estimate_ML = iConfint.interim[1,"estimate"],
+                                             se_ML = iConfint.interim[1,"se"],
+                                             info = iInfo.interim[1,"Interim"],
+                                             infoPC = iInfo.interim[1,"Interim.pc"],
+                                             info.pred = iInfo.interim[1,"Decision"],
+                                             infoPC.pred = iInfo.interim[1,"Decision.pc"],
+                                             uk = iBoundary.interim[1,"Ebound"],
+                                             lk = iBoundary.interim[1,"Fbound"],
+                                             decision = iDecision.interim["decision","stage 1"],
+                                             reason = iDecision.interim["reason.interim","stage 1"])
+     }
+     ## currentGSD[[1]]
+     ## plot(currentGSD[[1]])
+ 
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thet + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     out.decision <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+           
+         if(out.interim[[iMeth]]$decision == "stop"){
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+             ## plot(currentGSD[[iMeth]])
+ 
+             iConfint.decision <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.decision  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = iConfint.decision[1,"statistic"],
+                                                 p.value_ML = iConfint.decision[iConfint.decision$method == "ML","p.value"],
+                                                 lower_ML = iConfint.decision[iConfint.decision$method == "ML","lower"],
+                                                 upper_ML = iConfint.decision[iConfint.decision$method == "ML","upper"],
+                                                 estimate_ML = iConfint.decision[iConfint.decision$method == "ML","estimate"],
+                                                 p.value_MUE = iConfint.decision[iConfint.decision$method == "MUE","p.value"],
+                                                 lower_MUE = iConfint.decision[iConfint.decision$method == "MUE","lower"],
+                                                 upper_MUE = iConfint.decision[iConfint.decision$method == "MUE","upper"],
+                                                 estimate_MUE = iConfint.decision[iConfint.decision$method == "MUE","estimate"],
+                                                 info = iInfo.decision[1,"Interim"],
+                                                 infoPC = iInfo.decision[1,"Interim.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = unname(iDecision.decision["decision","stage 2"])
+                                                 )
+ 
+         }else{
+             ## update information
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+ 
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = NA,
+                                                 p.value_ML = NA,
+                                                 lower_ML = NA,
+                                                 upper_ML = NA,
+                                                 estimate_ML = NA,
+                                                 p.value_MUE = NA,
+                                                 lower_MUE = NA,
+                                                 upper_MUE = NA,
+                                                 estimate_MUE = NA,
+                                                 info = iInfo.decision[1,"Decision"],
+                                                 infoPC = iInfo.decision[1,"Decision.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = NA)
+         }
+     }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+ 
+     ## ** finale
+     dFinal <- d
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     out.final <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+         if(out.interim[[iMeth]]$decision == "stop"){
+             out.final[[iMeth]] <- data.frame(statistic = NA,
+                                              p.value_ML = NA,
+                                              lower_ML = NA,
+                                              upper_ML = NA,
+                                              estimate_ML = NA,
+                                              p.value_MUE = NA,
+                                              lower_MUE = NA,
+                                              upper_MUE = NA,
+                                              estimate_MUE = NA,
+                                              info = NA,
+                                              infoPC = NA,
+                                              ck = NA,
+                                              decision = NA)
+ 
+         }else{
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+ 
+             ## plot(test)
+             ## summary(test)
+             iConfint.final <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.final <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.final <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.final  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.final[[iMeth]] <- data.frame(statistic = iConfint.final[1,"statistic"],
+                                              p.value_ML = iConfint.final[iConfint.final$method == "ML","p.value"],
+                                              lower_ML = iConfint.final[iConfint.final$method == "ML","lower"],
+                                              upper_ML = iConfint.final[iConfint.final$method == "ML","upper"],
+                                              estimate_ML = iConfint.final[iConfint.final$method == "ML","estimate"],
+                                              p.value_MUE = iConfint.final[iConfint.final$method == "MUE","p.value"],
+                                              lower_MUE = iConfint.final[iConfint.final$method == "MUE","lower"],
+                                              upper_MUE = iConfint.final[iConfint.final$method == "MUE","upper"],
+                                              estimate_MUE = iConfint.final[iConfint.final$method == "MUE","estimate"],
+                                              info = iInfo.final[1,"Interim"],
+                                              infoPC = iInfo.final[1,"Interim.pc"],
+                                              ck = iBoundary.final[1,"Cbound"],
+                                              decision = unname(coef(currentGSD[[iMeth]], type = "decision")["decision","stage 2"])
+                                              )
+         }
+     }
+                                         # }}}
+ 
+     stopComp <- Sys.time()
+                                         # {{{ Save results
+ 
+     outMerge <- do.call(rbind,lapply(method, function(iMeth){
+         iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+         iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+         iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+         iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+         iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+         return(iMerge)
+     }))
+ 
+     ## outMerge[outMerge$method==3,]
+ 
+     out <- cbind(
+         ## results
+         outMerge,
+         ## simulation details
+         time.interim = thet,
+         seed=myseedi,             
+         nX1.interim = sum(!is.na(di$X1)),
+         nX2.interim = sum(!is.na(di$X2)),
+         nX3.interim = sum(!is.na(di$X3)),
+         ## computation time
+         computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+     )
+     ## names(out) <- myColNames
+     RES <- rbind(RES,out)
+     save(RES,file=paste0(path.res,name,"(tempo)-",iter_sim,".rda"))
+                                         # }}}
+ }
[1] "seed 13495 for j=1 out of 250 (i.e. j=751 in [751;1000], as job id is i=4)"
Loading required namespace: nlme
[1] "seed 36243 for j=2 out of 250 (i.e. j=752 in [751;1000], as job id is i=4)"
[1] "seed 31475 for j=3 out of 250 (i.e. j=753 in [751;1000], as job id is i=4)"
[1] "seed 58179 for j=4 out of 250 (i.e. j=754 in [751;1000], as job id is i=4)"
[1] "seed 28632 for j=5 out of 250 (i.e. j=755 in [751;1000], as job id is i=4)"
[1] "seed 95380 for j=6 out of 250 (i.e. j=756 in [751;1000], as job id is i=4)"
[1] "seed 2387 for j=7 out of 250 (i.e. j=757 in [751;1000], as job id is i=4)"
[1] "seed 38609 for j=8 out of 250 (i.e. j=758 in [751;1000], as job id is i=4)"
[1] "seed 26767 for j=9 out of 250 (i.e. j=759 in [751;1000], as job id is i=4)"
[1] "seed 16512 for j=10 out of 250 (i.e. j=760 in [751;1000], as job id is i=4)"
[1] "seed 23205 for j=11 out of 250 (i.e. j=761 in [751;1000], as job id is i=4)"
[1] "seed 52272 for j=12 out of 250 (i.e. j=762 in [751;1000], as job id is i=4)"
[1] "seed 66890 for j=13 out of 250 (i.e. j=763 in [751;1000], as job id is i=4)"
[1] "seed 76634 for j=14 out of 250 (i.e. j=764 in [751;1000], as job id is i=4)"
[1] "seed 36410 for j=15 out of 250 (i.e. j=765 in [751;1000], as job id is i=4)"
[1] "seed 92480 for j=16 out of 250 (i.e. j=766 in [751;1000], as job id is i=4)"
[1] "seed 60655 for j=17 out of 250 (i.e. j=767 in [751;1000], as job id is i=4)"
[1] "seed 44963 for j=18 out of 250 (i.e. j=768 in [751;1000], as job id is i=4)"
[1] "seed 74634 for j=19 out of 250 (i.e. j=769 in [751;1000], as job id is i=4)"
[1] "seed 72237 for j=20 out of 250 (i.e. j=770 in [751;1000], as job id is i=4)"
[1] "seed 44445 for j=21 out of 250 (i.e. j=771 in [751;1000], as job id is i=4)"
[1] "seed 50289 for j=22 out of 250 (i.e. j=772 in [751;1000], as job id is i=4)"
[1] "seed 52342 for j=23 out of 250 (i.e. j=773 in [751;1000], as job id is i=4)"
[1] "seed 89098 for j=24 out of 250 (i.e. j=774 in [751;1000], as job id is i=4)"
[1] "seed 45821 for j=25 out of 250 (i.e. j=775 in [751;1000], as job id is i=4)"
[1] "seed 53802 for j=26 out of 250 (i.e. j=776 in [751;1000], as job id is i=4)"
[1] "seed 94083 for j=27 out of 250 (i.e. j=777 in [751;1000], as job id is i=4)"
[1] "seed 65444 for j=28 out of 250 (i.e. j=778 in [751;1000], as job id is i=4)"
[1] "seed 5800 for j=29 out of 250 (i.e. j=779 in [751;1000], as job id is i=4)"
[1] "seed 97303 for j=30 out of 250 (i.e. j=780 in [751;1000], as job id is i=4)"
[1] "seed 89497 for j=31 out of 250 (i.e. j=781 in [751;1000], as job id is i=4)"
[1] "seed 6205 for j=32 out of 250 (i.e. j=782 in [751;1000], as job id is i=4)"
[1] "seed 30597 for j=33 out of 250 (i.e. j=783 in [751;1000], as job id is i=4)"
[1] "seed 27699 for j=34 out of 250 (i.e. j=784 in [751;1000], as job id is i=4)"
[1] "seed 28374 for j=35 out of 250 (i.e. j=785 in [751;1000], as job id is i=4)"
[1] "seed 6131 for j=36 out of 250 (i.e. j=786 in [751;1000], as job id is i=4)"
[1] "seed 84523 for j=37 out of 250 (i.e. j=787 in [751;1000], as job id is i=4)"
[1] "seed 31630 for j=38 out of 250 (i.e. j=788 in [751;1000], as job id is i=4)"
[1] "seed 18827 for j=39 out of 250 (i.e. j=789 in [751;1000], as job id is i=4)"
[1] "seed 19271 for j=40 out of 250 (i.e. j=790 in [751;1000], as job id is i=4)"
[1] "seed 7001 for j=41 out of 250 (i.e. j=791 in [751;1000], as job id is i=4)"
[1] "seed 37881 for j=42 out of 250 (i.e. j=792 in [751;1000], as job id is i=4)"
[1] "seed 69749 for j=43 out of 250 (i.e. j=793 in [751;1000], as job id is i=4)"
[1] "seed 93327 for j=44 out of 250 (i.e. j=794 in [751;1000], as job id is i=4)"
[1] "seed 17251 for j=45 out of 250 (i.e. j=795 in [751;1000], as job id is i=4)"
[1] "seed 1732 for j=46 out of 250 (i.e. j=796 in [751;1000], as job id is i=4)"
[1] "seed 38549 for j=47 out of 250 (i.e. j=797 in [751;1000], as job id is i=4)"
[1] "seed 26607 for j=48 out of 250 (i.e. j=798 in [751;1000], as job id is i=4)"
[1] "seed 81507 for j=49 out of 250 (i.e. j=799 in [751;1000], as job id is i=4)"
[1] "seed 38943 for j=50 out of 250 (i.e. j=800 in [751;1000], as job id is i=4)"
[1] "seed 151 for j=51 out of 250 (i.e. j=801 in [751;1000], as job id is i=4)"
[1] "seed 44504 for j=52 out of 250 (i.e. j=802 in [751;1000], as job id is i=4)"
[1] "seed 54183 for j=53 out of 250 (i.e. j=803 in [751;1000], as job id is i=4)"
[1] "seed 3085 for j=54 out of 250 (i.e. j=804 in [751;1000], as job id is i=4)"
[1] "seed 33412 for j=55 out of 250 (i.e. j=805 in [751;1000], as job id is i=4)"
[1] "seed 58980 for j=56 out of 250 (i.e. j=806 in [751;1000], as job id is i=4)"
[1] "seed 50365 for j=57 out of 250 (i.e. j=807 in [751;1000], as job id is i=4)"
[1] "seed 53376 for j=58 out of 250 (i.e. j=808 in [751;1000], as job id is i=4)"
[1] "seed 42065 for j=59 out of 250 (i.e. j=809 in [751;1000], as job id is i=4)"
[1] "seed 69046 for j=60 out of 250 (i.e. j=810 in [751;1000], as job id is i=4)"
[1] "seed 96536 for j=61 out of 250 (i.e. j=811 in [751;1000], as job id is i=4)"
[1] "seed 13031 for j=62 out of 250 (i.e. j=812 in [751;1000], as job id is i=4)"
[1] "seed 88899 for j=63 out of 250 (i.e. j=813 in [751;1000], as job id is i=4)"
[1] "seed 73449 for j=64 out of 250 (i.e. j=814 in [751;1000], as job id is i=4)"
[1] "seed 30986 for j=65 out of 250 (i.e. j=815 in [751;1000], as job id is i=4)"
[1] "seed 97093 for j=66 out of 250 (i.e. j=816 in [751;1000], as job id is i=4)"
[1] "seed 52959 for j=67 out of 250 (i.e. j=817 in [751;1000], as job id is i=4)"
[1] "seed 40185 for j=68 out of 250 (i.e. j=818 in [751;1000], as job id is i=4)"
[1] "seed 7623 for j=69 out of 250 (i.e. j=819 in [751;1000], as job id is i=4)"
[1] "seed 51161 for j=70 out of 250 (i.e. j=820 in [751;1000], as job id is i=4)"
[1] "seed 80675 for j=71 out of 250 (i.e. j=821 in [751;1000], as job id is i=4)"
[1] "seed 42132 for j=72 out of 250 (i.e. j=822 in [751;1000], as job id is i=4)"
[1] "seed 35796 for j=73 out of 250 (i.e. j=823 in [751;1000], as job id is i=4)"
[1] "seed 1879 for j=74 out of 250 (i.e. j=824 in [751;1000], as job id is i=4)"
[1] "seed 12789 for j=75 out of 250 (i.e. j=825 in [751;1000], as job id is i=4)"
[1] "seed 53678 for j=76 out of 250 (i.e. j=826 in [751;1000], as job id is i=4)"
[1] "seed 54016 for j=77 out of 250 (i.e. j=827 in [751;1000], as job id is i=4)"
[1] "seed 50654 for j=78 out of 250 (i.e. j=828 in [751;1000], as job id is i=4)"
[1] "seed 60469 for j=79 out of 250 (i.e. j=829 in [751;1000], as job id is i=4)"
[1] "seed 56647 for j=80 out of 250 (i.e. j=830 in [751;1000], as job id is i=4)"
[1] "seed 78444 for j=81 out of 250 (i.e. j=831 in [751;1000], as job id is i=4)"
[1] "seed 6470 for j=82 out of 250 (i.e. j=832 in [751;1000], as job id is i=4)"
[1] "seed 14929 for j=83 out of 250 (i.e. j=833 in [751;1000], as job id is i=4)"
[1] "seed 40218 for j=84 out of 250 (i.e. j=834 in [751;1000], as job id is i=4)"
[1] "seed 67281 for j=85 out of 250 (i.e. j=835 in [751;1000], as job id is i=4)"
[1] "seed 42621 for j=86 out of 250 (i.e. j=836 in [751;1000], as job id is i=4)"
[1] "seed 50395 for j=87 out of 250 (i.e. j=837 in [751;1000], as job id is i=4)"
[1] "seed 69009 for j=88 out of 250 (i.e. j=838 in [751;1000], as job id is i=4)"
[1] "seed 52705 for j=89 out of 250 (i.e. j=839 in [751;1000], as job id is i=4)"
[1] "seed 53856 for j=90 out of 250 (i.e. j=840 in [751;1000], as job id is i=4)"
[1] "seed 98812 for j=91 out of 250 (i.e. j=841 in [751;1000], as job id is i=4)"
[1] "seed 75290 for j=92 out of 250 (i.e. j=842 in [751;1000], as job id is i=4)"
[1] "seed 70263 for j=93 out of 250 (i.e. j=843 in [751;1000], as job id is i=4)"
[1] "seed 24848 for j=94 out of 250 (i.e. j=844 in [751;1000], as job id is i=4)"
[1] "seed 97448 for j=95 out of 250 (i.e. j=845 in [751;1000], as job id is i=4)"
[1] "seed 13693 for j=96 out of 250 (i.e. j=846 in [751;1000], as job id is i=4)"
[1] "seed 35423 for j=97 out of 250 (i.e. j=847 in [751;1000], as job id is i=4)"
[1] "seed 54665 for j=98 out of 250 (i.e. j=848 in [751;1000], as job id is i=4)"
[1] "seed 77355 for j=99 out of 250 (i.e. j=849 in [751;1000], as job id is i=4)"
[1] "seed 92575 for j=100 out of 250 (i.e. j=850 in [751;1000], as job id is i=4)"
[1] "seed 10754 for j=101 out of 250 (i.e. j=851 in [751;1000], as job id is i=4)"
[1] "seed 15402 for j=102 out of 250 (i.e. j=852 in [751;1000], as job id is i=4)"
[1] "seed 49108 for j=103 out of 250 (i.e. j=853 in [751;1000], as job id is i=4)"
[1] "seed 36957 for j=104 out of 250 (i.e. j=854 in [751;1000], as job id is i=4)"
[1] "seed 21544 for j=105 out of 250 (i.e. j=855 in [751;1000], as job id is i=4)"
[1] "seed 56490 for j=106 out of 250 (i.e. j=856 in [751;1000], as job id is i=4)"
[1] "seed 22863 for j=107 out of 250 (i.e. j=857 in [751;1000], as job id is i=4)"
[1] "seed 79061 for j=108 out of 250 (i.e. j=858 in [751;1000], as job id is i=4)"
[1] "seed 94177 for j=109 out of 250 (i.e. j=859 in [751;1000], as job id is i=4)"
[1] "seed 40782 for j=110 out of 250 (i.e. j=860 in [751;1000], as job id is i=4)"
[1] "seed 35871 for j=111 out of 250 (i.e. j=861 in [751;1000], as job id is i=4)"
[1] "seed 19895 for j=112 out of 250 (i.e. j=862 in [751;1000], as job id is i=4)"
[1] "seed 73860 for j=113 out of 250 (i.e. j=863 in [751;1000], as job id is i=4)"
[1] "seed 77362 for j=114 out of 250 (i.e. j=864 in [751;1000], as job id is i=4)"
[1] "seed 97550 for j=115 out of 250 (i.e. j=865 in [751;1000], as job id is i=4)"
[1] "seed 18139 for j=116 out of 250 (i.e. j=866 in [751;1000], as job id is i=4)"
[1] "seed 52270 for j=117 out of 250 (i.e. j=867 in [751;1000], as job id is i=4)"
[1] "seed 84948 for j=118 out of 250 (i.e. j=868 in [751;1000], as job id is i=4)"
[1] "seed 70720 for j=119 out of 250 (i.e. j=869 in [751;1000], as job id is i=4)"
[1] "seed 44422 for j=120 out of 250 (i.e. j=870 in [751;1000], as job id is i=4)"
[1] "seed 82788 for j=121 out of 250 (i.e. j=871 in [751;1000], as job id is i=4)"
[1] "seed 17381 for j=122 out of 250 (i.e. j=872 in [751;1000], as job id is i=4)"
[1] "seed 82348 for j=123 out of 250 (i.e. j=873 in [751;1000], as job id is i=4)"
[1] "seed 31380 for j=124 out of 250 (i.e. j=874 in [751;1000], as job id is i=4)"
[1] "seed 31181 for j=125 out of 250 (i.e. j=875 in [751;1000], as job id is i=4)"
[1] "seed 44941 for j=126 out of 250 (i.e. j=876 in [751;1000], as job id is i=4)"
[1] "seed 67500 for j=127 out of 250 (i.e. j=877 in [751;1000], as job id is i=4)"
[1] "seed 94897 for j=128 out of 250 (i.e. j=878 in [751;1000], as job id is i=4)"
[1] "seed 10274 for j=129 out of 250 (i.e. j=879 in [751;1000], as job id is i=4)"
[1] "seed 59885 for j=130 out of 250 (i.e. j=880 in [751;1000], as job id is i=4)"
[1] "seed 15870 for j=131 out of 250 (i.e. j=881 in [751;1000], as job id is i=4)"
[1] "seed 75090 for j=132 out of 250 (i.e. j=882 in [751;1000], as job id is i=4)"
[1] "seed 29277 for j=133 out of 250 (i.e. j=883 in [751;1000], as job id is i=4)"
[1] "seed 11913 for j=134 out of 250 (i.e. j=884 in [751;1000], as job id is i=4)"
[1] "seed 99853 for j=135 out of 250 (i.e. j=885 in [751;1000], as job id is i=4)"
[1] "seed 19883 for j=136 out of 250 (i.e. j=886 in [751;1000], as job id is i=4)"
[1] "seed 86810 for j=137 out of 250 (i.e. j=887 in [751;1000], as job id is i=4)"
[1] "seed 9012 for j=138 out of 250 (i.e. j=888 in [751;1000], as job id is i=4)"
[1] "seed 27464 for j=139 out of 250 (i.e. j=889 in [751;1000], as job id is i=4)"
[1] "seed 64545 for j=140 out of 250 (i.e. j=890 in [751;1000], as job id is i=4)"
[1] "seed 36331 for j=141 out of 250 (i.e. j=891 in [751;1000], as job id is i=4)"
[1] "seed 72651 for j=142 out of 250 (i.e. j=892 in [751;1000], as job id is i=4)"
[1] "seed 47226 for j=143 out of 250 (i.e. j=893 in [751;1000], as job id is i=4)"
[1] "seed 5866 for j=144 out of 250 (i.e. j=894 in [751;1000], as job id is i=4)"
[1] "seed 50458 for j=145 out of 250 (i.e. j=895 in [751;1000], as job id is i=4)"
[1] "seed 49468 for j=146 out of 250 (i.e. j=896 in [751;1000], as job id is i=4)"
[1] "seed 71921 for j=147 out of 250 (i.e. j=897 in [751;1000], as job id is i=4)"
[1] "seed 7401 for j=148 out of 250 (i.e. j=898 in [751;1000], as job id is i=4)"
[1] "seed 23148 for j=149 out of 250 (i.e. j=899 in [751;1000], as job id is i=4)"
[1] "seed 45494 for j=150 out of 250 (i.e. j=900 in [751;1000], as job id is i=4)"
[1] "seed 1848 for j=151 out of 250 (i.e. j=901 in [751;1000], as job id is i=4)"
[1] "seed 83027 for j=152 out of 250 (i.e. j=902 in [751;1000], as job id is i=4)"
[1] "seed 23657 for j=153 out of 250 (i.e. j=903 in [751;1000], as job id is i=4)"
[1] "seed 40407 for j=154 out of 250 (i.e. j=904 in [751;1000], as job id is i=4)"
[1] "seed 40250 for j=155 out of 250 (i.e. j=905 in [751;1000], as job id is i=4)"
[1] "seed 75981 for j=156 out of 250 (i.e. j=906 in [751;1000], as job id is i=4)"
[1] "seed 90744 for j=157 out of 250 (i.e. j=907 in [751;1000], as job id is i=4)"
[1] "seed 75459 for j=158 out of 250 (i.e. j=908 in [751;1000], as job id is i=4)"
[1] "seed 32078 for j=159 out of 250 (i.e. j=909 in [751;1000], as job id is i=4)"
[1] "seed 68586 for j=160 out of 250 (i.e. j=910 in [751;1000], as job id is i=4)"
[1] "seed 24202 for j=161 out of 250 (i.e. j=911 in [751;1000], as job id is i=4)"
[1] "seed 85855 for j=162 out of 250 (i.e. j=912 in [751;1000], as job id is i=4)"
[1] "seed 27235 for j=163 out of 250 (i.e. j=913 in [751;1000], as job id is i=4)"
[1] "seed 84719 for j=164 out of 250 (i.e. j=914 in [751;1000], as job id is i=4)"
[1] "seed 87730 for j=165 out of 250 (i.e. j=915 in [751;1000], as job id is i=4)"
[1] "seed 31871 for j=166 out of 250 (i.e. j=916 in [751;1000], as job id is i=4)"
[1] "seed 7709 for j=167 out of 250 (i.e. j=917 in [751;1000], as job id is i=4)"
[1] "seed 63536 for j=168 out of 250 (i.e. j=918 in [751;1000], as job id is i=4)"
[1] "seed 50743 for j=169 out of 250 (i.e. j=919 in [751;1000], as job id is i=4)"
[1] "seed 73104 for j=170 out of 250 (i.e. j=920 in [751;1000], as job id is i=4)"
[1] "seed 9758 for j=171 out of 250 (i.e. j=921 in [751;1000], as job id is i=4)"
[1] "seed 3608 for j=172 out of 250 (i.e. j=922 in [751;1000], as job id is i=4)"
[1] "seed 74148 for j=173 out of 250 (i.e. j=923 in [751;1000], as job id is i=4)"
[1] "seed 21447 for j=174 out of 250 (i.e. j=924 in [751;1000], as job id is i=4)"
[1] "seed 46925 for j=175 out of 250 (i.e. j=925 in [751;1000], as job id is i=4)"
[1] "seed 48204 for j=176 out of 250 (i.e. j=926 in [751;1000], as job id is i=4)"
[1] "seed 27971 for j=177 out of 250 (i.e. j=927 in [751;1000], as job id is i=4)"
[1] "seed 93839 for j=178 out of 250 (i.e. j=928 in [751;1000], as job id is i=4)"
[1] "seed 33299 for j=179 out of 250 (i.e. j=929 in [751;1000], as job id is i=4)"
[1] "seed 40968 for j=180 out of 250 (i.e. j=930 in [751;1000], as job id is i=4)"
[1] "seed 52464 for j=181 out of 250 (i.e. j=931 in [751;1000], as job id is i=4)"
[1] "seed 12951 for j=182 out of 250 (i.e. j=932 in [751;1000], as job id is i=4)"
[1] "seed 97123 for j=183 out of 250 (i.e. j=933 in [751;1000], as job id is i=4)"
[1] "seed 38335 for j=184 out of 250 (i.e. j=934 in [751;1000], as job id is i=4)"
[1] "seed 60886 for j=185 out of 250 (i.e. j=935 in [751;1000], as job id is i=4)"
[1] "seed 27995 for j=186 out of 250 (i.e. j=936 in [751;1000], as job id is i=4)"
[1] "seed 20892 for j=187 out of 250 (i.e. j=937 in [751;1000], as job id is i=4)"
[1] "seed 17923 for j=188 out of 250 (i.e. j=938 in [751;1000], as job id is i=4)"
[1] "seed 47115 for j=189 out of 250 (i.e. j=939 in [751;1000], as job id is i=4)"
[1] "seed 66772 for j=190 out of 250 (i.e. j=940 in [751;1000], as job id is i=4)"
[1] "seed 54208 for j=191 out of 250 (i.e. j=941 in [751;1000], as job id is i=4)"
[1] "seed 73173 for j=192 out of 250 (i.e. j=942 in [751;1000], as job id is i=4)"
[1] "seed 24121 for j=193 out of 250 (i.e. j=943 in [751;1000], as job id is i=4)"
[1] "seed 46796 for j=194 out of 250 (i.e. j=944 in [751;1000], as job id is i=4)"
[1] "seed 50016 for j=195 out of 250 (i.e. j=945 in [751;1000], as job id is i=4)"
[1] "seed 68273 for j=196 out of 250 (i.e. j=946 in [751;1000], as job id is i=4)"
[1] "seed 28070 for j=197 out of 250 (i.e. j=947 in [751;1000], as job id is i=4)"
[1] "seed 39448 for j=198 out of 250 (i.e. j=948 in [751;1000], as job id is i=4)"
[1] "seed 44714 for j=199 out of 250 (i.e. j=949 in [751;1000], as job id is i=4)"
[1] "seed 16446 for j=200 out of 250 (i.e. j=950 in [751;1000], as job id is i=4)"
[1] "seed 91302 for j=201 out of 250 (i.e. j=951 in [751;1000], as job id is i=4)"
[1] "seed 39075 for j=202 out of 250 (i.e. j=952 in [751;1000], as job id is i=4)"
[1] "seed 66963 for j=203 out of 250 (i.e. j=953 in [751;1000], as job id is i=4)"
[1] "seed 26466 for j=204 out of 250 (i.e. j=954 in [751;1000], as job id is i=4)"
[1] "seed 98333 for j=205 out of 250 (i.e. j=955 in [751;1000], as job id is i=4)"
[1] "seed 67490 for j=206 out of 250 (i.e. j=956 in [751;1000], as job id is i=4)"
[1] "seed 76081 for j=207 out of 250 (i.e. j=957 in [751;1000], as job id is i=4)"
[1] "seed 29479 for j=208 out of 250 (i.e. j=958 in [751;1000], as job id is i=4)"
[1] "seed 86058 for j=209 out of 250 (i.e. j=959 in [751;1000], as job id is i=4)"
[1] "seed 72790 for j=210 out of 250 (i.e. j=960 in [751;1000], as job id is i=4)"
[1] "seed 69715 for j=211 out of 250 (i.e. j=961 in [751;1000], as job id is i=4)"
[1] "seed 12533 for j=212 out of 250 (i.e. j=962 in [751;1000], as job id is i=4)"
[1] "seed 54365 for j=213 out of 250 (i.e. j=963 in [751;1000], as job id is i=4)"
[1] "seed 55450 for j=214 out of 250 (i.e. j=964 in [751;1000], as job id is i=4)"
[1] "seed 29477 for j=215 out of 250 (i.e. j=965 in [751;1000], as job id is i=4)"
[1] "seed 17184 for j=216 out of 250 (i.e. j=966 in [751;1000], as job id is i=4)"
[1] "seed 97311 for j=217 out of 250 (i.e. j=967 in [751;1000], as job id is i=4)"
[1] "seed 93981 for j=218 out of 250 (i.e. j=968 in [751;1000], as job id is i=4)"
[1] "seed 42184 for j=219 out of 250 (i.e. j=969 in [751;1000], as job id is i=4)"
[1] "seed 34658 for j=220 out of 250 (i.e. j=970 in [751;1000], as job id is i=4)"
[1] "seed 70533 for j=221 out of 250 (i.e. j=971 in [751;1000], as job id is i=4)"
[1] "seed 61576 for j=222 out of 250 (i.e. j=972 in [751;1000], as job id is i=4)"
[1] "seed 28102 for j=223 out of 250 (i.e. j=973 in [751;1000], as job id is i=4)"
[1] "seed 62949 for j=224 out of 250 (i.e. j=974 in [751;1000], as job id is i=4)"
[1] "seed 23774 for j=225 out of 250 (i.e. j=975 in [751;1000], as job id is i=4)"
[1] "seed 33524 for j=226 out of 250 (i.e. j=976 in [751;1000], as job id is i=4)"
[1] "seed 37249 for j=227 out of 250 (i.e. j=977 in [751;1000], as job id is i=4)"
[1] "seed 78413 for j=228 out of 250 (i.e. j=978 in [751;1000], as job id is i=4)"
[1] "seed 89 for j=229 out of 250 (i.e. j=979 in [751;1000], as job id is i=4)"
[1] "seed 13696 for j=230 out of 250 (i.e. j=980 in [751;1000], as job id is i=4)"
[1] "seed 34589 for j=231 out of 250 (i.e. j=981 in [751;1000], as job id is i=4)"
[1] "seed 82117 for j=232 out of 250 (i.e. j=982 in [751;1000], as job id is i=4)"
[1] "seed 58702 for j=233 out of 250 (i.e. j=983 in [751;1000], as job id is i=4)"
[1] "seed 8940 for j=234 out of 250 (i.e. j=984 in [751;1000], as job id is i=4)"
[1] "seed 30157 for j=235 out of 250 (i.e. j=985 in [751;1000], as job id is i=4)"
[1] "seed 41861 for j=236 out of 250 (i.e. j=986 in [751;1000], as job id is i=4)"
[1] "seed 27605 for j=237 out of 250 (i.e. j=987 in [751;1000], as job id is i=4)"
[1] "seed 85707 for j=238 out of 250 (i.e. j=988 in [751;1000], as job id is i=4)"
[1] "seed 61691 for j=239 out of 250 (i.e. j=989 in [751;1000], as job id is i=4)"
[1] "seed 75689 for j=240 out of 250 (i.e. j=990 in [751;1000], as job id is i=4)"
[1] "seed 56616 for j=241 out of 250 (i.e. j=991 in [751;1000], as job id is i=4)"
[1] "seed 87262 for j=242 out of 250 (i.e. j=992 in [751;1000], as job id is i=4)"
[1] "seed 76149 for j=243 out of 250 (i.e. j=993 in [751;1000], as job id is i=4)"
[1] "seed 78803 for j=244 out of 250 (i.e. j=994 in [751;1000], as job id is i=4)"
[1] "seed 26877 for j=245 out of 250 (i.e. j=995 in [751;1000], as job id is i=4)"
[1] "seed 63053 for j=246 out of 250 (i.e. j=996 in [751;1000], as job id is i=4)"
[1] "seed 57647 for j=247 out of 250 (i.e. j=997 in [751;1000], as job id is i=4)"
[1] "seed 50523 for j=248 out of 250 (i.e. j=998 in [751;1000], as job id is i=4)"
[1] "seed 80016 for j=249 out of 250 (i.e. j=999 in [751;1000], as job id is i=4)"
[1] "seed 53755 for j=250 out of 250 (i.e. j=1000 in [751;1000], as job id is i=4)"
There were 18 warnings (use warnings() to see them)
> rownames(RES) <- NULL
> save(RES,file=paste0(path.res,name,"-",iter_sim,".rda"))
> 
> ## * Summary results
> sessionInfo()
R version 4.1.2 (2021-11-01)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux 8.5 (Ootpa)

Matrix products: default
BLAS:   /opt/software/R/4.1.2/lib64/R/lib/libRblas.so
LAPACK: /opt/software/R/4.1.2/lib64/R/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] mvtnorm_1.1-3    DelayedGSD_0.0.3

loaded via a namespace (and not attached):
 [1] BB_2019.10-1     magrittr_2.0.3   tidyselect_1.1.2 munsell_0.5.0   
 [5] lattice_0.20-45  colorspace_2.0-3 xtable_1.8-4     R6_2.5.1        
 [9] quadprog_1.5-8   rlang_1.0.3      fansi_1.0.3      dplyr_1.0.9     
[13] grid_4.1.2       nlme_3.1-153     gtable_0.3.0     gsDesign_3.3.0  
[17] utf8_1.2.2       cli_3.3.0        ellipsis_0.3.2   tibble_3.1.7    
[21] lifecycle_1.0.1  crayon_1.5.1     purrr_0.3.4      ggplot2_3.3.6   
[25] tidyr_1.2.0      vctrs_0.4.1      glue_1.6.2       compiler_4.1.2  
[29] pillar_1.7.0     generics_0.1.3   scales_1.2.0     pkgconfig_2.0.3 
> summary(RES)
     method        stage           type             statistic     
 Min.   :1.0   Min.   :1.000   Length:1500        Min.   :0.0002  
 1st Qu.:1.0   1st Qu.:1.000   Class :character   1st Qu.:1.6379  
 Median :1.5   Median :1.000   Mode  :character   Median :2.3642  
 Mean   :1.5   Mean   :1.333                      Mean   :2.2749  
 3rd Qu.:2.0   3rd Qu.:2.000                      3rd Qu.:2.9125  
 Max.   :2.0   Max.   :2.000                      Max.   :5.5967  
                                                  NA's   :500     
  estimate_ML          se_ML             info           infoPC      
 Min.   :-0.5001   Min.   :0.3354   Min.   :4.144   Min.   :0.3238  
 1st Qu.: 0.5791   1st Qu.:0.3886   1st Qu.:5.626   1st Qu.:0.4396  
 Median : 0.8155   Median :0.4073   Median :6.097   Median :0.4764  
 Mean   : 0.8089   Mean   :0.4073   Mean   :6.181   Mean   :0.4830  
 3rd Qu.: 1.0781   3rd Qu.:0.4235   3rd Qu.:6.653   3rd Qu.:0.5199  
 Max.   : 2.0911   Max.   :0.4912   Max.   :9.370   Max.   :0.7321  
 NA's   :500       NA's   :1000     NA's   :166     NA's   :166     
   info.pred      infoPC.pred           uk              lk         
 Min.   :4.585   Min.   :0.3583   Min.   :2.255   Min.   :-0.4055  
 1st Qu.:5.926   1st Qu.:0.4631   1st Qu.:2.473   1st Qu.: 0.1142  
 Median :6.412   Median :0.5011   Median :2.540   Median : 0.2625  
 Mean   :6.497   Mean   :0.5077   Mean   :2.535   Mean   : 0.2791  
 3rd Qu.:7.035   3rd Qu.:0.5498   3rd Qu.:2.594   3rd Qu.: 0.4472  
 Max.   :9.402   Max.   :0.7347   Max.   :2.792   Max.   : 1.0839  
 NA's   :1000    NA's   :1000     NA's   :1000    NA's   :1000     
   decision            reason            p.value_ML        lower_ML      
 Length:1500        Length:1500        Min.   :0.0000   Min.   :-0.8740  
 Class :character   Class :character   1st Qu.:0.0019   1st Qu.:-0.0353  
 Mode  :character   Mode  :character   Median :0.0095   Median : 0.1091  
                                       Mean   :0.0660   Mean   : 0.1005  
                                       3rd Qu.:0.0337   3rd Qu.: 0.2883  
                                       Max.   :0.9999   Max.   : 1.0335  
                                       NA's   :1000     NA's   :1000     
    upper_ML       p.value_MUE       lower_MUE         upper_MUE     
 Min.   :0.5298   Min.   :0.0000   Min.   :-0.8975   Min.   :0.8336  
 1st Qu.:1.2636   1st Qu.:0.0033   1st Qu.:-0.0494   1st Qu.:1.2682  
 Median :1.4779   Median :0.0073   Median : 0.0768   Median :1.4639  
 Mean   :1.5470   Mean   :0.0408   Mean   : 0.0859   Mean   :1.5695  
 3rd Qu.:1.8432   3rd Qu.:0.0191   3rd Qu.: 0.1911   3rd Qu.:1.8763  
 Max.   :2.6822   Max.   :1.0000   Max.   : 1.7177   Max.   :3.1609  
 NA's   :1000     NA's   :1000     NA's   :1000      NA's   :1000    
  estimate_MUE           ck          time.interim        seed      
 Min.   :-0.0001   Min.   :0.2501   Min.   :520.0   Min.   :   89  
 1st Qu.: 0.6124   1st Qu.:1.3847   1st Qu.:578.0   1st Qu.:27699  
 Median : 0.7854   Median :1.4351   Median :600.0   Median :48656  
 Mean   : 0.8326   Mean   :1.4184   Mean   :600.4   Mean   :49070  
 3rd Qu.: 1.0711   3rd Qu.:1.4893   3rd Qu.:621.0   3rd Qu.:72237  
 Max.   : 2.3361   Max.   :1.6976   Max.   :663.0   Max.   :99853  
 NA's   :1000      NA's   :666                                     
  nX1.interim     nX2.interim     nX3.interim    computation.time
 Min.   :145.0   Min.   :130.0   Min.   :119.0   Min.   :0.702   
 1st Qu.:147.0   1st Qu.:135.0   1st Qu.:125.0   1st Qu.:0.909   
 Median :148.0   Median :137.0   Median :127.0   Median :0.982   
 Mean   :148.6   Mean   :136.5   Mean   :126.8   Mean   :1.017   
 3rd Qu.:150.0   3rd Qu.:138.0   3rd Qu.:128.0   3rd Qu.:1.114   
 Max.   :154.0   Max.   :143.0   Max.   :135.0   Max.   :3.735   
                                                                 
> 
> #----------------------------------------------------------------------
> ### BATCH_simuMain.R ends here
> 
> proc.time()
   user  system elapsed 
256.703   0.420 267.962 
