
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### BATCH_simuMain.R --- 
> #----------------------------------------------------------------------
> ## Author: Paul Blanche
> ## Created: Mar  5 2021 (10:56) 
> ## Version: 
> ## Last-Updated: jul  7 2022 (13:56) 
> ##           By: Brice Ozenne
> ##     Update #: 518
> #----------------------------------------------------------------------
> ## 
> ### Commentary: 
> ## 
> ### Change Log:
> #----------------------------------------------------------------------
> ## 
> ### Code:
> 
> ## ** BATCH loop
> ## cd /projects/biostat01/people/hpl802/DelayedGSD/
> ## for ITER in `seq 1 10`;
> ## do
> ## eval 'R CMD BATCH --vanilla "--args iter_sim='$ITER' n.iter_sim=10" BATCH_simuMain.R output/R-simuMain-'$ITER'.Rout &'
> ## done
> 
> ## [1] 1186669
> ## [2] 1186670
> ## [3] 1186671
> ## [4] 1186672
> ## [5] 1186673
> ## [6] 1186674
> ## [7] 1186675
> ## [8] 1186676
> ## [9] 1186677
> ## [10] 1186678
> 
> rm(list=ls())
>                                    # {{{ parameters
> ## * parameters
> name <- "ScenarioName" # To save the results
> method <- 1:2 # methods used to compute the boundaries
>                                         #---
> myseed <- 140786598
>                                         #--- to plan the trial ----
> NMC <- 250 # number of sequential simulations to run in parallel. Eg. with 250, then we can run 40 scripts in paralell to get N=10,000 runs in total.
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.5,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.55  #(expected) information rate at each decision analysis
> binding <- TRUE
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.6,0.8) # treatment effect
> ar <- (0.86*2)*2 # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As to low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> Miss11 <- 5/104 # miss both V1 and V2
> Miss12 <- 1/104 # miss V1 and but not V2
> Miss21 <- 6/104 # do not miss V1 and but miss V2
> Miss22 <- 92/104 # miss none
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- abs(delta[3]) # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> n <- ceiling(2*2*((allsd[3]/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
>                                         # {{{ Set seeds for parallel computing and reproducibility
> ## * Seed
> args <- commandArgs(TRUE) ## BATCH MODE
> if(length(args)>0){
+     for (arg in args){
+         eval(parse(text=arg))
+     }
+ }else{ ## SLUMR
+     iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
+     n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
+ } ## interactive
> if(is.na(iter_sim)){iter_sim <- 1}
> if(is.na(n.iter_sim)){n.iter_sim <- 40}
> 
> set.seed(140786598)
> allseeds <- sample.int(n = 10*n.iter_sim*NMC, size = n.iter_sim*NMC, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> # }}}
> 
> # {{{ set path to load and save and othe machine specific variables
> ## * path
> path <- "."
> path.res <- file.path(path,"Results","simuMain")
> if(dir.exists(path.res)==FALSE){
+     if(dir.exists(file.path(path,"Results"))==FALSE){
+     dir.create(file.path(path,"Results"))
+     }
+     dir.create(path.res)
+ }
> path.output <- file.path(path,"output","simuMain")
> if(dir.exists(path.output)==FALSE){
+     if(dir.exists(file.path(path,"output"))==FALSE){
+     dir.create(file.path(path,"output"))
+     }
+     dir.create(path.output)
+ }
> # }}}
> 
> 
> ## * libraries and functions
> library(DelayedGSD)
DelayedGSD version 0.0.3
> ## sourceDir <- function(path, trace = TRUE, ...) {
> ##     for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
> ##         if(trace) cat(nm,":")
> ##         source(file.path(path, nm), ...)
> ##         if(trace) cat("\n")
> ##     }
> ## }
> ## sourceDir(pathToLoad)
>     
> 
> ## * Compute inflation factor and sample size
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+     plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                         alpha=alpha, 
+                                         beta=beta,  
+                                         InfoR.i=informationRates,  
+                                         InfoR.d=c(Id,1),  
+                                         rho_alpha=rho_alpha,  
+                                         rho_beta=rho_beta,  
+                                         method=iMeth,  
+                                         cNotBelowFixedc=FALSE,
+                                         bindingFutility=binding,
+                                         delta=tail(delta,1))
+     ## summary(plannedB[[1]])
+     ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> ##  plot(plannedB[[1]])
> 
> #
> # --- just to check---
> ## n
> ## InfoFixed <- ((qnorm(1-beta)-qnorm(alpha))/(deltaPower))^2
> ## InfoFixed
> ## n/(4*(allsd[3])^2)
> #---
> # }}}
> 
> 
> 
> 
> # {{{ technical details to loop
> RES <- NULL # initialize results to save
> allj <- ((iter_sim-1)*NMC + 1):(iter_sim*NMC) # indices of all iterations (replicates) for this job, accountng for the other jobs running in parallel
> # }}}
> 
> ## * Loop
> for(j in allj){ ## j <- 51 ## 5
+     startComp <- Sys.time()
+     myseedi <- allseeds[j]
+     # {{{ TRACE info (e.g. to check the Rout)
+     print(paste0("seed ",myseedi," for ","j=",which(j==allj)," out of ",NMC, " (i.e. j=",j," in [",(iter_sim-1)*NMC + 1,";",iter_sim*NMC,"], as job id is i=",iter_sim,")"))
+     # }}}
+     # {{{ Missing probabilities
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE) # to additionnally remove 1 more because some FASFL=N
+     colnames(MyMissProb) <- c("V2 missing","V2 not missing")
+     rownames(MyMissProb) <- c("V1 missing","V1 not missing")
+     # }}}
+ 
+                                         # {{{ generate data
+     ## ** simulate
+     res <- GenData(n=n, 
+                    N.fw=2,
+                    rand.block=block,
+                    allsd=allsd,
+                    mean0=mean0,
+                    delta=delta,
+                    ar=ar,
+                    cor.01.1=cor011,
+                    cor.ij.1=corij1,
+                    cor.0j.1=cor0j1,
+                    seed=myseedi,
+                    MissProb=MyMissProb,
+                    DigitsOutcome=2,
+                    TimeFactor=TimeFactor,
+                    DigitsTime=0
+                    )
+     d <- res$d
+     ## head(d,n=20)
+                                         # }}}
+                                         # {{{ reformat data like those of Corine
+     ## Make data long format
+     ## dd <- FormatAsCase(d)
+     ## head(dd)
+     ## summary(dd)
+                                         # }}}
+    
+                                         # {{{ make data available at interim
+                                         # Here we stop inclusion data collection for the interim analysis as soon as
+                                         # half of the participants have completed (or had the opportunity to complete) the follow-up 
+     thet <- d$t3[ceiling(n*PropForInterim)]
+     di <- SelectData(d,t=thet)
+     ## ddi <- FormatAsCase(di) # needed ????
+     ## head(d[d$id==52,])
+                                         # }}}
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thet + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     currentGSD <- vector(mode = "list", length = 3)
+     out.interim <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+ 
+         currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+ 
+         iConfint.interim <- confint(currentGSD[[iMeth]])
+         iInfo.interim <- coef(currentGSD[[iMeth]], type = "information")
+         iBoundary.interim <- coef(currentGSD[[iMeth]], type = "boundary")
+         iDecision.interim <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+         out.interim[[iMeth]] <-  data.frame(statistic = iConfint.interim[1,"statistic"],
+                                             estimate_ML = iConfint.interim[1,"estimate"],
+                                             se_ML = iConfint.interim[1,"se"],
+                                             info = iInfo.interim[1,"Interim"],
+                                             infoPC = iInfo.interim[1,"Interim.pc"],
+                                             info.pred = iInfo.interim[1,"Decision"],
+                                             infoPC.pred = iInfo.interim[1,"Decision.pc"],
+                                             uk = iBoundary.interim[1,"Ebound"],
+                                             lk = iBoundary.interim[1,"Fbound"],
+                                             decision = iDecision.interim["decision","stage 1"],
+                                             reason = iDecision.interim["reason.interim","stage 1"])
+     }
+     ## currentGSD[[1]]
+     ## plot(currentGSD[[1]])
+ 
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thet + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     out.decision <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+           
+         if(out.interim[[iMeth]]$decision == "stop"){
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+             ## plot(currentGSD[[iMeth]])
+ 
+             iConfint.decision <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.decision  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = iConfint.decision[1,"statistic"],
+                                                 p.value_ML = iConfint.decision[iConfint.decision$method == "ML","p.value"],
+                                                 lower_ML = iConfint.decision[iConfint.decision$method == "ML","lower"],
+                                                 upper_ML = iConfint.decision[iConfint.decision$method == "ML","upper"],
+                                                 estimate_ML = iConfint.decision[iConfint.decision$method == "ML","estimate"],
+                                                 p.value_MUE = iConfint.decision[iConfint.decision$method == "MUE","p.value"],
+                                                 lower_MUE = iConfint.decision[iConfint.decision$method == "MUE","lower"],
+                                                 upper_MUE = iConfint.decision[iConfint.decision$method == "MUE","upper"],
+                                                 estimate_MUE = iConfint.decision[iConfint.decision$method == "MUE","estimate"],
+                                                 info = iInfo.decision[1,"Interim"],
+                                                 infoPC = iInfo.decision[1,"Interim.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = unname(iDecision.decision["decision","stage 2"])
+                                                 )
+ 
+         }else{
+             ## update information
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+ 
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = NA,
+                                                 p.value_ML = NA,
+                                                 lower_ML = NA,
+                                                 upper_ML = NA,
+                                                 estimate_ML = NA,
+                                                 p.value_MUE = NA,
+                                                 lower_MUE = NA,
+                                                 upper_MUE = NA,
+                                                 estimate_MUE = NA,
+                                                 info = iInfo.decision[1,"Decision"],
+                                                 infoPC = iInfo.decision[1,"Decision.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = NA)
+         }
+     }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+ 
+     ## ** finale
+     dFinal <- d
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     out.final <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+         if(out.interim[[iMeth]]$decision == "stop"){
+             out.final[[iMeth]] <- data.frame(statistic = NA,
+                                              p.value_ML = NA,
+                                              lower_ML = NA,
+                                              upper_ML = NA,
+                                              estimate_ML = NA,
+                                              p.value_MUE = NA,
+                                              lower_MUE = NA,
+                                              upper_MUE = NA,
+                                              estimate_MUE = NA,
+                                              info = NA,
+                                              infoPC = NA,
+                                              ck = NA,
+                                              decision = NA)
+ 
+         }else{
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+ 
+             ## plot(test)
+             ## summary(test)
+             iConfint.final <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.final <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.final <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.final  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.final[[iMeth]] <- data.frame(statistic = iConfint.final[1,"statistic"],
+                                              p.value_ML = iConfint.final[iConfint.final$method == "ML","p.value"],
+                                              lower_ML = iConfint.final[iConfint.final$method == "ML","lower"],
+                                              upper_ML = iConfint.final[iConfint.final$method == "ML","upper"],
+                                              estimate_ML = iConfint.final[iConfint.final$method == "ML","estimate"],
+                                              p.value_MUE = iConfint.final[iConfint.final$method == "MUE","p.value"],
+                                              lower_MUE = iConfint.final[iConfint.final$method == "MUE","lower"],
+                                              upper_MUE = iConfint.final[iConfint.final$method == "MUE","upper"],
+                                              estimate_MUE = iConfint.final[iConfint.final$method == "MUE","estimate"],
+                                              info = iInfo.final[1,"Interim"],
+                                              infoPC = iInfo.final[1,"Interim.pc"],
+                                              ck = iBoundary.final[1,"Cbound"],
+                                              decision = unname(coef(currentGSD[[iMeth]], type = "decision")["decision","stage 2"])
+                                              )
+         }
+     }
+                                         # }}}
+ 
+     stopComp <- Sys.time()
+                                         # {{{ Save results
+ 
+     outMerge <- do.call(rbind,lapply(method, function(iMeth){
+         iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+         iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+         iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+         iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+         iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+         return(iMerge)
+     }))
+ 
+     ## outMerge[outMerge$method==3,]
+ 
+     out <- cbind(
+         ## results
+         outMerge,
+         ## simulation details
+         time.interim = thet,
+         seed=myseedi,             
+         nX1.interim = sum(!is.na(di$X1)),
+         nX2.interim = sum(!is.na(di$X2)),
+         nX3.interim = sum(!is.na(di$X3)),
+         ## computation time
+         computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+     )
+     ## names(out) <- myColNames
+     RES <- rbind(RES,out)
+     save(RES,file=paste0(path.res,name,"(tempo)-",iter_sim,".rda"))
+                                         # }}}
+ }
[1] "seed 60600 for j=1 out of 250 (i.e. j=1 in [1;250], as job id is i=1)"
Loading required namespace: nlme
[1] "seed 39943 for j=2 out of 250 (i.e. j=2 in [1;250], as job id is i=1)"
[1] "seed 16724 for j=3 out of 250 (i.e. j=3 in [1;250], as job id is i=1)"
[1] "seed 61339 for j=4 out of 250 (i.e. j=4 in [1;250], as job id is i=1)"
[1] "seed 49246 for j=5 out of 250 (i.e. j=5 in [1;250], as job id is i=1)"
[1] "seed 44942 for j=6 out of 250 (i.e. j=6 in [1;250], as job id is i=1)"
[1] "seed 96315 for j=7 out of 250 (i.e. j=7 in [1;250], as job id is i=1)"
[1] "seed 92549 for j=8 out of 250 (i.e. j=8 in [1;250], as job id is i=1)"
[1] "seed 73741 for j=9 out of 250 (i.e. j=9 in [1;250], as job id is i=1)"
[1] "seed 73194 for j=10 out of 250 (i.e. j=10 in [1;250], as job id is i=1)"
[1] "seed 89029 for j=11 out of 250 (i.e. j=11 in [1;250], as job id is i=1)"
[1] "seed 8694 for j=12 out of 250 (i.e. j=12 in [1;250], as job id is i=1)"
[1] "seed 49007 for j=13 out of 250 (i.e. j=13 in [1;250], as job id is i=1)"
[1] "seed 24823 for j=14 out of 250 (i.e. j=14 in [1;250], as job id is i=1)"
[1] "seed 7390 for j=15 out of 250 (i.e. j=15 in [1;250], as job id is i=1)"
[1] "seed 25437 for j=16 out of 250 (i.e. j=16 in [1;250], as job id is i=1)"
[1] "seed 62245 for j=17 out of 250 (i.e. j=17 in [1;250], as job id is i=1)"
[1] "seed 24681 for j=18 out of 250 (i.e. j=18 in [1;250], as job id is i=1)"
[1] "seed 21728 for j=19 out of 250 (i.e. j=19 in [1;250], as job id is i=1)"
[1] "seed 86273 for j=20 out of 250 (i.e. j=20 in [1;250], as job id is i=1)"
[1] "seed 52410 for j=21 out of 250 (i.e. j=21 in [1;250], as job id is i=1)"
[1] "seed 89295 for j=22 out of 250 (i.e. j=22 in [1;250], as job id is i=1)"
[1] "seed 85702 for j=23 out of 250 (i.e. j=23 in [1;250], as job id is i=1)"
[1] "seed 79729 for j=24 out of 250 (i.e. j=24 in [1;250], as job id is i=1)"
[1] "seed 77167 for j=25 out of 250 (i.e. j=25 in [1;250], as job id is i=1)"
[1] "seed 64909 for j=26 out of 250 (i.e. j=26 in [1;250], as job id is i=1)"
[1] "seed 40500 for j=27 out of 250 (i.e. j=27 in [1;250], as job id is i=1)"
[1] "seed 1950 for j=28 out of 250 (i.e. j=28 in [1;250], as job id is i=1)"
[1] "seed 38234 for j=29 out of 250 (i.e. j=29 in [1;250], as job id is i=1)"
[1] "seed 7555 for j=30 out of 250 (i.e. j=30 in [1;250], as job id is i=1)"
[1] "seed 63271 for j=31 out of 250 (i.e. j=31 in [1;250], as job id is i=1)"
[1] "seed 51173 for j=32 out of 250 (i.e. j=32 in [1;250], as job id is i=1)"
[1] "seed 92356 for j=33 out of 250 (i.e. j=33 in [1;250], as job id is i=1)"
[1] "seed 26271 for j=34 out of 250 (i.e. j=34 in [1;250], as job id is i=1)"
[1] "seed 65863 for j=35 out of 250 (i.e. j=35 in [1;250], as job id is i=1)"
[1] "seed 41029 for j=36 out of 250 (i.e. j=36 in [1;250], as job id is i=1)"
[1] "seed 27506 for j=37 out of 250 (i.e. j=37 in [1;250], as job id is i=1)"
[1] "seed 34780 for j=38 out of 250 (i.e. j=38 in [1;250], as job id is i=1)"
[1] "seed 55406 for j=39 out of 250 (i.e. j=39 in [1;250], as job id is i=1)"
[1] "seed 51283 for j=40 out of 250 (i.e. j=40 in [1;250], as job id is i=1)"
[1] "seed 28714 for j=41 out of 250 (i.e. j=41 in [1;250], as job id is i=1)"
[1] "seed 80734 for j=42 out of 250 (i.e. j=42 in [1;250], as job id is i=1)"
[1] "seed 62951 for j=43 out of 250 (i.e. j=43 in [1;250], as job id is i=1)"
[1] "seed 32877 for j=44 out of 250 (i.e. j=44 in [1;250], as job id is i=1)"
[1] "seed 65316 for j=45 out of 250 (i.e. j=45 in [1;250], as job id is i=1)"
[1] "seed 77333 for j=46 out of 250 (i.e. j=46 in [1;250], as job id is i=1)"
[1] "seed 95835 for j=47 out of 250 (i.e. j=47 in [1;250], as job id is i=1)"
[1] "seed 86016 for j=48 out of 250 (i.e. j=48 in [1;250], as job id is i=1)"
[1] "seed 24224 for j=49 out of 250 (i.e. j=49 in [1;250], as job id is i=1)"
[1] "seed 91329 for j=50 out of 250 (i.e. j=50 in [1;250], as job id is i=1)"
[1] "seed 19519 for j=51 out of 250 (i.e. j=51 in [1;250], as job id is i=1)"
[1] "seed 59249 for j=52 out of 250 (i.e. j=52 in [1;250], as job id is i=1)"
[1] "seed 46669 for j=53 out of 250 (i.e. j=53 in [1;250], as job id is i=1)"
[1] "seed 76824 for j=54 out of 250 (i.e. j=54 in [1;250], as job id is i=1)"
[1] "seed 12287 for j=55 out of 250 (i.e. j=55 in [1;250], as job id is i=1)"
[1] "seed 51596 for j=56 out of 250 (i.e. j=56 in [1;250], as job id is i=1)"
[1] "seed 4390 for j=57 out of 250 (i.e. j=57 in [1;250], as job id is i=1)"
[1] "seed 95751 for j=58 out of 250 (i.e. j=58 in [1;250], as job id is i=1)"
[1] "seed 28450 for j=59 out of 250 (i.e. j=59 in [1;250], as job id is i=1)"
[1] "seed 5044 for j=60 out of 250 (i.e. j=60 in [1;250], as job id is i=1)"
[1] "seed 58875 for j=61 out of 250 (i.e. j=61 in [1;250], as job id is i=1)"
[1] "seed 44410 for j=62 out of 250 (i.e. j=62 in [1;250], as job id is i=1)"
[1] "seed 31742 for j=63 out of 250 (i.e. j=63 in [1;250], as job id is i=1)"
[1] "seed 23280 for j=64 out of 250 (i.e. j=64 in [1;250], as job id is i=1)"
[1] "seed 84203 for j=65 out of 250 (i.e. j=65 in [1;250], as job id is i=1)"
[1] "seed 11570 for j=66 out of 250 (i.e. j=66 in [1;250], as job id is i=1)"
[1] "seed 73789 for j=67 out of 250 (i.e. j=67 in [1;250], as job id is i=1)"
[1] "seed 32677 for j=68 out of 250 (i.e. j=68 in [1;250], as job id is i=1)"
[1] "seed 87452 for j=69 out of 250 (i.e. j=69 in [1;250], as job id is i=1)"
[1] "seed 10336 for j=70 out of 250 (i.e. j=70 in [1;250], as job id is i=1)"
[1] "seed 86029 for j=71 out of 250 (i.e. j=71 in [1;250], as job id is i=1)"
[1] "seed 90626 for j=72 out of 250 (i.e. j=72 in [1;250], as job id is i=1)"
[1] "seed 5251 for j=73 out of 250 (i.e. j=73 in [1;250], as job id is i=1)"
[1] "seed 43438 for j=74 out of 250 (i.e. j=74 in [1;250], as job id is i=1)"
[1] "seed 75767 for j=75 out of 250 (i.e. j=75 in [1;250], as job id is i=1)"
[1] "seed 7829 for j=76 out of 250 (i.e. j=76 in [1;250], as job id is i=1)"
[1] "seed 7687 for j=77 out of 250 (i.e. j=77 in [1;250], as job id is i=1)"
[1] "seed 62774 for j=78 out of 250 (i.e. j=78 in [1;250], as job id is i=1)"
[1] "seed 36893 for j=79 out of 250 (i.e. j=79 in [1;250], as job id is i=1)"
[1] "seed 66642 for j=80 out of 250 (i.e. j=80 in [1;250], as job id is i=1)"
[1] "seed 5791 for j=81 out of 250 (i.e. j=81 in [1;250], as job id is i=1)"
[1] "seed 14826 for j=82 out of 250 (i.e. j=82 in [1;250], as job id is i=1)"
[1] "seed 82961 for j=83 out of 250 (i.e. j=83 in [1;250], as job id is i=1)"
[1] "seed 86803 for j=84 out of 250 (i.e. j=84 in [1;250], as job id is i=1)"
[1] "seed 44511 for j=85 out of 250 (i.e. j=85 in [1;250], as job id is i=1)"
[1] "seed 60098 for j=86 out of 250 (i.e. j=86 in [1;250], as job id is i=1)"
[1] "seed 26086 for j=87 out of 250 (i.e. j=87 in [1;250], as job id is i=1)"
[1] "seed 69048 for j=88 out of 250 (i.e. j=88 in [1;250], as job id is i=1)"
[1] "seed 25769 for j=89 out of 250 (i.e. j=89 in [1;250], as job id is i=1)"
[1] "seed 57915 for j=90 out of 250 (i.e. j=90 in [1;250], as job id is i=1)"
[1] "seed 80285 for j=91 out of 250 (i.e. j=91 in [1;250], as job id is i=1)"
[1] "seed 22887 for j=92 out of 250 (i.e. j=92 in [1;250], as job id is i=1)"
[1] "seed 39756 for j=93 out of 250 (i.e. j=93 in [1;250], as job id is i=1)"
[1] "seed 79102 for j=94 out of 250 (i.e. j=94 in [1;250], as job id is i=1)"
[1] "seed 96652 for j=95 out of 250 (i.e. j=95 in [1;250], as job id is i=1)"
[1] "seed 19558 for j=96 out of 250 (i.e. j=96 in [1;250], as job id is i=1)"
[1] "seed 18589 for j=97 out of 250 (i.e. j=97 in [1;250], as job id is i=1)"
[1] "seed 38298 for j=98 out of 250 (i.e. j=98 in [1;250], as job id is i=1)"
[1] "seed 71162 for j=99 out of 250 (i.e. j=99 in [1;250], as job id is i=1)"
[1] "seed 53902 for j=100 out of 250 (i.e. j=100 in [1;250], as job id is i=1)"
[1] "seed 51639 for j=101 out of 250 (i.e. j=101 in [1;250], as job id is i=1)"
[1] "seed 17210 for j=102 out of 250 (i.e. j=102 in [1;250], as job id is i=1)"
[1] "seed 97427 for j=103 out of 250 (i.e. j=103 in [1;250], as job id is i=1)"
[1] "seed 42440 for j=104 out of 250 (i.e. j=104 in [1;250], as job id is i=1)"
[1] "seed 20239 for j=105 out of 250 (i.e. j=105 in [1;250], as job id is i=1)"
[1] "seed 87091 for j=106 out of 250 (i.e. j=106 in [1;250], as job id is i=1)"
[1] "seed 1838 for j=107 out of 250 (i.e. j=107 in [1;250], as job id is i=1)"
[1] "seed 24452 for j=108 out of 250 (i.e. j=108 in [1;250], as job id is i=1)"
[1] "seed 24325 for j=109 out of 250 (i.e. j=109 in [1;250], as job id is i=1)"
[1] "seed 6275 for j=110 out of 250 (i.e. j=110 in [1;250], as job id is i=1)"
[1] "seed 34708 for j=111 out of 250 (i.e. j=111 in [1;250], as job id is i=1)"
[1] "seed 47826 for j=112 out of 250 (i.e. j=112 in [1;250], as job id is i=1)"
[1] "seed 79849 for j=113 out of 250 (i.e. j=113 in [1;250], as job id is i=1)"
[1] "seed 67348 for j=114 out of 250 (i.e. j=114 in [1;250], as job id is i=1)"
[1] "seed 25815 for j=115 out of 250 (i.e. j=115 in [1;250], as job id is i=1)"
[1] "seed 53336 for j=116 out of 250 (i.e. j=116 in [1;250], as job id is i=1)"
[1] "seed 80771 for j=117 out of 250 (i.e. j=117 in [1;250], as job id is i=1)"
[1] "seed 9126 for j=118 out of 250 (i.e. j=118 in [1;250], as job id is i=1)"
[1] "seed 30661 for j=119 out of 250 (i.e. j=119 in [1;250], as job id is i=1)"
[1] "seed 76002 for j=120 out of 250 (i.e. j=120 in [1;250], as job id is i=1)"
[1] "seed 51072 for j=121 out of 250 (i.e. j=121 in [1;250], as job id is i=1)"
[1] "seed 89546 for j=122 out of 250 (i.e. j=122 in [1;250], as job id is i=1)"
[1] "seed 81947 for j=123 out of 250 (i.e. j=123 in [1;250], as job id is i=1)"
[1] "seed 70558 for j=124 out of 250 (i.e. j=124 in [1;250], as job id is i=1)"
[1] "seed 41473 for j=125 out of 250 (i.e. j=125 in [1;250], as job id is i=1)"
[1] "seed 35607 for j=126 out of 250 (i.e. j=126 in [1;250], as job id is i=1)"
[1] "seed 98651 for j=127 out of 250 (i.e. j=127 in [1;250], as job id is i=1)"
[1] "seed 33286 for j=128 out of 250 (i.e. j=128 in [1;250], as job id is i=1)"
[1] "seed 20124 for j=129 out of 250 (i.e. j=129 in [1;250], as job id is i=1)"
[1] "seed 30352 for j=130 out of 250 (i.e. j=130 in [1;250], as job id is i=1)"
[1] "seed 39010 for j=131 out of 250 (i.e. j=131 in [1;250], as job id is i=1)"
[1] "seed 86191 for j=132 out of 250 (i.e. j=132 in [1;250], as job id is i=1)"
[1] "seed 7750 for j=133 out of 250 (i.e. j=133 in [1;250], as job id is i=1)"
[1] "seed 12662 for j=134 out of 250 (i.e. j=134 in [1;250], as job id is i=1)"
[1] "seed 91871 for j=135 out of 250 (i.e. j=135 in [1;250], as job id is i=1)"
[1] "seed 16847 for j=136 out of 250 (i.e. j=136 in [1;250], as job id is i=1)"
[1] "seed 35352 for j=137 out of 250 (i.e. j=137 in [1;250], as job id is i=1)"
[1] "seed 9595 for j=138 out of 250 (i.e. j=138 in [1;250], as job id is i=1)"
[1] "seed 54563 for j=139 out of 250 (i.e. j=139 in [1;250], as job id is i=1)"
[1] "seed 42096 for j=140 out of 250 (i.e. j=140 in [1;250], as job id is i=1)"
[1] "seed 57075 for j=141 out of 250 (i.e. j=141 in [1;250], as job id is i=1)"
[1] "seed 25121 for j=142 out of 250 (i.e. j=142 in [1;250], as job id is i=1)"
[1] "seed 18626 for j=143 out of 250 (i.e. j=143 in [1;250], as job id is i=1)"
[1] "seed 78583 for j=144 out of 250 (i.e. j=144 in [1;250], as job id is i=1)"
[1] "seed 96906 for j=145 out of 250 (i.e. j=145 in [1;250], as job id is i=1)"
[1] "seed 68190 for j=146 out of 250 (i.e. j=146 in [1;250], as job id is i=1)"
[1] "seed 11720 for j=147 out of 250 (i.e. j=147 in [1;250], as job id is i=1)"
[1] "seed 18039 for j=148 out of 250 (i.e. j=148 in [1;250], as job id is i=1)"
[1] "seed 15725 for j=149 out of 250 (i.e. j=149 in [1;250], as job id is i=1)"
[1] "seed 66938 for j=150 out of 250 (i.e. j=150 in [1;250], as job id is i=1)"
[1] "seed 15330 for j=151 out of 250 (i.e. j=151 in [1;250], as job id is i=1)"
[1] "seed 4081 for j=152 out of 250 (i.e. j=152 in [1;250], as job id is i=1)"
[1] "seed 6203 for j=153 out of 250 (i.e. j=153 in [1;250], as job id is i=1)"
[1] "seed 4836 for j=154 out of 250 (i.e. j=154 in [1;250], as job id is i=1)"
[1] "seed 44892 for j=155 out of 250 (i.e. j=155 in [1;250], as job id is i=1)"
[1] "seed 43328 for j=156 out of 250 (i.e. j=156 in [1;250], as job id is i=1)"
[1] "seed 85664 for j=157 out of 250 (i.e. j=157 in [1;250], as job id is i=1)"
[1] "seed 12263 for j=158 out of 250 (i.e. j=158 in [1;250], as job id is i=1)"
[1] "seed 66230 for j=159 out of 250 (i.e. j=159 in [1;250], as job id is i=1)"
[1] "seed 41515 for j=160 out of 250 (i.e. j=160 in [1;250], as job id is i=1)"
[1] "seed 74565 for j=161 out of 250 (i.e. j=161 in [1;250], as job id is i=1)"
[1] "seed 52544 for j=162 out of 250 (i.e. j=162 in [1;250], as job id is i=1)"
[1] "seed 24233 for j=163 out of 250 (i.e. j=163 in [1;250], as job id is i=1)"
[1] "seed 98503 for j=164 out of 250 (i.e. j=164 in [1;250], as job id is i=1)"
[1] "seed 36076 for j=165 out of 250 (i.e. j=165 in [1;250], as job id is i=1)"
[1] "seed 73978 for j=166 out of 250 (i.e. j=166 in [1;250], as job id is i=1)"
[1] "seed 30398 for j=167 out of 250 (i.e. j=167 in [1;250], as job id is i=1)"
[1] "seed 16203 for j=168 out of 250 (i.e. j=168 in [1;250], as job id is i=1)"
[1] "seed 19658 for j=169 out of 250 (i.e. j=169 in [1;250], as job id is i=1)"
[1] "seed 75113 for j=170 out of 250 (i.e. j=170 in [1;250], as job id is i=1)"
[1] "seed 87890 for j=171 out of 250 (i.e. j=171 in [1;250], as job id is i=1)"
[1] "seed 23131 for j=172 out of 250 (i.e. j=172 in [1;250], as job id is i=1)"
[1] "seed 83785 for j=173 out of 250 (i.e. j=173 in [1;250], as job id is i=1)"
[1] "seed 38032 for j=174 out of 250 (i.e. j=174 in [1;250], as job id is i=1)"
[1] "seed 24277 for j=175 out of 250 (i.e. j=175 in [1;250], as job id is i=1)"
[1] "seed 21345 for j=176 out of 250 (i.e. j=176 in [1;250], as job id is i=1)"
[1] "seed 64429 for j=177 out of 250 (i.e. j=177 in [1;250], as job id is i=1)"
[1] "seed 75393 for j=178 out of 250 (i.e. j=178 in [1;250], as job id is i=1)"
[1] "seed 28398 for j=179 out of 250 (i.e. j=179 in [1;250], as job id is i=1)"
[1] "seed 46191 for j=180 out of 250 (i.e. j=180 in [1;250], as job id is i=1)"
[1] "seed 78061 for j=181 out of 250 (i.e. j=181 in [1;250], as job id is i=1)"
[1] "seed 94739 for j=182 out of 250 (i.e. j=182 in [1;250], as job id is i=1)"
[1] "seed 89395 for j=183 out of 250 (i.e. j=183 in [1;250], as job id is i=1)"
[1] "seed 34612 for j=184 out of 250 (i.e. j=184 in [1;250], as job id is i=1)"
[1] "seed 22348 for j=185 out of 250 (i.e. j=185 in [1;250], as job id is i=1)"
[1] "seed 66454 for j=186 out of 250 (i.e. j=186 in [1;250], as job id is i=1)"
[1] "seed 871 for j=187 out of 250 (i.e. j=187 in [1;250], as job id is i=1)"
[1] "seed 39118 for j=188 out of 250 (i.e. j=188 in [1;250], as job id is i=1)"
[1] "seed 64199 for j=189 out of 250 (i.e. j=189 in [1;250], as job id is i=1)"
[1] "seed 80205 for j=190 out of 250 (i.e. j=190 in [1;250], as job id is i=1)"
[1] "seed 27661 for j=191 out of 250 (i.e. j=191 in [1;250], as job id is i=1)"
[1] "seed 92818 for j=192 out of 250 (i.e. j=192 in [1;250], as job id is i=1)"
[1] "seed 54194 for j=193 out of 250 (i.e. j=193 in [1;250], as job id is i=1)"
[1] "seed 30617 for j=194 out of 250 (i.e. j=194 in [1;250], as job id is i=1)"
[1] "seed 63013 for j=195 out of 250 (i.e. j=195 in [1;250], as job id is i=1)"
[1] "seed 4006 for j=196 out of 250 (i.e. j=196 in [1;250], as job id is i=1)"
[1] "seed 72709 for j=197 out of 250 (i.e. j=197 in [1;250], as job id is i=1)"
[1] "seed 96020 for j=198 out of 250 (i.e. j=198 in [1;250], as job id is i=1)"
[1] "seed 51540 for j=199 out of 250 (i.e. j=199 in [1;250], as job id is i=1)"
[1] "seed 36550 for j=200 out of 250 (i.e. j=200 in [1;250], as job id is i=1)"
[1] "seed 9907 for j=201 out of 250 (i.e. j=201 in [1;250], as job id is i=1)"
[1] "seed 57618 for j=202 out of 250 (i.e. j=202 in [1;250], as job id is i=1)"
[1] "seed 22100 for j=203 out of 250 (i.e. j=203 in [1;250], as job id is i=1)"
[1] "seed 78252 for j=204 out of 250 (i.e. j=204 in [1;250], as job id is i=1)"
[1] "seed 6870 for j=205 out of 250 (i.e. j=205 in [1;250], as job id is i=1)"
[1] "seed 57587 for j=206 out of 250 (i.e. j=206 in [1;250], as job id is i=1)"
[1] "seed 67408 for j=207 out of 250 (i.e. j=207 in [1;250], as job id is i=1)"
[1] "seed 46568 for j=208 out of 250 (i.e. j=208 in [1;250], as job id is i=1)"
[1] "seed 96981 for j=209 out of 250 (i.e. j=209 in [1;250], as job id is i=1)"
[1] "seed 55042 for j=210 out of 250 (i.e. j=210 in [1;250], as job id is i=1)"
[1] "seed 52174 for j=211 out of 250 (i.e. j=211 in [1;250], as job id is i=1)"
[1] "seed 35284 for j=212 out of 250 (i.e. j=212 in [1;250], as job id is i=1)"
[1] "seed 20507 for j=213 out of 250 (i.e. j=213 in [1;250], as job id is i=1)"
[1] "seed 77277 for j=214 out of 250 (i.e. j=214 in [1;250], as job id is i=1)"
[1] "seed 73918 for j=215 out of 250 (i.e. j=215 in [1;250], as job id is i=1)"
[1] "seed 65045 for j=216 out of 250 (i.e. j=216 in [1;250], as job id is i=1)"
[1] "seed 4713 for j=217 out of 250 (i.e. j=217 in [1;250], as job id is i=1)"
[1] "seed 13816 for j=218 out of 250 (i.e. j=218 in [1;250], as job id is i=1)"
[1] "seed 15273 for j=219 out of 250 (i.e. j=219 in [1;250], as job id is i=1)"
[1] "seed 39757 for j=220 out of 250 (i.e. j=220 in [1;250], as job id is i=1)"
[1] "seed 27349 for j=221 out of 250 (i.e. j=221 in [1;250], as job id is i=1)"
[1] "seed 97514 for j=222 out of 250 (i.e. j=222 in [1;250], as job id is i=1)"
[1] "seed 40519 for j=223 out of 250 (i.e. j=223 in [1;250], as job id is i=1)"
[1] "seed 36232 for j=224 out of 250 (i.e. j=224 in [1;250], as job id is i=1)"
[1] "seed 86314 for j=225 out of 250 (i.e. j=225 in [1;250], as job id is i=1)"
[1] "seed 50968 for j=226 out of 250 (i.e. j=226 in [1;250], as job id is i=1)"
[1] "seed 55048 for j=227 out of 250 (i.e. j=227 in [1;250], as job id is i=1)"
[1] "seed 66709 for j=228 out of 250 (i.e. j=228 in [1;250], as job id is i=1)"
[1] "seed 45723 for j=229 out of 250 (i.e. j=229 in [1;250], as job id is i=1)"
[1] "seed 9594 for j=230 out of 250 (i.e. j=230 in [1;250], as job id is i=1)"
[1] "seed 18742 for j=231 out of 250 (i.e. j=231 in [1;250], as job id is i=1)"
[1] "seed 84946 for j=232 out of 250 (i.e. j=232 in [1;250], as job id is i=1)"
[1] "seed 19405 for j=233 out of 250 (i.e. j=233 in [1;250], as job id is i=1)"
[1] "seed 69779 for j=234 out of 250 (i.e. j=234 in [1;250], as job id is i=1)"
[1] "seed 35446 for j=235 out of 250 (i.e. j=235 in [1;250], as job id is i=1)"
[1] "seed 2288 for j=236 out of 250 (i.e. j=236 in [1;250], as job id is i=1)"
[1] "seed 3991 for j=237 out of 250 (i.e. j=237 in [1;250], as job id is i=1)"
[1] "seed 28943 for j=238 out of 250 (i.e. j=238 in [1;250], as job id is i=1)"
[1] "seed 85247 for j=239 out of 250 (i.e. j=239 in [1;250], as job id is i=1)"
[1] "seed 52807 for j=240 out of 250 (i.e. j=240 in [1;250], as job id is i=1)"
[1] "seed 79422 for j=241 out of 250 (i.e. j=241 in [1;250], as job id is i=1)"
[1] "seed 16554 for j=242 out of 250 (i.e. j=242 in [1;250], as job id is i=1)"
[1] "seed 1454 for j=243 out of 250 (i.e. j=243 in [1;250], as job id is i=1)"
[1] "seed 84103 for j=244 out of 250 (i.e. j=244 in [1;250], as job id is i=1)"
[1] "seed 86396 for j=245 out of 250 (i.e. j=245 in [1;250], as job id is i=1)"
[1] "seed 84367 for j=246 out of 250 (i.e. j=246 in [1;250], as job id is i=1)"
[1] "seed 46541 for j=247 out of 250 (i.e. j=247 in [1;250], as job id is i=1)"
[1] "seed 64691 for j=248 out of 250 (i.e. j=248 in [1;250], as job id is i=1)"
[1] "seed 27643 for j=249 out of 250 (i.e. j=249 in [1;250], as job id is i=1)"
[1] "seed 60436 for j=250 out of 250 (i.e. j=250 in [1;250], as job id is i=1)"
There were 12 warnings (use warnings() to see them)
> rownames(RES) <- NULL
> save(RES,file=paste0(path.res,name,"-",iter_sim,".rda"))
> 
> ## * Summary results
> sessionInfo()
R version 4.1.2 (2021-11-01)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux 8.5 (Ootpa)

Matrix products: default
BLAS:   /opt/software/R/4.1.2/lib64/R/lib/libRblas.so
LAPACK: /opt/software/R/4.1.2/lib64/R/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] mvtnorm_1.1-3    DelayedGSD_0.0.3

loaded via a namespace (and not attached):
 [1] BB_2019.10-1     magrittr_2.0.3   tidyselect_1.1.2 munsell_0.5.0   
 [5] lattice_0.20-45  colorspace_2.0-3 xtable_1.8-4     R6_2.5.1        
 [9] quadprog_1.5-8   rlang_1.0.3      fansi_1.0.3      dplyr_1.0.9     
[13] grid_4.1.2       nlme_3.1-153     gtable_0.3.0     gsDesign_3.3.0  
[17] utf8_1.2.2       cli_3.3.0        ellipsis_0.3.2   tibble_3.1.7    
[21] lifecycle_1.0.1  crayon_1.5.1     purrr_0.3.4      ggplot2_3.3.6   
[25] tidyr_1.2.0      vctrs_0.4.1      glue_1.6.2       compiler_4.1.2  
[29] pillar_1.7.0     generics_0.1.3   scales_1.2.0     pkgconfig_2.0.3 
> summary(RES)
     method        stage           type             statistic     
 Min.   :1.0   Min.   :1.000   Length:1500        Min.   :0.0058  
 1st Qu.:1.0   1st Qu.:1.000   Class :character   1st Qu.:1.6300  
 Median :1.5   Median :1.000   Mode  :character   Median :2.3059  
 Mean   :1.5   Mean   :1.333                      Mean   :2.3115  
 3rd Qu.:2.0   3rd Qu.:2.000                      3rd Qu.:3.0546  
 Max.   :2.0   Max.   :2.000                      Max.   :5.1238  
                                                  NA's   :500     
  estimate_ML          se_ML             info            infoPC      
 Min.   :-0.3644   Min.   :0.3150   Min.   : 4.344   Min.   :0.3394  
 1st Qu.: 0.5654   1st Qu.:0.3858   1st Qu.: 5.720   1st Qu.:0.4469  
 Median : 0.8047   Median :0.4041   Median : 6.196   Median :0.4842  
 Mean   : 0.8217   Mean   :0.4035   Mean   : 6.298   Mean   :0.4922  
 3rd Qu.: 1.1048   3rd Qu.:0.4214   3rd Qu.: 6.799   3rd Qu.:0.5312  
 Max.   : 2.0729   Max.   :0.4798   Max.   :10.352   Max.   :0.8089  
 NA's   :500       NA's   :1000     NA's   :170      NA's   :170     
   info.pred       infoPC.pred           uk              lk         
 Min.   : 4.609   Min.   :0.3602   Min.   :2.157   Min.   :-0.3274  
 1st Qu.: 5.990   1st Qu.:0.4681   1st Qu.:2.463   1st Qu.: 0.1327  
 Median : 6.520   Median :0.5095   Median :2.529   Median : 0.2929  
 Mean   : 6.608   Mean   :0.5164   Mean   :2.522   Mean   : 0.3139  
 3rd Qu.: 7.117   3rd Qu.:0.5561   3rd Qu.:2.587   3rd Qu.: 0.4769  
 Max.   :10.730   Max.   :0.8384   Max.   :2.761   Max.   : 1.3898  
 NA's   :1000     NA's   :1000     NA's   :1000    NA's   :1000     
   decision            reason            p.value_ML        lower_ML      
 Length:1500        Length:1500        Min.   :0.0000   Min.   :-0.9771  
 Class :character   Class :character   1st Qu.:0.0008   1st Qu.:-0.0740  
 Mode  :character   Mode  :character   Median :0.0062   Median : 0.1599  
                                       Mean   :0.0752   Mean   : 0.1268  
                                       3rd Qu.:0.0480   3rd Qu.: 0.3853  
                                       Max.   :0.9535   Max.   : 1.0786  
                                       NA's   :1000     NA's   :1000     
    upper_ML       p.value_MUE       lower_MUE         upper_MUE     
 Min.   :0.6987   Min.   :0.0000   Min.   :-0.9726   Min.   :0.6941  
 1st Qu.:1.2092   1st Qu.:0.0027   1st Qu.:-0.0853   1st Qu.:1.2124  
 Median :1.4922   Median :0.0073   Median : 0.0731   Median :1.4683  
 Mean   :1.5698   Mean   :0.0427   Mean   : 0.0756   Mean   :1.5681  
 3rd Qu.:1.8890   3rd Qu.:0.0260   3rd Qu.: 0.2063   3rd Qu.:1.8662  
 Max.   :2.8095   Max.   :0.7015   Max.   : 1.6963   Max.   :3.1233  
 NA's   :1000     NA's   :1000     NA's   :1000      NA's   :1000    
  estimate_MUE           ck          time.interim        seed      
 Min.   :-0.1393   Min.   :0.1247   Min.   :527.0   Min.   :  871  
 1st Qu.: 0.5703   1st Qu.:1.3980   1st Qu.:582.0   1st Qu.:24233  
 Median : 0.8054   Median :1.4474   Median :600.5   Median :46554  
 Mean   : 0.8337   Mean   :1.4335   Mean   :601.5   Mean   :48406  
 3rd Qu.: 1.0524   3rd Qu.:1.5119   3rd Qu.:619.0   3rd Qu.:73978  
 Max.   : 2.3078   Max.   :1.7921   Max.   :669.0   Max.   :98651  
 NA's   :1000      NA's   :670                                     
  nX1.interim     nX2.interim     nX3.interim    computation.time
 Min.   :145.0   Min.   :131.0   Min.   :119.0   Min.   :0.704   
 1st Qu.:148.0   1st Qu.:135.0   1st Qu.:125.0   1st Qu.:0.912   
 Median :149.0   Median :137.0   Median :127.0   Median :0.988   
 Mean   :148.7   Mean   :136.6   Mean   :127.1   Mean   :1.026   
 3rd Qu.:149.0   3rd Qu.:138.0   3rd Qu.:129.0   3rd Qu.:1.146   
 Max.   :154.0   Max.   :141.0   Max.   :134.0   Max.   :3.567   
                                                                 
> 
> #----------------------------------------------------------------------
> ### BATCH_simuMain.R ends here
> 
> proc.time()
   user  system elapsed 
259.576   0.431 270.970 
