
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### BATCH_simuMain.R --- 
> #----------------------------------------------------------------------
> ## Author: Paul Blanche
> ## Created: Mar  5 2021 (10:56) 
> ## Version: 
> ## Last-Updated: maj  6 2022 (10:22) 
> ##           By: Brice Ozenne
> ##     Update #: 512
> #----------------------------------------------------------------------
> ## 
> ### Commentary: 
> ## 
> ### Change Log:
> #----------------------------------------------------------------------
> ## 
> ### Code:
> 
> rm(list=ls())
>                                    # {{{ parameters
> ## * parameters
> name <- "ScenarioName" # To save the results
> method <- 1:2 # methods used to compute the boundaries
>                                         #---
> myseed <- 140786598
>                                         #--- to plan the trial ----
> NMC <- 250 # number of sequential simulations to run in parallel. Eg. with 250, then we can run 40 scripts in paralell to get N=10,000 runs in total.
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.5,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.55  #(expected) information rate at each decision analysis
> binding <- TRUE
>                                         #
>                                         #---- to generate data -----------
>                                         #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.6,0.8) # treatment effect
> ar <- (0.86*2)*2 # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As to low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> Miss11 <- 5/104 # miss both V1 and V2
> Miss12 <- 1/104 # miss V1 and but not V2
> Miss21 <- 6/104 # do not miss V1 and but miss V2
> Miss22 <- 92/104 # miss none
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
>                                         #
>                                         #--- actually for both planing the trial  and generating data-----
>                                         #
>                                         #
> deltaPower <- abs(delta[3]) # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> n <- ceiling(2*2*((allsd[3]/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
>                                         # inflate SS as required for interim
> 
> # {{{ Set seeds for parallel computing and reproducibility
> ## * Seed
> iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
> n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
> if(is.na(iter_sim)){iter_sim <- 2}
> if(is.na(n.iter_sim)){n.iter_sim <- 10}
> 
> set.seed(140786598)
> allseeds <- sample.int(n = 10*n.iter_sim*NMC, size = n.iter_sim*NMC, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> # }}}
> 
> # {{{ set path to load and save and othe machine specific variables
> ## * path
> path <- "."
> path.res <- file.path(path,"Results","simuMain")
> if(dir.exists(path.res)==FALSE){
+     if(dir.exists(file.path(path,"Results"))==FALSE){
+     dir.create(file.path(path,"Results"))
+     }
+     dir.create(path.res)
+ }
> path.output <- file.path(path,"output","simuMain")
> if(dir.exists(path.output)==FALSE){
+     if(dir.exists(file.path(path,"output"))==FALSE){
+     dir.create(file.path(path,"output"))
+     }
+     dir.create(path.output)
+ }
> # }}}
> 
> 
> ## * libraries and functions
> library(DelayedGSD)
DelayedGSD version 0.0.2
> ## sourceDir <- function(path, trace = TRUE, ...) {
> ##     for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
> ##         if(trace) cat(nm,":")
> ##         source(file.path(path, nm), ...)
> ##         if(trace) cat("\n")
> ##     }
> ## }
> ## sourceDir(pathToLoad)
>     
> 
> ## * Compute inflation factor and sample size
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+     plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                         alpha=alpha, 
+                                         beta=beta,  
+                                         InfoR.i=informationRates,  
+                                         InfoR.d=c(Id,1),  
+                                         rho_alpha=rho_alpha,  
+                                         rho_beta=rho_beta,  
+                                         method=iMeth,  
+                                         cNotBelowFixedc=FALSE,
+                                         bindingFutility=binding,
+                                         delta=tail(delta,1))
+     ## summary(plannedB[[1]])
+     ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> ##  plot(plannedB[[1]])
> 
> #
> # --- just to check---
> ## n
> ## InfoFixed <- ((qnorm(1-beta)-qnorm(alpha))/(deltaPower))^2
> ## InfoFixed
> ## n/(4*(allsd[3])^2)
> #---
> # }}}
> 
> 
> 
> 
> # {{{ technical details to loop
> RES <- NULL # initialize results to save
> allj <- ((iter_sim-1)*NMC + 1):(iter_sim*NMC) # indices of all iterations (replicates) for this job, accountng for the other jobs running in parallel
> # }}}
> 
> ## * Loop
> for(j in allj){ ## j <- 5 ## 5
+     startComp <- Sys.time()
+     myseedi <- allseeds[j]
+     # {{{ TRACE info (e.g. to check the Rout)
+     print(paste0("seed ",myseedi," for ","j=",which(j==allj)," out of ",NMC, " (i.e. j=",j," in [",(iter_sim-1)*NMC + 1,";",iter_sim*NMC,"], as job id is i=",iter_sim,")"))
+     # }}}
+     # {{{ Missing probabilities
+     MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE) # to additionnally remove 1 more because some FASFL=N
+     colnames(MyMissProb) <- c("V2 missing","V2 not missing")
+     rownames(MyMissProb) <- c("V1 missing","V1 not missing")
+     # }}}
+ 
+                                         # {{{ generate data
+     ## ** simulate
+     res <- GenData(n=n, 
+                    N.fw=2,
+                    rand.block=block,
+                    allsd=allsd,
+                    mean0=mean0,
+                    delta=delta,
+                    ar=ar,
+                    cor.01.1=cor011,
+                    cor.ij.1=corij1,
+                    cor.0j.1=cor0j1,
+                    seed=myseedi,
+                    MissProb=MyMissProb,
+                    DigitsOutcome=2,
+                    TimeFactor=TimeFactor,
+                    DigitsTime=0
+                    )
+     d <- res$d
+     ## head(d,n=20)
+                                         # }}}
+                                         # {{{ reformat data like those of Corine
+     ## Make data long format
+     ## dd <- FormatAsCase(d)
+     ## head(dd)
+     ## summary(dd)
+                                         # }}}
+    
+                                         # {{{ make data available at interim
+                                         # Here we stop inclusion data collection for the interim analysis as soon as
+                                         # half of the participants have completed (or had the opportunity to complete) the follow-up 
+     thet <- d$t3[ceiling(n*PropForInterim)]
+     di <- SelectData(d,t=thet)
+     ## ddi <- FormatAsCase(di) # needed ????
+     ## head(d[d$id==52,])
+                                         # }}}
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thet + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     currentGSD <- vector(mode = "list", length = 3)
+     out.interim <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+ 
+         currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+ 
+         iConfint.interim <- confint(currentGSD[[iMeth]])
+         iInfo.interim <- coef(currentGSD[[iMeth]], type = "information")
+         iBoundary.interim <- coef(currentGSD[[iMeth]], type = "boundary")
+         iDecision.interim <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+         out.interim[[iMeth]] <-  data.frame(statistic = iConfint.interim[1,"statistic"],
+                                             estimate_ML = iConfint.interim[1,"estimate"],
+                                             se_ML = iConfint.interim[1,"se"],
+                                             info = iInfo.interim[1,"Interim"],
+                                             infoPC = iInfo.interim[1,"Interim.pc"],
+                                             info.pred = iInfo.interim[1,"Decision"],
+                                             infoPC.pred = iInfo.interim[1,"Decision.pc"],
+                                             uk = iBoundary.interim[1,"Ebound"],
+                                             lk = iBoundary.interim[1,"Fbound"],
+                                             decision = iDecision.interim["decision","stage 1"],
+                                             reason = iDecision.interim["reason.interim","stage 1"])
+     }
+     ## currentGSD[[1]]
+     ## plot(currentGSD[[1]])
+ 
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thet + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     out.decision <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+           
+         if(out.interim[[iMeth]]$decision == "stop"){
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+             ## plot(currentGSD[[iMeth]])
+ 
+             iConfint.decision <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.decision  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = iConfint.decision[1,"statistic"],
+                                                 p.value_ML = iConfint.decision[iConfint.decision$method == "ML","p.value"],
+                                                 lower_ML = iConfint.decision[iConfint.decision$method == "ML","lower"],
+                                                 upper_ML = iConfint.decision[iConfint.decision$method == "ML","upper"],
+                                                 estimate_ML = iConfint.decision[iConfint.decision$method == "ML","estimate"],
+                                                 p.value_MUE = iConfint.decision[iConfint.decision$method == "MUE","p.value"],
+                                                 lower_MUE = iConfint.decision[iConfint.decision$method == "MUE","lower"],
+                                                 upper_MUE = iConfint.decision[iConfint.decision$method == "MUE","upper"],
+                                                 estimate_MUE = iConfint.decision[iConfint.decision$method == "MUE","estimate"],
+                                                 info = iInfo.decision[1,"Interim"],
+                                                 infoPC = iInfo.decision[1,"Interim.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = unname(iDecision.decision["decision","stage 2"])
+                                                 )
+ 
+         }else{
+             ## update information
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+ 
+             iInfo.decision <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.decision <- coef(currentGSD[[iMeth]], type = "boundary")
+ 
+             out.decision[[iMeth]] <- data.frame(statistic = NA,
+                                                 p.value_ML = NA,
+                                                 lower_ML = NA,
+                                                 upper_ML = NA,
+                                                 estimate_ML = NA,
+                                                 p.value_MUE = NA,
+                                                 lower_MUE = NA,
+                                                 upper_MUE = NA,
+                                                 estimate_MUE = NA,
+                                                 info = iInfo.decision[1,"Decision"],
+                                                 infoPC = iInfo.decision[1,"Decision.pc"],
+                                                 ck = iBoundary.decision[1,"Cbound"],
+                                                 decision = NA)
+         }
+     }
+                                         # }}}
+                                         # {{{ Analyze data at decision
+ 
+     ## ** finale
+     dFinal <- d
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+ 
+     out.final <- vector(mode = "list", length = 3)
+     for(iMeth in method){ ## iMeth <- 1
+         if(out.interim[[iMeth]]$decision == "stop"){
+             out.final[[iMeth]] <- data.frame(statistic = NA,
+                                              p.value_ML = NA,
+                                              lower_ML = NA,
+                                              upper_ML = NA,
+                                              estimate_ML = NA,
+                                              p.value_MUE = NA,
+                                              lower_MUE = NA,
+                                              upper_MUE = NA,
+                                              estimate_MUE = NA,
+                                              info = NA,
+                                              infoPC = NA,
+                                              ck = NA,
+                                              decision = NA)
+ 
+         }else{
+             currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+ 
+             ## plot(test)
+             ## summary(test)
+             iConfint.final <- confint(currentGSD[[iMeth]], method = c("ML","MUE"))
+             iInfo.final <- coef(currentGSD[[iMeth]], type = "information")
+             iBoundary.final <- coef(currentGSD[[iMeth]], type = "boundary")
+             iDecision.final  <- coef(currentGSD[[iMeth]], type = "decision")
+ 
+             out.final[[iMeth]] <- data.frame(statistic = iConfint.final[1,"statistic"],
+                                              p.value_ML = iConfint.final[iConfint.final$method == "ML","p.value"],
+                                              lower_ML = iConfint.final[iConfint.final$method == "ML","lower"],
+                                              upper_ML = iConfint.final[iConfint.final$method == "ML","upper"],
+                                              estimate_ML = iConfint.final[iConfint.final$method == "ML","estimate"],
+                                              p.value_MUE = iConfint.final[iConfint.final$method == "MUE","p.value"],
+                                              lower_MUE = iConfint.final[iConfint.final$method == "MUE","lower"],
+                                              upper_MUE = iConfint.final[iConfint.final$method == "MUE","upper"],
+                                              estimate_MUE = iConfint.final[iConfint.final$method == "MUE","estimate"],
+                                              info = iInfo.final[1,"Interim"],
+                                              infoPC = iInfo.final[1,"Interim.pc"],
+                                              ck = iBoundary.final[1,"Cbound"],
+                                              decision = unname(coef(currentGSD[[iMeth]], type = "decision")["decision","stage 2"])
+                                              )
+         }
+     }
+                                         # }}}
+ 
+     stopComp <- Sys.time()
+                                         # {{{ Save results
+ 
+     outMerge <- do.call(rbind,lapply(method, function(iMeth){
+         iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+         iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+         iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+         iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+         iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+         return(iMerge)
+     }))
+ 
+     ## outMerge[outMerge$method==3,]
+ 
+     out <- cbind(
+         ## results
+         outMerge,
+         ## simulation details
+         time.interim = thet,
+         seed=myseedi,             
+         nX1.interim = sum(!is.na(di$X1)),
+         nX2.interim = sum(!is.na(di$X2)),
+         nX3.interim = sum(!is.na(di$X3)),
+         ## computation time
+         computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+     )
+     ## names(out) <- myColNames
+     RES <- rbind(RES,out)
+     save(RES,file=paste0(path.res,name,"(tempo)-",iter_sim,".rda"))
+                                         # }}}
+ }
[1] "seed 12597 for j=1 out of 250 (i.e. j=5251 in [5251;5500], as job id is i=22)"
Loading required namespace: nlme
[1] "seed 88710 for j=2 out of 250 (i.e. j=5252 in [5251;5500], as job id is i=22)"
[1] "seed 86410 for j=3 out of 250 (i.e. j=5253 in [5251;5500], as job id is i=22)"
[1] "seed 63703 for j=4 out of 250 (i.e. j=5254 in [5251;5500], as job id is i=22)"
[1] "seed 17306 for j=5 out of 250 (i.e. j=5255 in [5251;5500], as job id is i=22)"
[1] "seed 91517 for j=6 out of 250 (i.e. j=5256 in [5251;5500], as job id is i=22)"
[1] "seed 3580 for j=7 out of 250 (i.e. j=5257 in [5251;5500], as job id is i=22)"
[1] "seed 78168 for j=8 out of 250 (i.e. j=5258 in [5251;5500], as job id is i=22)"
[1] "seed 37560 for j=9 out of 250 (i.e. j=5259 in [5251;5500], as job id is i=22)"
[1] "seed 60461 for j=10 out of 250 (i.e. j=5260 in [5251;5500], as job id is i=22)"
[1] "seed 5040 for j=11 out of 250 (i.e. j=5261 in [5251;5500], as job id is i=22)"
[1] "seed 76131 for j=12 out of 250 (i.e. j=5262 in [5251;5500], as job id is i=22)"
[1] "seed 45082 for j=13 out of 250 (i.e. j=5263 in [5251;5500], as job id is i=22)"
[1] "seed 62144 for j=14 out of 250 (i.e. j=5264 in [5251;5500], as job id is i=22)"
[1] "seed 21082 for j=15 out of 250 (i.e. j=5265 in [5251;5500], as job id is i=22)"
[1] "seed 66503 for j=16 out of 250 (i.e. j=5266 in [5251;5500], as job id is i=22)"
[1] "seed 72929 for j=17 out of 250 (i.e. j=5267 in [5251;5500], as job id is i=22)"
[1] "seed 83282 for j=18 out of 250 (i.e. j=5268 in [5251;5500], as job id is i=22)"
[1] "seed 45509 for j=19 out of 250 (i.e. j=5269 in [5251;5500], as job id is i=22)"
[1] "seed 53465 for j=20 out of 250 (i.e. j=5270 in [5251;5500], as job id is i=22)"
[1] "seed 73011 for j=21 out of 250 (i.e. j=5271 in [5251;5500], as job id is i=22)"
[1] "seed 88937 for j=22 out of 250 (i.e. j=5272 in [5251;5500], as job id is i=22)"
[1] "seed 14186 for j=23 out of 250 (i.e. j=5273 in [5251;5500], as job id is i=22)"
[1] "seed 24391 for j=24 out of 250 (i.e. j=5274 in [5251;5500], as job id is i=22)"
[1] "seed 25953 for j=25 out of 250 (i.e. j=5275 in [5251;5500], as job id is i=22)"
[1] "seed 59355 for j=26 out of 250 (i.e. j=5276 in [5251;5500], as job id is i=22)"
[1] "seed 20157 for j=27 out of 250 (i.e. j=5277 in [5251;5500], as job id is i=22)"
[1] "seed 38798 for j=28 out of 250 (i.e. j=5278 in [5251;5500], as job id is i=22)"
[1] "seed 26298 for j=29 out of 250 (i.e. j=5279 in [5251;5500], as job id is i=22)"
[1] "seed 76921 for j=30 out of 250 (i.e. j=5280 in [5251;5500], as job id is i=22)"
[1] "seed 92119 for j=31 out of 250 (i.e. j=5281 in [5251;5500], as job id is i=22)"
[1] "seed 13557 for j=32 out of 250 (i.e. j=5282 in [5251;5500], as job id is i=22)"
[1] "seed 78438 for j=33 out of 250 (i.e. j=5283 in [5251;5500], as job id is i=22)"
[1] "seed 8274 for j=34 out of 250 (i.e. j=5284 in [5251;5500], as job id is i=22)"
[1] "seed 8825 for j=35 out of 250 (i.e. j=5285 in [5251;5500], as job id is i=22)"
[1] "seed 60844 for j=36 out of 250 (i.e. j=5286 in [5251;5500], as job id is i=22)"
[1] "seed 86863 for j=37 out of 250 (i.e. j=5287 in [5251;5500], as job id is i=22)"
[1] "seed 23578 for j=38 out of 250 (i.e. j=5288 in [5251;5500], as job id is i=22)"
[1] "seed 87845 for j=39 out of 250 (i.e. j=5289 in [5251;5500], as job id is i=22)"
[1] "seed 78767 for j=40 out of 250 (i.e. j=5290 in [5251;5500], as job id is i=22)"
[1] "seed 75406 for j=41 out of 250 (i.e. j=5291 in [5251;5500], as job id is i=22)"
[1] "seed 9368 for j=42 out of 250 (i.e. j=5292 in [5251;5500], as job id is i=22)"
[1] "seed 97760 for j=43 out of 250 (i.e. j=5293 in [5251;5500], as job id is i=22)"
[1] "seed 86544 for j=44 out of 250 (i.e. j=5294 in [5251;5500], as job id is i=22)"
[1] "seed 87462 for j=45 out of 250 (i.e. j=5295 in [5251;5500], as job id is i=22)"
[1] "seed 29914 for j=46 out of 250 (i.e. j=5296 in [5251;5500], as job id is i=22)"
[1] "seed 96792 for j=47 out of 250 (i.e. j=5297 in [5251;5500], as job id is i=22)"
[1] "seed 34391 for j=48 out of 250 (i.e. j=5298 in [5251;5500], as job id is i=22)"
[1] "seed 96978 for j=49 out of 250 (i.e. j=5299 in [5251;5500], as job id is i=22)"
[1] "seed 19653 for j=50 out of 250 (i.e. j=5300 in [5251;5500], as job id is i=22)"
[1] "seed 66424 for j=51 out of 250 (i.e. j=5301 in [5251;5500], as job id is i=22)"
[1] "seed 93391 for j=52 out of 250 (i.e. j=5302 in [5251;5500], as job id is i=22)"
[1] "seed 29865 for j=53 out of 250 (i.e. j=5303 in [5251;5500], as job id is i=22)"
[1] "seed 40077 for j=54 out of 250 (i.e. j=5304 in [5251;5500], as job id is i=22)"
[1] "seed 32896 for j=55 out of 250 (i.e. j=5305 in [5251;5500], as job id is i=22)"
[1] "seed 65197 for j=56 out of 250 (i.e. j=5306 in [5251;5500], as job id is i=22)"
[1] "seed 55654 for j=57 out of 250 (i.e. j=5307 in [5251;5500], as job id is i=22)"
[1] "seed 26160 for j=58 out of 250 (i.e. j=5308 in [5251;5500], as job id is i=22)"
[1] "seed 91753 for j=59 out of 250 (i.e. j=5309 in [5251;5500], as job id is i=22)"
[1] "seed 72306 for j=60 out of 250 (i.e. j=5310 in [5251;5500], as job id is i=22)"
[1] "seed 87968 for j=61 out of 250 (i.e. j=5311 in [5251;5500], as job id is i=22)"
[1] "seed 99309 for j=62 out of 250 (i.e. j=5312 in [5251;5500], as job id is i=22)"
[1] "seed 12404 for j=63 out of 250 (i.e. j=5313 in [5251;5500], as job id is i=22)"
[1] "seed 37181 for j=64 out of 250 (i.e. j=5314 in [5251;5500], as job id is i=22)"
[1] "seed 23194 for j=65 out of 250 (i.e. j=5315 in [5251;5500], as job id is i=22)"
[1] "seed 78316 for j=66 out of 250 (i.e. j=5316 in [5251;5500], as job id is i=22)"
[1] "seed 66836 for j=67 out of 250 (i.e. j=5317 in [5251;5500], as job id is i=22)"
[1] "seed 68396 for j=68 out of 250 (i.e. j=5318 in [5251;5500], as job id is i=22)"
[1] "seed 95061 for j=69 out of 250 (i.e. j=5319 in [5251;5500], as job id is i=22)"
[1] "seed 46030 for j=70 out of 250 (i.e. j=5320 in [5251;5500], as job id is i=22)"
[1] "seed 9160 for j=71 out of 250 (i.e. j=5321 in [5251;5500], as job id is i=22)"
[1] "seed 85637 for j=72 out of 250 (i.e. j=5322 in [5251;5500], as job id is i=22)"
[1] "seed 6284 for j=73 out of 250 (i.e. j=5323 in [5251;5500], as job id is i=22)"
[1] "seed 36041 for j=74 out of 250 (i.e. j=5324 in [5251;5500], as job id is i=22)"
[1] "seed 54504 for j=75 out of 250 (i.e. j=5325 in [5251;5500], as job id is i=22)"
[1] "seed 53574 for j=76 out of 250 (i.e. j=5326 in [5251;5500], as job id is i=22)"
[1] "seed 32339 for j=77 out of 250 (i.e. j=5327 in [5251;5500], as job id is i=22)"
[1] "seed 4564 for j=78 out of 250 (i.e. j=5328 in [5251;5500], as job id is i=22)"
[1] "seed 30017 for j=79 out of 250 (i.e. j=5329 in [5251;5500], as job id is i=22)"
[1] "seed 15080 for j=80 out of 250 (i.e. j=5330 in [5251;5500], as job id is i=22)"
[1] "seed 72108 for j=81 out of 250 (i.e. j=5331 in [5251;5500], as job id is i=22)"
[1] "seed 17145 for j=82 out of 250 (i.e. j=5332 in [5251;5500], as job id is i=22)"
[1] "seed 83236 for j=83 out of 250 (i.e. j=5333 in [5251;5500], as job id is i=22)"
[1] "seed 27860 for j=84 out of 250 (i.e. j=5334 in [5251;5500], as job id is i=22)"
[1] "seed 72121 for j=85 out of 250 (i.e. j=5335 in [5251;5500], as job id is i=22)"
[1] "seed 8584 for j=86 out of 250 (i.e. j=5336 in [5251;5500], as job id is i=22)"
[1] "seed 43168 for j=87 out of 250 (i.e. j=5337 in [5251;5500], as job id is i=22)"
[1] "seed 45212 for j=88 out of 250 (i.e. j=5338 in [5251;5500], as job id is i=22)"
[1] "seed 68074 for j=89 out of 250 (i.e. j=5339 in [5251;5500], as job id is i=22)"
[1] "seed 87348 for j=90 out of 250 (i.e. j=5340 in [5251;5500], as job id is i=22)"
[1] "seed 74724 for j=91 out of 250 (i.e. j=5341 in [5251;5500], as job id is i=22)"
[1] "seed 8357 for j=92 out of 250 (i.e. j=5342 in [5251;5500], as job id is i=22)"
[1] "seed 24065 for j=93 out of 250 (i.e. j=5343 in [5251;5500], as job id is i=22)"
[1] "seed 36501 for j=94 out of 250 (i.e. j=5344 in [5251;5500], as job id is i=22)"
[1] "seed 81557 for j=95 out of 250 (i.e. j=5345 in [5251;5500], as job id is i=22)"
[1] "seed 55091 for j=96 out of 250 (i.e. j=5346 in [5251;5500], as job id is i=22)"
[1] "seed 74054 for j=97 out of 250 (i.e. j=5347 in [5251;5500], as job id is i=22)"
[1] "seed 80006 for j=98 out of 250 (i.e. j=5348 in [5251;5500], as job id is i=22)"
[1] "seed 68758 for j=99 out of 250 (i.e. j=5349 in [5251;5500], as job id is i=22)"
[1] "seed 91951 for j=100 out of 250 (i.e. j=5350 in [5251;5500], as job id is i=22)"
[1] "seed 42095 for j=101 out of 250 (i.e. j=5351 in [5251;5500], as job id is i=22)"
[1] "seed 47502 for j=102 out of 250 (i.e. j=5352 in [5251;5500], as job id is i=22)"
[1] "seed 3489 for j=103 out of 250 (i.e. j=5353 in [5251;5500], as job id is i=22)"
[1] "seed 98166 for j=104 out of 250 (i.e. j=5354 in [5251;5500], as job id is i=22)"
[1] "seed 32391 for j=105 out of 250 (i.e. j=5355 in [5251;5500], as job id is i=22)"
[1] "seed 56549 for j=106 out of 250 (i.e. j=5356 in [5251;5500], as job id is i=22)"
[1] "seed 41376 for j=107 out of 250 (i.e. j=5357 in [5251;5500], as job id is i=22)"
[1] "seed 38928 for j=108 out of 250 (i.e. j=5358 in [5251;5500], as job id is i=22)"
[1] "seed 85669 for j=109 out of 250 (i.e. j=5359 in [5251;5500], as job id is i=22)"
Error in uniroot(function(x) { : 
  f() values at end points not of opposite sign
Calls: update ... update.delayedGSD -> updateBoundaries -> updateMethod1 -> uniroot
In addition: Warning messages:
1: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

2: In updateBoundaries(object, k = k, type.k = type.k, trace = trace -  :
  Information has decreased between interim and decision. 

Execution halted
