
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> rm(list=ls())
> 
> ## * User interface
> ## cd /projects/biostat01/people/hpl802/DelayedGSD/
> args <- commandArgs(TRUE) ## BATCH MODE
> 
> iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_ID"))
> n.iter_sim <- as.numeric(Sys.getenv("SLURM_ARRAY_TASK_COUNT"))
> if(length(args)>0){
+     for (arg in args){
+         eval(parse(text=arg))
+     }
+ }
> if(is.na(iter_sim)){
+     iter_sim <- 1
+     n.iter_sim <- 100
+ 
+     if("missing" %in% ls() == FALSE){ missing <- TRUE }
+ 	if("binding" %in% ls() == FALSE){ binding <- TRUE }
+     if("cNotBelowFixedc" %in% ls() == FALSE){ binding <- FALSE }
+     if("ar.factor" %in% ls() == FALSE){ ar.factor <- 5 }
+ 	if("delta.factor" %in% ls() == FALSE){ delta.factor <- 5 }
+ }
> 
> name <- ""
> if(missing>0){
+     name <- paste(name,"missing",sep="_")
+ }else{
+     name <- paste(name,"nomissing",sep="_")
+ }
> if(cNotBelowFixedc>0){
+     name <- paste(name,"fixC",sep="_")
+ }
> if(binding>0){
+     name <- paste(name,"binding",sep="_")
+ }else{
+     name <- paste(name,"nonbinding",sep="_")
+ }
> name <- paste0("2stage",name,"_ar",ar.factor)
> if(delta.factor>0){
+     name <- paste(name,"power",sep="_")
+ }else{
+     name <- paste(name,"typeI",sep="_")
+ }
> 
> cat("BATCH ",name,": ",iter_sim," over ",n.iter_sim,"\n",sep="")
BATCH 2stage_missing_nonbinding_ar10_power: 3 over 100
> 
> ## * Settings
> nsim <- 100 # number of simulations
> method <- 1:3 # methods used to compute the boundaries
> #--- to plan the trial ----
> kMax <- 2  #max number of analyses (including final)
> alpha <- 0.025  #type I error (one sided)
> beta <- 0.2  #type II error
> informationRates <- c(0.58,1)  #planned  information rates
> rho_alpha <- 2  # rho parameter for alpha error spending function
> rho_beta <- 2  # rho parameter for beta error spending function
> ## deltaPower <- 0.75 # just to try another value when Id > Imax
> Id <- 0.68  #(expected) information rate at each decision analysis
> #
> #---- to generate data -----------
> #
> block <- c(1,1,0,0) 
> allsd <- c(2.5,2.1,2.4) # sd, first from baseline measurement, then the two changes from baseline
> mean0 <- c(10,0,0) # mean placebo group (again, first is absolute value, then change from baseline)
> delta <- c(0,0.5,1)*delta.factor # treatment effect
> ar <- (0.86*2)*2*ar.factor # orginial accrual rate from data from Corine is 0.86 per week, hence we multiply by 2 for by 14 days. As too low, we further multiply by 2
> cor011 <- -0.15 # ~ from data from Corine
> corij1 <- 0.68  # ~ from data from Corine
> cor0j1 <- -0.27  # ~ from data from Corine
> Miss11 <- 5/104*missing # miss both V1 and V2
> Miss12 <- 1/104*missing # miss V1 and but not V2
> Miss21 <- 6/104*missing # do not miss V1 and but miss V2
> Miss22 <- 92/104*missing # miss none
> MyMissProb <- matrix(c(Miss11,Miss12,Miss21,Miss22),ncol=2,nrow=2,byrow=TRUE, # to additionnally remove 1 more because some FASFL=N
+                      dimnames = list(c("V1 missing","V1 not missing"), c("V2 missing","V2 not missing"))) 
> PropForInterim <- 0.5 # Decide to have interim analysiz when PropForInterim % of all subjects have had the chance to have one follow-up measuement recorded in the data to be available for analysis.
> theDelta.t <- 1.50001 # time lag to process the data and make them ready to analyze after collecting them (unit is time between two follow-up visits)
> TimeFactor <- 14 ## number of days between two visits
> #
> #--- actually for both planing the trial  and generating data-----
> #
> #
> deltaPower <- 0.6 # effect (NOT Z-scale/unit, but outcome scale/unit!) that the study is powered for: should we choose ourselves or compute from other numbers above ???
> sdPower <- allsd[3]*sqrt(1-cor0j1^2)
> n <- ceiling(2*2*((sdPower/deltaPower)^2)*(qnorm(1-beta)-qnorm(alpha))^2) #104 with Corine's data # should we choose ourselves or compute from the above numbers ???
> # inflate SS as required for interim
> 
> #adjust for expected withdrawal
> n <- n/(1-(Miss11+Miss21))
> 
> ## * Seed
> set.seed(140786598)
> nsimAll <- n.iter_sim * nsim
> allseeds <- sample.int(n = 1000000000, size = nsimAll, replace=FALSE) #x=1:(.Machine$integer.max) seems to be maximal possible
> 
> ## * Load dependencies
> library(DelayedGSD) ## remotes::install_github("PauloWhite/DelayedGSD")
DelayedGSD version 0.0.3
> source("FCT.R") ## exportGSD function
> 
> ## * Planned boundaries
> plannedB <- vector(mode = "list", length = 3)
> for(iMeth in method){ ## iMeth <- 1
+   plannedB[[iMeth]] <- CalcBoundaries(kMax=kMax,  
+                                       alpha=alpha, 
+                                       beta=beta,  
+                                       InfoR.i=informationRates,  
+                                       InfoR.d=c(Id,1),  
+                                       rho_alpha=rho_alpha,  
+                                       rho_beta=rho_beta,  
+                                       method=iMeth,  
+                                       cNotBelowFixedc=FALSE,
+                                       bindingFutility=binding,
+                                       delta=deltaPower)
+   ## summary(plannedB[[1]])
+   ## coef(plannedB[[iMeth]], type = "information")
+ }
Loading required namespace: gsDesign
Loading required package: mvtnorm
Loading required namespace: BB
> inflationFactor <- unlist(lapply(plannedB,function(iP){iP$planned$InflationFactor}))
> nGSD <- ceiling(n*inflationFactor)
> RES <- NULL
> 
> ## * Loop
> allj <- seq(1+(iter_sim-1)*nsim, iter_sim*nsim, by = 1)
> #allj <- 572:1000
> for(j in allj){ ## j <- 51 ## 5
+   startComp <- Sys.time()
+   myseedi <- allseeds[j]
+   #myseedi <- 955535360
+   # {{{ TRACE info (e.g. to check the Rout)
+   print(paste0("seed ",myseedi," for ","j=",which(j==allj)," out of ",nsim))
+   # }}}
+   
+   # {{{ generate data
+   ## ** simulate
+   res <- GenData(n=max(nGSD), 
+                  N.fw=2,
+                  rand.block=block,
+                  allsd=allsd,
+                  mean0=mean0,
+                  delta=delta,
+                  ar=ar,
+                  cor.01.1=cor011,
+                  cor.ij.1=corij1,
+                  cor.0j.1=cor0j1,
+                  seed=myseedi,
+                  MissProb=MyMissProb,
+                  DigitsOutcome=2,
+                  TimeFactor=TimeFactor,
+                  DigitsTime=0
+   )
+   d <- res$d
+   ## head(d,n=20)
+   # }}}
+   # {{{ reformat data like those of Corine
+   ## Make data long format
+   ## dd <- FormatAsCase(d)
+   ## head(dd)
+   ## summary(dd)
+   # }}}
+   
+   # {{{ make data available at interim
+   # Here we stop inclusion data collection for the interim analysis as soon as
+   # half of the participants have completed (or had the opportunity to complete) the follow-up 
+   thets <- d$t3[ceiling(nGSD*PropForInterim)]
+   #thet <- d$t3[ceiling(n*PropForInterim)]
+   
+   ## ddi <- FormatAsCase(di) # needed ????
+   ## head(d[d$id==52,])
+   # }}}
+   
+   nX1.interim <- vector()
+   nX2.interim <- vector()
+   nX3.interim <- vector()
+   currentGSD <- vector(mode = "list", length = 3)
+   out.interim <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     # {{{ make data available at interim
+     di <- SelectData(d,t=thets[iMeth])
+     
+     nX1.interim[iMeth] <- sum(!is.na(di$X1))
+     nX2.interim[iMeth] = sum(!is.na(di$X2))
+     nX3.interim[iMeth] = sum(!is.na(di$X3))
+     
+     ## {{{ analyze data at at interim
+     ## ** interim
+     lmmI <- analyzeData(di, ddf = "nlme", data.decision = sum(d$t1 <= thets[iMeth] + theDelta.t*TimeFactor), getinfo = TRUE, trace = TRUE)
+     ## lmmI <- analyzeData(di, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     currentGSD[[iMeth]] <- update(plannedB[[iMeth]], delta = lmmI, trace = FALSE)
+     
+     out.interim[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                       export.statistic = TRUE,
+                                       export.ML = TRUE,
+                                       export.MUE = FALSE,
+                                       export.info = TRUE,
+                                       export.predinfo = TRUE,
+                                       export.boundary = TRUE,
+                                       export.decision = TRUE)
+   }
+   ## currentGSD[[1]]
+   ## plot(currentGSD[[1]])
+   
+   
+   out.decision <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     
+     ## ** decision
+     dDecision <- d[which(d$t1 <= thets[iMeth] + theDelta.t*TimeFactor),]
+     lmmD <- analyzeData(dDecision, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     if(out.interim[[iMeth]]$decision == "stop"){
+       currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, trace = FALSE)
+       ## plot(currentGSD[[iMeth]])
+       
+       out.decision[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                          export.statistic = TRUE,
+                                          export.ML = TRUE,
+                                          export.MUE = TRUE,
+                                          export.info = TRUE,
+                                          export.predinfo = FALSE,
+                                          export.boundary = TRUE,
+                                          export.decision = TRUE)
+       
+       
+     }else{
+       ## update information
+       currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmD, k = 1, type.k = "decision", trace = FALSE)
+       
+       out.decision[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                          export.statistic = FALSE,
+                                          export.ML = FALSE,
+                                          export.MUE = FALSE,
+                                          export.info = TRUE,
+                                          export.predinfo = FALSE,
+                                          export.boundary = TRUE,
+                                          export.decision = FALSE)
+     }
+   }
+   # }}}
+   # {{{ Analyze data at decision
+   
+   ## ** finale
+   out.final <- vector(mode = "list", length = 3)
+   for(iMeth in method){ ## iMeth <- 1
+     dFinal <- d[1:nGSD[iMeth],]
+     lmmF <- analyzeData(dFinal, ddf = "nlme", getinfo = TRUE, trace = TRUE)
+     
+     if(out.interim[[iMeth]]$decision == "stop"){
+       
+       out.final[[iMeth]] <- exportGSD(NA)
+       
+     }else{
+       currentGSD[[iMeth]] <- update(currentGSD[[iMeth]], delta = lmmF, trace = FALSE)
+       
+       out.final[[iMeth]] <- exportGSD(currentGSD[[iMeth]],
+                                       export.statistic = TRUE,
+                                       export.ML = TRUE,
+                                       export.MUE = TRUE,
+                                       export.info = TRUE,
+                                       export.predinfo = FALSE,
+                                       export.boundary = TRUE,
+                                       export.decision = TRUE)
+       
+     }
+   }
+   # }}}
+   
+   stopComp <- Sys.time()
+   # {{{ Save results
+   outMerge <- do.call(rbind,lapply(method, function(iMeth){
+     iNames <- unique(c(names(out.interim[[iMeth]]),names(out.decision[[iMeth]]),names(out.final[[iMeth]])))
+     iMerge <- data.frame(matrix(NA, ncol = length(iNames)+3, nrow = 3, dimnames = list(NULL, c("method", "stage", "type", iNames))))
+     iMerge[1,c("method","stage","type",names(out.interim[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "interim", out.interim[[iMeth]]) 
+     iMerge[2,c("method","stage","type",names(out.decision[[iMeth]]))] <- data.frame(method = iMeth, stage = 1, type = "decision", out.decision[[iMeth]]) 
+     iMerge[3,c("method","stage","type",names(out.final[[iMeth]]))] <- data.frame(method = iMeth, stage = 2, type = "final", out.final[[iMeth]])
+     return(iMerge)
+   }))
+   
+   ## outMerge[outMerge$method==3,]
+   
+   out <- cbind(
+       ## results
+       outMerge,
+       ## simulation details
+       time.interim = rep(thets,each=3),
+       seed=myseedi,             
+       nX1.interim = rep(nX1.interim,each=3),
+       nX2.interim = rep(nX2.interim,each=3),
+       nX3.interim = rep(nX3.interim,each=3),
+       ## computation time
+       computation.time=as.double(round(difftime(stopComp,startComp,units="secs"),3))
+   )
+   ## names(out) <- myColNames
+   RES <- rbind(RES,out)
+   if(j %in% round(quantile(allj, probs = (1:10)/10))){
+       saveRDS(RES,file=file.path("Results",name,paste0("sim-",name,"-",iter_sim,"(tempo)_",nsim,".rds")))
+   }
+   # }}}
+ }
[1] "seed 490538362 for j=1 out of 100"
Loading required namespace: nlme
[1] "seed 681447409 for j=2 out of 100"
[1] "seed 630952624 for j=3 out of 100"
[1] "seed 989577592 for j=4 out of 100"
[1] "seed 882776123 for j=5 out of 100"
[1] "seed 385749732 for j=6 out of 100"
[1] "seed 972336988 for j=7 out of 100"
[1] "seed 262773604 for j=8 out of 100"
[1] "seed 518564160 for j=9 out of 100"
[1] "seed 415337433 for j=10 out of 100"
[1] "seed 619269792 for j=11 out of 100"
[1] "seed 648949735 for j=12 out of 100"
[1] "seed 239841576 for j=13 out of 100"
[1] "seed 682164918 for j=14 out of 100"
[1] "seed 344367659 for j=15 out of 100"
[1] "seed 9380677 for j=16 out of 100"
[1] "seed 452906304 for j=17 out of 100"
[1] "seed 843734697 for j=18 out of 100"
[1] "seed 64323783 for j=19 out of 100"
[1] "seed 544731170 for j=20 out of 100"
[1] "seed 279612652 for j=21 out of 100"
[1] "seed 240460026 for j=22 out of 100"
[1] "seed 981628606 for j=23 out of 100"
[1] "seed 292306763 for j=24 out of 100"
[1] "seed 320359626 for j=25 out of 100"
[1] "seed 407971177 for j=26 out of 100"
[1] "seed 974477138 for j=27 out of 100"
[1] "seed 305512476 for j=28 out of 100"
[1] "seed 43539035 for j=29 out of 100"
[1] "seed 97077065 for j=30 out of 100"
[1] "seed 864982160 for j=31 out of 100"
[1] "seed 85179638 for j=32 out of 100"
[1] "seed 631660245 for j=33 out of 100"
[1] "seed 412898145 for j=34 out of 100"
[1] "seed 128038681 for j=35 out of 100"
[1] "seed 899087277 for j=36 out of 100"
[1] "seed 112928385 for j=37 out of 100"
[1] "seed 300183278 for j=38 out of 100"
[1] "seed 526955631 for j=39 out of 100"
[1] "seed 207958253 for j=40 out of 100"
[1] "seed 793211411 for j=41 out of 100"
[1] "seed 609610507 for j=42 out of 100"
[1] "seed 286743859 for j=43 out of 100"
[1] "seed 333612852 for j=44 out of 100"
[1] "seed 76699468 for j=45 out of 100"
[1] "seed 187368342 for j=46 out of 100"
[1] "seed 311559015 for j=47 out of 100"
[1] "seed 666802382 for j=48 out of 100"
[1] "seed 616156865 for j=49 out of 100"
[1] "seed 435485383 for j=50 out of 100"
[1] "seed 160066573 for j=51 out of 100"
[1] "seed 593980050 for j=52 out of 100"
[1] "seed 469423026 for j=53 out of 100"
[1] "seed 57833369 for j=54 out of 100"
[1] "seed 938014245 for j=55 out of 100"
[1] "seed 535433126 for j=56 out of 100"
[1] "seed 48438277 for j=57 out of 100"
[1] "seed 392525588 for j=58 out of 100"
[1] "seed 346547799 for j=59 out of 100"
[1] "seed 907841222 for j=60 out of 100"
[1] "seed 629382753 for j=61 out of 100"
[1] "seed 707405491 for j=62 out of 100"
[1] "seed 520151314 for j=63 out of 100"
[1] "seed 805983828 for j=64 out of 100"
[1] "seed 393425324 for j=65 out of 100"
[1] "seed 704912086 for j=66 out of 100"
[1] "seed 26665203 for j=67 out of 100"
[1] "seed 659752784 for j=68 out of 100"
[1] "seed 805221864 for j=69 out of 100"
[1] "seed 983661269 for j=70 out of 100"
[1] "seed 942855938 for j=71 out of 100"
[1] "seed 634440654 for j=72 out of 100"
[1] "seed 278956500 for j=73 out of 100"
[1] "seed 991711259 for j=74 out of 100"
[1] "seed 101428838 for j=75 out of 100"
[1] "seed 682175965 for j=76 out of 100"
[1] "seed 590422206 for j=77 out of 100"
[1] "seed 250543637 for j=78 out of 100"
[1] "seed 153490025 for j=79 out of 100"
[1] "seed 963393016 for j=80 out of 100"
[1] "seed 410663849 for j=81 out of 100"
[1] "seed 576971053 for j=82 out of 100"
[1] "seed 650419021 for j=83 out of 100"
[1] "seed 46395187 for j=84 out of 100"
[1] "seed 482241237 for j=85 out of 100"
[1] "seed 581795050 for j=86 out of 100"
[1] "seed 494050887 for j=87 out of 100"
[1] "seed 820940168 for j=88 out of 100"
[1] "seed 74928426 for j=89 out of 100"
[1] "seed 538363672 for j=90 out of 100"
[1] "seed 930141960 for j=91 out of 100"
[1] "seed 275842197 for j=92 out of 100"
[1] "seed 144487067 for j=93 out of 100"
[1] "seed 735585658 for j=94 out of 100"
[1] "seed 214976822 for j=95 out of 100"
[1] "seed 915785440 for j=96 out of 100"
[1] "seed 19286989 for j=97 out of 100"
[1] "seed 302375566 for j=98 out of 100"
[1] "seed 90771603 for j=99 out of 100"
[1] "seed 221547126 for j=100 out of 100"
> 
> ## * Export
> rownames(RES) <- NULL
> saveRDS(RES,file=file.path("Results",name,paste0("sim-",name,"-",iter_sim,"_",nsim,".rds")))
> 
> sessionInfo()
R version 4.1.2 (2021-11-01)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux 8.5 (Ootpa)

Matrix products: default
BLAS:   /opt/software/R/4.1.2/lib64/R/lib/libRblas.so
LAPACK: /opt/software/R/4.1.2/lib64/R/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] mvtnorm_1.1-3    DelayedGSD_0.0.3

loaded via a namespace (and not attached):
 [1] magrittr_2.0.3   BB_2019.10-1     tidyselect_1.1.2 munsell_0.5.0   
 [5] lattice_0.20-45  colorspace_2.0-3 xtable_1.8-4     R6_2.5.1        
 [9] quadprog_1.5-8   rlang_1.0.6      fansi_1.0.3      dplyr_1.0.10    
[13] grid_4.1.2       nlme_3.1-153     gtable_0.3.1     gsDesign_3.3.0  
[17] utf8_1.2.2       cli_3.4.1        tibble_3.1.8     lifecycle_1.0.3 
[21] purrr_0.3.5      ggplot2_3.3.6    tidyr_1.2.1      vctrs_0.4.2     
[25] glue_1.6.2       compiler_4.1.2   pillar_1.8.1     generics_0.1.3  
[29] scales_1.2.1     pkgconfig_2.0.3 
> 
> proc.time()
   user  system elapsed 
726.883   1.539 734.200 
