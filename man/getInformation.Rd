% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getInformation.R
\name{getInformation}
\alias{getInformation}
\alias{getInformation.matrix}
\alias{getInformation.ttest}
\alias{getInformation.gls}
\alias{getInformation.lmmGSD}
\alias{getInformation.delayedGSD}
\title{Extract information relative to a parameter.}
\usage{
getInformation(object, ...)

\method{getInformation}{matrix}(object, variance, ...)

\method{getInformation}{ttest}(object, type = "estimation", variance = NULL, ...)

\method{getInformation}{gls}(
  object,
  name.coef,
  data = NULL,
  details = FALSE,
  newdata = NULL,
  variance = NULL,
  ...
)

\method{getInformation}{lmmGSD}(object, newdata = NULL, variance = NULL, weighting = FALSE, ...)

\method{getInformation}{delayedGSD}(object, planned = TRUE, ...)
}
\arguments{
\item{object}{a \code{ttest} object or a \code{gls} object.}

\item{...}{not used. For compatibility with the generic details.}

\item{variance}{[NULL, list] If \code{NULL} then the estimated variance-covariance matrix from the object is used.
Otherwise it should be a list containing the theoretical value of the variance-covariance matrix for each treatment group.}

\item{type}{[character] Should the information be estimated only for the observed data (\code{"estimation"}, excluding missing values)
or for the full dataset  (\code{"prediction"}, including missing values).}

\item{name.coef}{[character] For which coefficient the information should be computed (only relevant for gls models).}

\item{details}{[logical] Should intermediate results be output. See details section.}

\item{newdata, data}{[data.frame] The dataset relative to which the information should be computed. See details section.}

\item{weighting}{[logical] Should weight be used to handle missing values in the covariates.}

\item{planned}{[character] Should only the information used to plan the trial be output (\code{"only"}),
or only the estimated information (\code{FALSE}),
or the estimated information when available and otherwise the information used to plan the trial.}
}
\description{
Extract information relative to a parameter.
}
\details{
Argument \bold{data}: the dataset may contain missing value in the outcome but no in the covariates. Missing value in the outcome indicates that the information is not available at the interim analysis but will be come available at decision.


Argument \bold{details}: when using gls models, an attribute detail is added to the output which contain a list:
\itemize{
\item decision: information at decision analysis
\item interim: information at the interim analysis using all available data
\item interim.cc: information at the interim analysis using a complete case analysis
\item n: sample size at decision, interim with complete observation, interim with only partial observations
}
}
\examples{
library(nlme)
n <- 1e2

#### Single endpoint ####
## simulate data
set.seed(10)
X <- rnorm(n)
Y <- rnorm(n)
df <- rbind(data.frame(group=0,value=X),
            data.frame(group=1,value=Y))

## t-test
getInformation(ttest(value~1, df[df$group==0,])) ## only work for R>=4.0
getInformation(ttest(x = X)) ##  based on the estimate variance
getInformation(ttest(X), variance = 1) ## based on a variance of 1
getInformation(ttest(X), variance = 2) ## based on a variance of 2
getInformation(ttest(rnorm(length(X))), variance = 2) ## note: the X values do not matter here

getInformation(ttest(value~group, data = df))
getInformation(ttest(x = X, Y))
getInformation(ttest(X,Y), variance = 1:2) ## information with a variance of 1 in one group and 2 in the other group
getInformation(ttest(X,Y), variance = c(1,3)) ## information with a variance of 1 in one group and 3 in the other group

## gls
library(nlme)

e1.gls <- gls(value~1, data = df[df$group==0,])
getInformation(e1.gls, name.coef = "(Intercept)")
getInformation(e1.gls, name.coef = "(Intercept)", variance = matrix(1,1,1))

e2.gls <- gls(value~group, data = df, weights = varIdent(form=~1|group))
getInformation(e2.gls, name.coef = "group")
getInformation(e2.gls, name.coef = "group", variance = list(matrix(1,1,1),matrix(2,1,1)))

#### Two endpoints ####
## simulate data
library(mvtnorm)

set.seed(10)
X <- rmvnorm(n, sigma = 0.5 + diag(0.5,2))
Y <- rmvnorm(n, sigma = 0.5 + diag(0.5,2))
df <- rbind(data.frame(id = paste0("id",1:n),group=0,time=0,value=X[,1]),
            data.frame(id = paste0("id",1:n),group=0,time=1,value=X[,2]),
            data.frame(id = paste0("id",n+1:n),group=1,time=0,value=Y[,1]),
            data.frame(id = paste0("id",n+1:n),group=1,time=1,value=Y[,2]))


## gls
e.gls <- gls(value~time-1, data = df[df$group==0,],
             correlation = corSymm(form=~1|id),
             weights = varIdent(form=~1|time))
getInformation(e.gls, name.coef = "time")  ## 1/vcov(e.gls)
getInformation(e.gls, name.coef = "time", variance = list(diag(1:2)))

## with interaction
e.gls <- gls(value~time*group, data = df,
             correlation = corSymm(form=~1|id),
             weights = varIdent(form=~1|time*group))
getInformation(e.gls, name.coef = "time:group") ## 1/vcov(e.gls)
getInformation(e.gls, name.coef = "time", variance = list(diag(1:2),diag(1:2)))

## with random ordering
df2 <- df[sample.int(NROW(df)),,drop=FALSE]
e2.gls <- gls(value~time*group, data = df2,
             correlation = corSymm(form=~1|id),
             weights = varIdent(form=~1|time*group))
getInformation(e2.gls, name.coef = "time:group") ## 1/vcov(e2.gls)
getInformation(e.gls, name.coef = "time", variance = list(diag(1:2),diag(1:2)))
}
